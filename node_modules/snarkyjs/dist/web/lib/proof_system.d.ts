import { Bool, ProvablePure, Pickles, Provable } from '../snarky.js';
import { Context } from './global-context.js';
export { Proof, SelfProof, ZkProgram, verify };
export { CompiledTag, sortMethodArguments, getPreviousProofsForProver, MethodInterface, GenericArgument, picklesRuleFromFunction, compileProgram, analyzeMethod, emptyValue, emptyWitness, synthesizeMethodArguments, methodArgumentsToConstant, methodArgumentTypesAndValues, isAsFields, snarkContext, Prover, inProver, inCompile, inAnalyze, inCheckedComputation, inCompileMode, };
declare type SnarkContext = {
    witnesses?: unknown[];
    proverData?: any;
    inProver?: boolean;
    inCompile?: boolean;
    inCheckedComputation?: boolean;
    inAnalyze?: boolean;
    inRunAndCheck?: boolean;
    inWitnessBlock?: boolean;
};
declare let snarkContext: Context.t<SnarkContext>;
declare class Proof<T> {
    static publicInputType: ProvablePure<any>;
    static tag: () => {
        name: string;
    };
    publicInput: T;
    proof: RawProof;
    maxProofsVerified: 0 | 1 | 2;
    shouldVerify: Bool;
    verify(): void;
    verifyIf(condition: Bool): void;
    toJSON(): JsonProof;
    static fromJSON<S extends Subclass<typeof Proof>>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, }: JsonProof): Proof<InferInstance<S['publicInputType']>>;
    constructor({ proof, publicInput, maxProofsVerified, }: {
        proof: RawProof;
        publicInput: T;
        maxProofsVerified: 0 | 1 | 2;
    });
}
declare function verify(proof: Proof<any> | JsonProof, verificationKey: string): Promise<boolean>;
declare type RawProof = unknown;
declare type JsonProof = {
    publicInput: string[];
    maxProofsVerified: 0 | 1 | 2;
    proof: string;
};
declare type CompiledTag = unknown;
declare let CompiledTag: {
    get(tag: any): CompiledTag | undefined;
    store(tag: any, compiledTag: CompiledTag): void;
};
declare function ZkProgram<PublicInputType extends ProvablePure<any>, Types extends {
    [I in string]: Tuple<PrivateInput>;
}>({ publicInput: publicInputType, methods, }: {
    publicInput: PublicInputType;
    methods: {
        [I in keyof Types]: Method<InferInstance<PublicInputType>, Types[I]>;
    };
}): {
    name: string;
    compile: () => Promise<{
        verificationKey: string;
    }>;
    verify: (proof: Proof<InferInstance<PublicInputType>>) => Promise<boolean>;
    digest: () => string;
    publicInputType: PublicInputType;
} & {
    [I in keyof Types]: Prover<InferInstance<PublicInputType>, Types[I]>;
};
declare namespace ZkProgram {
    var Proof: <PublicInputType extends ProvablePure<any>>(program: {
        name: string;
        publicInputType: PublicInputType;
    }) => {
        new ({ proof, publicInput, maxProofsVerified, }: {
            proof: unknown;
            publicInput: InferInstance<PublicInputType>;
            maxProofsVerified: 0 | 2 | 1;
        }): {
            publicInput: InferInstance<PublicInputType>;
            proof: unknown;
            maxProofsVerified: 0 | 2 | 1;
            shouldVerify: Bool;
            verify(): void;
            verifyIf(condition: Bool): void;
            toJSON(): JsonProof;
        };
        publicInputType: PublicInputType;
        tag: () => {
            name: string;
            publicInputType: PublicInputType;
        };
        fromJSON<S extends Subclass<typeof import("./proof_system.js").Proof>>(this: S, { maxProofsVerified, proof, publicInput, }: JsonProof): Proof<InferInstance<S["publicInputType"]>>;
    };
}
declare class SelfProof<T> extends Proof<T> {
}
declare function sortMethodArguments(programName: string, methodName: string, privateInputs: unknown[], selfProof: Subclass<typeof Proof>): MethodInterface;
declare function isAsFields(type: unknown): type is Provable<unknown> & ObjectConstructor;
declare class GenericArgument {
    isEmpty: boolean;
    constructor(isEmpty?: boolean);
}
declare function getPreviousProofsForProver(methodArgs: any[], { allArgs, proofArgs }: MethodInterface): Pickles.ProofWithPublicInput[];
declare type MethodInterface = {
    methodName: string;
    witnessArgs: Provable<unknown>[];
    proofArgs: Subclass<typeof Proof>[];
    genericArgs: Subclass<typeof GenericArgument>[];
    allArgs: {
        type: 'witness' | 'proof' | 'generic';
        index: number;
    }[];
    returnType?: Provable<any>;
};
declare function compileProgram(publicInputType: ProvablePure<any>, methodIntfs: MethodInterface[], methods: ((...args: any) => void)[], proofSystemTag: {
    name: string;
}): {
    getVerificationKeyArtifact: () => {
        data: string;
        hash: string;
    };
    provers: Pickles.Prover[];
    verify: (publicInput: Pickles.PublicInput, proof: unknown) => Promise<boolean>;
    tag: unknown;
};
declare function analyzeMethod<T>(publicInputType: ProvablePure<any>, methodIntf: MethodInterface, method: (...args: any) => T): {
    rows: number;
    digest: string;
    result: T;
};
declare function picklesRuleFromFunction(publicInputType: ProvablePure<any>, func: (...args: unknown[]) => void, proofSystemTag: {
    name: string;
}, { methodName, witnessArgs, proofArgs, allArgs }: MethodInterface): Pickles.Rule;
declare function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }: MethodInterface, asVariables?: boolean): unknown[];
declare function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }: MethodInterface, args: any[]): any[];
declare type TypeAndValue<T> = {
    type: Provable<T>;
    value: T;
};
declare function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }: MethodInterface, args: unknown[]): TypeAndValue<any>[];
declare function emptyValue<T>(type: Provable<T>): T;
declare function emptyWitness<T>(type: Provable<T>): T;
declare function Prover<ProverData>(): {
    run<Result>(witnesses: unknown[], proverData: ProverData, callback: () => Promise<Result>): Promise<[SnarkContext, Result]>;
    getData(): ProverData;
};
declare function inProver(): boolean;
declare function inCompile(): boolean;
declare function inAnalyze(): boolean;
declare function inCheckedComputation(): boolean;
declare function inCompileMode(): boolean;
declare type Tuple<T> = [T, ...T[]] | [];
declare type InferInstance<T> = T extends new (...args: any) => any ? InstanceType<T> : never;
declare type TupleToInstances<T> = {
    [I in keyof T]: InferInstance<T[I]>;
};
declare type Subclass<Class extends new (...args: any) => any> = (new (...args: any) => InstanceType<Class>) & {
    [K in keyof Class]: Class[K];
} & {
    prototype: InstanceType<Class>;
};
declare type PrivateInput = Provable<any> | Subclass<typeof Proof>;
declare type Method<PublicInput, Args extends Tuple<PrivateInput>> = {
    privateInputs: Args;
    method(publicInput: PublicInput, ...args: TupleToInstances<Args>): void;
};
declare type Prover<PublicInput, Args extends Tuple<PrivateInput>> = (publicInput: PublicInput, ...args: TupleToInstances<Args>) => Promise<Proof<PublicInput>>;
