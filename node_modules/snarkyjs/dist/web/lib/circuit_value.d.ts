import 'reflect-metadata';
import { Circuit, ProvablePure, Provable } from '../snarky.js';
import { Field, Bool } from './core.js';
import { Context } from './global-context.js';
export { Circuit, CircuitValue, ProvableExtended, prop, arrayProp, matrixProp, public_, circuitMain, provable, provablePure, Struct, };
export { AnyConstructor, cloneCircuitValue, circuitValueEquals, circuitArray, memoizationContext, memoizeWitness, getBlindingValue, toConstant, InferCircuitValue, HashInput, };
declare type Constructor<T> = new (...args: any) => T;
declare type AnyConstructor = Constructor<any>;
declare type NonMethodKeys<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
declare type NonMethods<T> = Pick<T, NonMethodKeys<T>>;
declare type HashInput = {
    fields?: Field[];
    packed?: [Field, number][];
};
declare const HashInput: {
    readonly empty: {};
    append(input1: HashInput, input2: HashInput): HashInput;
};
/**
 * @deprecated `CircuitValue` is deprecated in favor of {@link Struct}, which features a simpler API and better typing.
 */
declare abstract class CircuitValue {
    constructor(...props: any[]);
    static fromObject<T extends AnyConstructor>(this: T, value: NonMethods<InstanceType<T>>): InstanceType<T>;
    static sizeInFields(): number;
    static toFields<T extends AnyConstructor>(this: T, v: InstanceType<T>): Field[];
    static toAuxiliary(): [];
    static toInput<T extends AnyConstructor>(this: T, v: InstanceType<T>): HashInput;
    toFields(): Field[];
    toJSON(): any;
    toConstant(): this;
    equals(x: this): Bool;
    assertEquals(x: this): void;
    isConstant(): boolean;
    static fromFields<T extends AnyConstructor>(this: T, xs: Field[]): InstanceType<T>;
    static check<T extends AnyConstructor>(this: T, v: InstanceType<T>): void;
    static toConstant<T extends AnyConstructor>(this: T, t: InstanceType<T>): InstanceType<T>;
    static toJSON<T extends AnyConstructor>(this: T, v: InstanceType<T>): any;
    static fromJSON<T extends AnyConstructor>(this: T, value: any): InstanceType<T>;
}
declare function prop(this: any, target: any, key: string): void;
declare function circuitArray<T, TJson = any>(elementType: Provable<T> | ProvableExtended<T, TJson>, length: number): ProvableExtended<T[], TJson[]>;
declare function arrayProp<T>(elementType: Provable<T>, length: number): (target: any, key: string) => void;
declare function matrixProp<T>(elementType: Provable<T>, nRows: number, nColumns: number): (target: any, key: string) => void;
declare function public_(target: any, _key: string | symbol, index: number): void;
declare function circuitMain(target: any, propertyName: string, _descriptor?: PropertyDescriptor): any;
declare type ProvableExtension<T, TJson = any> = {
    toInput: (x: T) => {
        fields?: Field[];
        packed?: [Field, number][];
    };
    toJSON: (x: T) => TJson;
    fromJSON: (x: TJson) => T;
};
declare type ProvableExtended<T, TJson = any> = Provable<T> & ProvableExtension<T, TJson>;
declare function provable<A>(typeObj: A, options?: {
    customObjectKeys?: string[];
    isPure?: boolean;
}): ProvableExtended<InferCircuitValue<A>, InferJson<A>>;
declare function provablePure<A>(typeObj: A, options?: {
    customObjectKeys?: string[];
}): ProvablePure<InferCircuitValue<A>> & ProvableExtension<InferCircuitValue<A>, InferJson<A>>;
/**
 * `Struct` lets you declare composite types for use in snarkyjs circuits.
 *
 * These composite types can be passed in as arguments to smart contract methods, used for on-chain state variables
 * or as event / action types.
 *
 * Here's an example of creating a "Voter" struct, which holds a public key and a collection of votes on 3 different proposals:
 * ```ts
 * let Vote = { hasVoted: Bool, inFavor: Bool };
 *
 * class Voter extends Struct({
 *   publicKey: PublicKey,
 *   votes: [Vote, Vote, Vote]
 * }) {}
 *
 * // use Voter as SmartContract input:
 * class VoterContract extends SmartContract {
 *   \@method register(voter: Voter) {
 *     // ...
 *   }
 * }
 * ```
 * In this example, there are no instance methods on the class. This makes `Voter` type-compatible with an anonymous object of the form
 * `{ publicKey: PublicKey, votes: Vote[] }`.
 * This mean you don't have to create instances by using `new Voter(...)`, you can operate with plain objects:
 * ```ts
 * voterContract.register({ publicKey, votes });
 * ```
 *
 * On the other hand, you can also add your own methods:
 * ```ts
 * class Voter extends Struct({
 *   publicKey: PublicKey,
 *   votes: [Vote, Vote, Vote]
 * }) {
 *   vote(index: number, inFavor: Bool) {
 *     let vote = this.votes[i];
 *     vote.hasVoted = Bool(true);
 *     vote.inFavor = inFavor;
 *   }
 * }
 * ```
 *
 * In this case, you'll need the constructor to create instances of `Voter`. It always takes as input the plain object:
 * ```ts
 * let emptyVote = { hasVoted: Bool(false), inFavor: Bool(false) };
 * let voter = new Voter({ publicKey, votes: Array(3).fill(emptyVote) });
 * voter.vote(1, Bool(true));
 * ```
 *
 * In addition to creating types composed of Field elements, you can also include auxiliary data which does not become part of the proof.
 * This, for example, allows you to re-use the same type outside snarkyjs methods, where you might want to store additional metadata.
 *
 * To declare non-proof values of type `string`, `number`, etc, you can use the built-in objects `String`, `Number`, etc.
 * Here's how we could add the voter's name (a string) as auxiliary data:
 * ```ts
 * class Voter extends Struct({
 *   publicKey: PublicKey,
 *   votes: [Vote, Vote, Vote],
 *   fullName: String
 * }) {}
 * ```
 *
 * Again, it's important to note that this doesn't enable you to prove anything about the `fullName` string.
 * From the circuit point of view, it simply doesn't exist!
 *
 * @param type Object specifying the layout of the `Struct`
 * @param options Advanced option which allows you to force a certain order of object keys
 * @returns Class which you can extend
 */
declare function Struct<A, T extends InferCircuitValue<A> = InferCircuitValue<A>, J extends InferJson<A> = InferJson<A>, Pure extends boolean = IsPure<A>>(type: A, options?: {
    customObjectKeys?: string[];
}): (new (value: T) => T) & (Pure extends true ? ProvablePure<T> : Provable<T>) & {
    toInput: (x: T) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: T) => J;
    fromJSON: (x: J) => T;
};
declare function cloneCircuitValue<T>(obj: T): T;
declare function circuitValueEquals<T>(a: T, b: T): boolean;
declare function toConstant<T>(type: Provable<T>, value: T): T;
declare let memoizationContext: Context.t<{
    memoized: {
        fields: Field[];
        aux: any[];
    }[];
    currentIndex: number;
    blindingValue: Field;
}>;
/**
 * Like Circuit.witness, but memoizes the witness during transaction construction
 * for reuse by the prover. This is needed to witness non-deterministic values.
 */
declare function memoizeWitness<T>(type: Provable<T>, compute: () => T): T;
declare function getBlindingValue(): Field;
declare type Tuple<T> = [T, ...T[]] | [];
declare type Primitive = typeof String | typeof Number | typeof Boolean | typeof BigInt | null | undefined;
declare type InferPrimitive<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? bigint : P extends null ? null : P extends undefined ? undefined : any;
declare type InferPrimitiveJson<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? string : P extends null ? null : P extends undefined ? null : any;
declare type InferCircuitValue<A> = A extends Constructor<infer U> ? A extends Provable<U> ? U : InferCircuitValueBase<A> : InferCircuitValueBase<A>;
declare type InferCircuitValueBase<A> = A extends Provable<infer U> ? U : A extends Primitive ? InferPrimitive<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferCircuitValue<A[I]>;
} : A extends (infer U)[] ? InferCircuitValue<U>[] : A extends Record<any, any> ? {
    [K in keyof A]: InferCircuitValue<A[K]>;
} : never;
declare type WithJson<J> = {
    toJSON: (x: any) => J;
};
declare type InferJson<A> = A extends WithJson<infer J> ? J : A extends Primitive ? InferPrimitiveJson<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferJson<A[I]>;
} : A extends WithJson<infer U>[] ? U[] : A extends Record<any, any> ? {
    [K in keyof A]: InferJson<A[K]>;
} : any;
declare type IsPure<A> = IsPureBase<A> extends true ? true : false;
declare type IsPureBase<A> = A extends ProvablePure<any> ? true : A extends Provable<any> ? false : A extends Primitive ? false : A extends (infer U)[] ? IsPure<U> : A extends Record<any, any> ? {
    [K in keyof A]: IsPure<A[K]>;
}[keyof A] : false;
