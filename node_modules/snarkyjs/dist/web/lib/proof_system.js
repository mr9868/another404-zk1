import { Bool, Field, Pickles, Circuit, Poseidon, } from '../snarky.js';
import { provable, toConstant } from './circuit_value.js';
import { Context } from './global-context.js';
// public API
export { Proof, SelfProof, ZkProgram, verify };
// internal API
export { CompiledTag, sortMethodArguments, getPreviousProofsForProver, GenericArgument, picklesRuleFromFunction, compileProgram, analyzeMethod, emptyValue, emptyWitness, synthesizeMethodArguments, methodArgumentsToConstant, methodArgumentTypesAndValues, isAsFields, snarkContext, Prover, inProver, inCompile, inAnalyze, inCheckedComputation, inCompileMode, };
let snarkContext = Context.create({ default: {} });
class Proof {
    constructor({ proof, publicInput, maxProofsVerified, }) {
        this.shouldVerify = Bool(false);
        this.publicInput = publicInput;
        this.proof = proof; // TODO optionally convert from string?
        this.maxProofsVerified = maxProofsVerified;
    }
    verify() {
        this.shouldVerify = Bool(true);
    }
    verifyIf(condition) {
        this.shouldVerify = condition;
    }
    toJSON() {
        return {
            publicInput: getPublicInputType(this.constructor)
                .toFields(this.publicInput)
                .map(String),
            maxProofsVerified: this.maxProofsVerified,
            proof: Pickles.proofToBase64([this.maxProofsVerified, this.proof]),
        };
    }
    static fromJSON({ maxProofsVerified, proof: proofString, publicInput: publicInputJson, }) {
        let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);
        let publicInput = getPublicInputType(this).fromFields(publicInputJson.map(Field));
        return new this({ publicInput, proof, maxProofsVerified });
    }
}
Proof.publicInputType = undefined;
Proof.tag = () => {
    throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:\n` +
        `class MyProof extends Proof<PublicInput> { ... }`);
};
function verify(proof, verificationKey) {
    if (typeof proof.proof === 'string') {
        // json proof
        let [, picklesProof] = Pickles.proofOfBase64(proof.proof, proof.maxProofsVerified);
        let publicInputFields = proof.publicInput.map(Field);
        return Pickles.verify(publicInputFields, picklesProof, verificationKey);
    }
    else {
        // proof class
        let publicInputFields = getPublicInputType(proof.constructor).toFields(proof.publicInput);
        return Pickles.verify(publicInputFields, proof.proof, verificationKey);
    }
}
let compiledTags = new WeakMap();
let CompiledTag = {
    get(tag) {
        return compiledTags.get(tag);
    },
    store(tag, compiledTag) {
        compiledTags.set(tag, compiledTag);
    },
};
function ZkProgram({ publicInput: publicInputType, methods, }) {
    let selfTag = { name: `Program${i++}` };
    class SelfProof extends Proof {
    }
    SelfProof.publicInputType = publicInputType;
    SelfProof.tag = () => selfTag;
    let keys = Object.keys(methods).sort(); // need to have methods in (any) fixed order
    let methodIntfs = keys.map((key) => sortMethodArguments('program', key, methods[key].privateInputs, SelfProof));
    let methodFunctions = keys.map((key) => methods[key].method);
    let maxProofsVerified = methodIntfs.reduce((acc, { proofArgs }) => Math.max(acc, proofArgs.length), 0);
    let compileOutput;
    async function compile() {
        let { provers, verify, getVerificationKeyArtifact } = compileProgram(publicInputType, methodIntfs, methodFunctions, selfTag);
        compileOutput = { provers, verify };
        return { verificationKey: getVerificationKeyArtifact().data };
    }
    function toProver(key, i) {
        async function prove(publicInput, ...args) {
            let picklesProver = compileOutput?.provers?.[i];
            if (picklesProver === undefined) {
                throw Error(`Cannot prove execution of program.${key}(), no prover found. ` +
                    `Try calling \`await program.compile()\` first, this will cache provers in the background.`);
            }
            let publicInputFields = publicInputType.toFields(publicInput);
            let previousProofs = getPreviousProofsForProver(args, methodIntfs[i]);
            let [, proof] = await snarkContext.runWithAsync({ witnesses: args, inProver: true }, () => picklesProver(publicInputFields, previousProofs));
            class ProgramProof extends Proof {
            }
            ProgramProof.publicInputType = publicInputType;
            ProgramProof.tag = () => selfTag;
            return new ProgramProof({ publicInput, proof, maxProofsVerified });
        }
        return [key, prove];
    }
    let provers = Object.fromEntries(keys.map(toProver));
    function verify(proof) {
        if (compileOutput?.verify === undefined) {
            throw Error(`Cannot verify proof, verification key not found. Try calling \`await program.compile()\` first.`);
        }
        return compileOutput.verify(publicInputType.toFields(proof.publicInput), proof.proof);
    }
    function digest() {
        let methodData = methodIntfs.map((methodEntry, i) => analyzeMethod(publicInputType, methodEntry, methodFunctions[i]));
        let hash = Poseidon.hash(Object.values(methodData).map((d) => Field(BigInt('0x' + d.digest))), false);
        return hash.toBigInt().toString(16);
    }
    return Object.assign(selfTag, { compile, verify, digest, publicInputType }, provers);
}
let i = 0;
class SelfProof extends Proof {
}
function sortMethodArguments(programName, methodName, privateInputs, selfProof) {
    let witnessArgs = [];
    let proofArgs = [];
    let allArgs = [];
    let genericArgs = [];
    for (let i = 0; i < privateInputs.length; i++) {
        let privateInput = privateInputs[i];
        if (isProof(privateInput)) {
            if (privateInput === Proof) {
                throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:\n` +
                    `class MyProof extends Proof<PublicInput> { ... }`);
            }
            allArgs.push({ type: 'proof', index: proofArgs.length });
            if (privateInput === SelfProof) {
                proofArgs.push(selfProof);
            }
            else {
                proofArgs.push(privateInput);
            }
        }
        else if (isAsFields(privateInput)) {
            allArgs.push({ type: 'witness', index: witnessArgs.length });
            witnessArgs.push(privateInput);
        }
        else if (isGeneric(privateInput)) {
            allArgs.push({ type: 'generic', index: genericArgs.length });
            genericArgs.push(privateInput);
        }
        else {
            throw Error(`Argument ${i + 1} of method ${methodName} is not a provable type: ${privateInput}`);
        }
    }
    if (proofArgs.length > 2) {
        throw Error(`${programName}.${methodName}() has more than two proof arguments, which is not supported.\n` +
            `Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
    }
    return {
        methodName,
        witnessArgs,
        proofArgs,
        allArgs,
        genericArgs,
    };
}
function isAsFields(type) {
    return ((typeof type === 'function' || typeof type === 'object') &&
        type !== null &&
        ['toFields', 'fromFields', 'sizeInFields', 'toAuxiliary'].every((s) => s in type));
}
function isProof(type) {
    // the second case covers subclasses
    return (type === Proof ||
        (typeof type === 'function' && type.prototype instanceof Proof));
}
class GenericArgument {
    constructor(isEmpty = false) {
        this.isEmpty = isEmpty;
    }
}
let emptyGeneric = () => new GenericArgument(true);
function isGeneric(type) {
    // the second case covers subclasses
    return (type === GenericArgument ||
        (typeof type === 'function' && type.prototype instanceof GenericArgument));
}
function getPreviousProofsForProver(methodArgs, { allArgs, proofArgs }) {
    let previousProofs = [];
    for (let i = 0; i < allArgs.length; i++) {
        let arg = allArgs[i];
        if (arg.type === 'proof') {
            let { proof, publicInput } = methodArgs[i];
            let publicInputType = getPublicInputType(proofArgs[arg.index]);
            previousProofs[arg.index] = {
                publicInput: publicInputType.toFields(publicInput),
                proof,
            };
        }
    }
    return previousProofs;
}
function compileProgram(publicInputType, methodIntfs, methods, proofSystemTag) {
    let rules = methodIntfs.map((methodEntry, i) => picklesRuleFromFunction(publicInputType, methods[i], proofSystemTag, methodEntry));
    let [, { getVerificationKeyArtifact, provers, verify, tag }] = snarkContext.runWith({ inCompile: true }, () => Pickles.compile(rules, publicInputType.sizeInFields()));
    CompiledTag.store(proofSystemTag, tag);
    return { getVerificationKeyArtifact, provers, verify, tag };
}
function analyzeMethod(publicInputType, methodIntf, method) {
    return Circuit.constraintSystem(() => {
        let args = synthesizeMethodArguments(methodIntf, true);
        let publicInput = emptyWitness(publicInputType);
        return method(publicInput, ...args);
    });
}
function picklesRuleFromFunction(publicInputType, func, proofSystemTag, { methodName, witnessArgs, proofArgs, allArgs }) {
    function main(publicInput, previousInputs) {
        let { witnesses: argsWithoutPublicInput } = snarkContext.get();
        let finalArgs = [];
        let proofs = [];
        for (let i = 0; i < allArgs.length; i++) {
            let arg = allArgs[i];
            if (arg.type === 'witness') {
                let type = witnessArgs[arg.index];
                finalArgs[i] = argsWithoutPublicInput
                    ? Circuit.witness(type, () => argsWithoutPublicInput[i])
                    : emptyWitness(type);
            }
            else if (arg.type === 'proof') {
                let Proof = proofArgs[arg.index];
                let publicInput = getPublicInputType(Proof).fromFields(previousInputs[arg.index]);
                let proofInstance;
                if (argsWithoutPublicInput) {
                    let { proof } = argsWithoutPublicInput[i];
                    proofInstance = new Proof({ publicInput, proof });
                }
                else {
                    proofInstance = new Proof({ publicInput, proof: undefined });
                }
                finalArgs[i] = proofInstance;
                proofs.push(proofInstance);
            }
            else if (arg.type === 'generic') {
                finalArgs[i] = argsWithoutPublicInput?.[i] ?? emptyGeneric();
            }
        }
        func(publicInputType.fromFields(publicInput), ...finalArgs);
        return proofs.map((proof) => proof.shouldVerify);
    }
    if (proofArgs.length > 2) {
        throw Error(`${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.\n` +
            `Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
    }
    let proofsToVerify = proofArgs.map((Proof) => {
        let tag = Proof.tag();
        if (tag === proofSystemTag)
            return { isSelf: true };
        else {
            let compiledTag = CompiledTag.get(tag);
            if (compiledTag === undefined) {
                throw Error(`${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.\n` +
                    `Try to run ${tag.name}.compile() first.`);
            }
            return { isSelf: false, tag: compiledTag };
        }
    });
    return { identifier: methodName, main, proofsToVerify };
}
function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }, asVariables = false) {
    let args = [];
    let empty = asVariables ? emptyWitness : emptyValue;
    for (let arg of allArgs) {
        if (arg.type === 'witness') {
            args.push(empty(witnessArgs[arg.index]));
        }
        else if (arg.type === 'proof') {
            let Proof = proofArgs[arg.index];
            let publicInput = empty(getPublicInputType(Proof));
            args.push(new Proof({ publicInput, proof: undefined }));
        }
        else if (arg.type === 'generic') {
            args.push(emptyGeneric());
        }
    }
    return args;
}
function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }, args) {
    let constArgs = [];
    for (let i = 0; i < allArgs.length; i++) {
        let arg = args[i];
        let { type, index } = allArgs[i];
        if (type === 'witness') {
            constArgs.push(toConstant(witnessArgs[index], arg));
        }
        else if (type === 'proof') {
            let Proof = proofArgs[index];
            let publicInput = toConstant(getPublicInputType(Proof), arg.publicInput);
            constArgs.push(new Proof({ publicInput, proof: arg.proof }));
        }
        else if (type === 'generic') {
            constArgs.push(arg);
        }
    }
    return constArgs;
}
let Generic = provable(null);
function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }, args) {
    let typesAndValues = [];
    for (let i = 0; i < allArgs.length; i++) {
        let arg = args[i];
        let { type, index } = allArgs[i];
        if (type === 'witness') {
            typesAndValues.push({ type: witnessArgs[index], value: arg });
        }
        else if (type === 'proof') {
            let Proof = proofArgs[index];
            typesAndValues.push({
                type: getPublicInputType(Proof),
                value: arg.publicInput,
            });
        }
        else if (type === 'generic') {
            typesAndValues.push({ type: Generic, value: arg });
        }
    }
    return typesAndValues;
}
function emptyValue(type) {
    return type.fromFields(Array(type.sizeInFields()).fill(Field(0)), type.toAuxiliary());
}
function emptyWitness(type) {
    return Circuit.witness(type, () => emptyValue(type));
}
function getPublicInputType(Proof) {
    if (Proof.publicInputType === undefined) {
        throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:\n` +
            `class MyProof extends Proof<PublicInput> { ... }`);
    }
    return Proof.publicInputType;
}
ZkProgram.Proof = function (program) {
    var _a;
    return _a = class ZkProgramProof extends Proof {
        },
        _a.publicInputType = program.publicInputType,
        _a.tag = () => program,
        _a;
};
// helpers for circuit context
function Prover() {
    return {
        async run(witnesses, proverData, callback) {
            return snarkContext.runWithAsync({ witnesses, proverData, inProver: true }, callback);
        },
        getData() {
            return snarkContext.get().proverData;
        },
    };
}
function inProver() {
    return !!snarkContext.get().inProver;
}
function inCompile() {
    return !!snarkContext.get().inCompile;
}
function inAnalyze() {
    return !!snarkContext.get().inAnalyze;
}
function inCheckedComputation() {
    let ctx = snarkContext.get();
    return !!ctx.inCompile || !!ctx.inProver || !!ctx.inCheckedComputation;
}
function inCompileMode() {
    let ctx = snarkContext.get();
    return !!ctx.inCompile || !!ctx.inAnalyze;
}
//# sourceMappingURL=proof_system.js.map