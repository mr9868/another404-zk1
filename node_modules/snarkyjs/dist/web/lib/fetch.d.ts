import 'isomorphic-fetch';
import { Bool, Field } from '../snarky.js';
import { UInt32, UInt64 } from './int.js';
import { Permissions } from './account_update.js';
import { PublicKey } from './signature.js';
import { Types } from '../provable/types.js';
export { fetchAccount, fetchLastBlock, parseFetchedAccount, markAccountToBeFetched, markNetworkToBeFetched, fetchMissingData, getCachedAccount, getCachedNetwork, addCachedAccount, defaultGraphqlEndpoint, setGraphqlEndpoint, sendZkappQuery, sendZkapp, removeJsonQuotes, };
export { Account };
declare let defaultGraphqlEndpoint: string;
/**
 * Specifies the default GraphQL endpoint.
 */
declare function setGraphqlEndpoint(graphqlEndpoint: string): void;
/**
 * Gets account information on the specified publicKey by performing a GraphQL query
 * to the specified endpoint. This will call the 'GetAccountInfo' query which fetches
 * zkapp related account information.
 *
 * If an error is returned by the specified endpoint, an error is thrown. Otherwise,
 * the data is returned.
 *
 * @param publicKey The specified account to get account information on
 * @param graphqlEndpoint The graphql endpoint to fetch from
 * @param config An object that exposes an additional timeout option
 * @returns zkapp information on the specified account or an error is thrown
 */
declare function fetchAccount(accountInfo: {
    publicKey: string | PublicKey;
    tokenId?: string;
}, graphqlEndpoint?: string, { timeout }?: {
    timeout?: number | undefined;
}): Promise<{
    account: Account;
    error: undefined;
} | {
    account: undefined;
    error: FetchError;
}>;
declare type FetchResponse = {
    data: any;
};
declare type FetchError = {
    statusCode: number;
    statusText: string;
};
declare type AuthRequired = Types.Json.AuthRequired;
declare type FetchedAccount = {
    publicKey: string;
    nonce: string;
    token: string;
    tokenSymbol: string;
    zkappUri?: string;
    zkappState: string[] | null;
    receiptChainHash?: string;
    balance: {
        total: string;
    };
    permissions?: {
        editState: AuthRequired;
        send: AuthRequired;
        receive: AuthRequired;
        setDelegate: AuthRequired;
        setPermissions: AuthRequired;
        setVerificationKey: AuthRequired;
        setZkappUri: AuthRequired;
        editSequenceState: AuthRequired;
        setTokenSymbol: AuthRequired;
        incrementNonce: AuthRequired;
        setVotingFor: AuthRequired;
    };
    delegateAccount?: {
        publicKey: string;
    };
    sequenceEvents?: string[] | null;
    verificationKey?: {
        verificationKey: string;
    };
};
declare type Account = {
    publicKey: PublicKey;
    nonce: UInt32;
    balance: UInt64;
    tokenId: Field;
    tokenSymbol: string;
    appState?: Field[];
    permissions?: Permissions;
    receiptChainHash: Field;
    delegate?: PublicKey;
    sequenceState?: Field;
    provedState: Bool;
    verificationKey?: string;
    timing?: NonNullable<Types.AccountUpdate['body']['update']['timing']['value']> & {
        isTimed: Bool;
    };
};
declare function parseFetchedAccount(account: FetchedAccount): Account;
declare function parseFetchedAccount(account: Partial<FetchedAccount>): Partial<Account>;
declare function markAccountToBeFetched(publicKey: PublicKey, tokenId: Field, graphqlEndpoint: string): void;
declare function markNetworkToBeFetched(graphqlEndpoint: string): void;
declare function fetchMissingData(graphqlEndpoint: string): Promise<void>;
declare function getCachedAccount(publicKey: PublicKey, tokenId: Field, graphqlEndpoint?: string): Account | undefined;
declare function getCachedNetwork(graphqlEndpoint?: string): {
    snarkedLedgerHash: Field;
    timestamp: UInt64;
    blockchainLength: UInt32;
    minWindowDensity: UInt32;
    totalCurrency: UInt64;
    globalSlotSinceHardFork: UInt32;
    globalSlotSinceGenesis: UInt32;
    stakingEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
    nextEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
};
/**
 * Fetches an account from the GraphQL endpoint and adds it to the local cache.
 */
declare function addCachedAccount(account: {
    publicKey: string | PublicKey;
    nonce: string | number | UInt32;
    balance?: string | number | UInt64;
    zkapp?: {
        appState: (string | number | Field)[];
    };
    tokenId: string;
}, graphqlEndpoint?: string): void;
/**
 * Fetches the last block on the Mina network.
 */
declare function fetchLastBlock(graphqlEndpoint?: string): Promise<{
    snarkedLedgerHash: Field;
    timestamp: UInt64;
    blockchainLength: UInt32;
    minWindowDensity: UInt32;
    totalCurrency: UInt64;
    globalSlotSinceHardFork: UInt32;
    globalSlotSinceGenesis: UInt32;
    stakingEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
    nextEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
}>;
/**
 * Sends a zkApp command (transaction) to the specified GraphQL endpoint.
 */
declare function sendZkapp(json: string, graphqlEndpoint?: string, { timeout }?: {
    timeout?: number | undefined;
}): Promise<[FetchResponse, undefined] | [undefined, FetchError]>;
declare function sendZkappQuery(json: string): string;
declare function removeJsonQuotes(json: string): string;
