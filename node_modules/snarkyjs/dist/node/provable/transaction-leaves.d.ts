import { Field, Bool } from '../lib/core.js';
import { UInt32, UInt64, Sign } from '../lib/int.js';
import { PublicKey } from '../lib/signature.js';
export { PublicKey, Field, Bool, AuthRequired, AuthorizationKind, UInt64, UInt32, Sign, TokenId, };
export { Events, SequenceEvents, StringWithHash, TokenSymbol, SequenceState };
declare type AuthRequired = {
    constant: Bool;
    signatureNecessary: Bool;
    signatureSufficient: Bool;
};
declare type AuthorizationKind = {
    isSigned: Bool;
    isProved: Bool;
};
declare type TokenId = Field;
declare type TokenSymbol = {
    symbol: string;
    field: Field;
};
declare const TokenId: {
    emptyValue(): Field;
    toJSON(x: Field): string;
    fromJSON(x: string): Field;
    toFields: (x: Field) => Field[];
    toAuxiliary: (x?: Field | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
}, TokenSymbol: {
    toInput({ field }: {
        symbol: string;
        field: Field;
    }): import("./generic.js").GenericHashInput<Field>;
    toJSON({ symbol }: {
        symbol: string;
        field: Field;
    }): string;
    fromJSON(symbol: string): {
        symbol: string;
        field: Field;
    };
    toFields: (x: {
        field: Field;
        symbol: string;
    }) => Field[];
    toAuxiliary: (x?: {
        field: Field;
        symbol: string;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        field: Field;
        symbol: string;
    };
    sizeInFields(): number;
    check: (x: {
        field: Field;
        symbol: string;
    }) => void;
    emptyValue?: (() => {
        field: Field;
        symbol: string;
    }) | undefined;
}, AuthRequired: {
    emptyValue(): {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    };
    toJSON(x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }): import("./transaction-leaves-json.js").AuthRequired;
    fromJSON(json: import("./transaction-leaves-json.js").AuthRequired): {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    };
    toFields: (x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }) => Field[];
    toAuxiliary: (x?: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    };
    sizeInFields(): number;
    check: (x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }) => void;
    toInput: (x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
}, AuthorizationKind: {
    toJSON(x: {
        isSigned: Bool;
        isProved: Bool;
    }): import("./transaction-leaves-json.js").AuthorizationKind;
    fromJSON(json: import("./transaction-leaves-json.js").AuthorizationKind): {
        isSigned: Bool;
        isProved: Bool;
    };
    toFields: (x: {
        isSigned: Bool;
        isProved: Bool;
    }) => Field[];
    toAuxiliary: (x?: {
        isSigned: Bool;
        isProved: Bool;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        isSigned: Bool;
        isProved: Bool;
    };
    sizeInFields(): number;
    check: (x: {
        isSigned: Bool;
        isProved: Bool;
    }) => void;
    toInput: (x: {
        isSigned: Bool;
        isProved: Bool;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    emptyValue?: (() => {
        isSigned: Bool;
        isProved: Bool;
    }) | undefined;
};
declare type Event = Field[];
declare type Events = {
    hash: Field;
    data: Event[];
};
declare type SequenceEvents = Events;
declare const Events: {
    toFields: (x: {
        data: Field[][];
        hash: Field;
    }) => Field[];
    toAuxiliary: (x?: {
        data: Field[][];
        hash: Field;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        data: Field[][];
        hash: Field;
    };
    sizeInFields(): number;
    check: (x: {
        data: Field[][];
        hash: Field;
    }) => void;
    toInput: (x: {
        data: Field[][];
        hash: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        data: Field[][];
        hash: Field;
    }) => string[][];
    fromJSON: (x: string[][]) => {
        data: Field[][];
        hash: Field;
    };
    emptyValue?: (() => {
        data: Field[][];
        hash: Field;
    }) | undefined;
    empty(): {
        hash: Field;
        data: Field[][];
    };
    pushEvent(events: {
        hash: Field;
        data: Field[][];
    }, event: Field[]): {
        hash: Field;
        data: Field[][];
    };
    hash(events: Field[][]): Field;
}, SequenceEvents: {
    toFields: (x: {
        data: Field[][];
        hash: Field;
    }) => Field[];
    toAuxiliary: (x?: {
        data: Field[][];
        hash: Field;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        data: Field[][];
        hash: Field;
    };
    sizeInFields(): number;
    check: (x: {
        data: Field[][];
        hash: Field;
    }) => void;
    toInput: (x: {
        data: Field[][];
        hash: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        data: Field[][];
        hash: Field;
    }) => string[][];
    fromJSON: (x: string[][]) => {
        data: Field[][];
        hash: Field;
    };
    emptyValue?: (() => {
        data: Field[][];
        hash: Field;
    }) | undefined;
    empty(): {
        hash: Field;
        data: Field[][];
    };
    pushEvent(sequenceEvents: {
        hash: Field;
        data: Field[][];
    }, event: Field[]): {
        hash: Field;
        data: Field[][];
    };
    hash(events: Field[][]): Field;
    emptySequenceState(): Field;
    updateSequenceState(state: Field, sequenceEventsHash: Field): Field;
};
declare type SequenceState = Field;
declare const SequenceState: {
    emptyValue: () => Field;
    toFields: (x: Field) => Field[];
    toAuxiliary: (x?: Field | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: Field) => string;
    fromJSON: (x: string) => Field;
};
declare const StringWithHash: import("./generic.js").GenericProvableExtended<{
    data: string;
    hash: Field;
}, string, Field>;
