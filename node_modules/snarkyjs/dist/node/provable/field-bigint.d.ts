import { Binable } from './binable.js';
import { GenericHashInput, GenericProvableExtended } from './generic.js';
export { Field, Bool, UInt32, UInt64, Sign };
export { pseudoClass, ProvableExtended, HashInput, ProvableBigint, BinableBigint, bigIntToBytes, sizeInBits, bytesToBigInt, };
declare type Field = bigint;
declare type Bool = 0n | 1n;
declare type UInt32 = bigint;
declare type UInt64 = bigint;
declare const sizeInBits: number;
declare type minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;
declare const minusOne: minusOne;
declare type Sign = 1n | minusOne;
declare type HashInput = GenericHashInput<Field>;
declare type ProvableExtended<T, J> = GenericProvableExtended<T, J, Field>;
declare const Field: ((value: bigint | number | string) => bigint) & {
    toBytes(t: bigint): number[];
    fromBytes(bytes: number[]): bigint;
    sizeInBytes(): number;
    toFields: (x: bigint) => bigint[];
    toAuxiliary: (x?: bigint | undefined) => any[];
    fromFields: (x: bigint[], aux: any[]) => bigint;
    sizeInFields(): number;
    check: (x: bigint) => void;
    toInput: (x: bigint) => {
        fields?: bigint[] | undefined;
        packed?: [bigint, number][] | undefined;
    };
    toJSON: (x: bigint) => string;
    fromJSON: (x: string) => bigint;
    emptyValue?: (() => bigint) | undefined;
    MODULUS: bigint;
};
declare const Bool: ((value: boolean) => Bool) & {
    toInput(x: Bool): HashInput;
    toJSON(x: Bool): boolean;
    fromJSON(x: boolean): Bool;
    sizeInBytes(): 1;
    Unsafe: {
        fromField(x: Field): 0n | 1n;
    };
    toBytes(t: Bool): number[];
    fromBytes(bytes: number[]): Bool;
    toFields: (x: Bool) => bigint[];
    toAuxiliary: (x?: Bool | undefined) => any[];
    fromFields: (x: bigint[], aux: any[]) => Bool;
    sizeInFields(): number;
    check: (x: Bool) => void;
    emptyValue?: (() => Bool) | undefined;
};
declare const UInt32: ((value: bigint | number | string) => bigint) & {
    toInput(x: bigint): HashInput;
    maxValue: bigint;
    toBytes(t: bigint): number[];
    fromBytes(bytes: number[]): bigint;
    sizeInBytes(): number;
    toFields: (x: bigint) => bigint[];
    toAuxiliary: (x?: bigint | undefined) => any[];
    fromFields: (x: bigint[], aux: any[]) => bigint;
    sizeInFields(): number;
    check: (x: bigint) => void;
    toJSON: (x: bigint) => string;
    fromJSON: (x: string) => bigint;
    emptyValue?: (() => bigint) | undefined;
};
declare const UInt64: ((value: bigint | number | string) => bigint) & {
    toInput(x: bigint): HashInput;
    maxValue: bigint;
    toBytes(t: bigint): number[];
    fromBytes(bytes: number[]): bigint;
    sizeInBytes(): number;
    toFields: (x: bigint) => bigint[];
    toAuxiliary: (x?: bigint | undefined) => any[];
    fromFields: (x: bigint[], aux: any[]) => bigint;
    sizeInFields(): number;
    check: (x: bigint) => void;
    toJSON: (x: bigint) => string;
    fromJSON: (x: string) => bigint;
    emptyValue?: (() => bigint) | undefined;
};
declare const Sign: ((value: 1 | -1) => Sign) & {
    emptyValue(): 1n;
    toInput(x: Sign): HashInput;
    fromFields([x]: Field[]): Sign;
    toJSON(x: Sign): "Positive" | "Negative";
    fromJSON(x: 'Positive' | 'Negative'): Sign;
    toBytes(t: Sign): number[];
    fromBytes(bytes: number[]): Sign;
    sizeInBytes(): number;
    toFields: (x: Sign) => bigint[];
    toAuxiliary: (x?: Sign | undefined) => any[];
    sizeInFields(): number;
    check: (x: Sign) => void;
};
declare function pseudoClass<F extends (...args: any) => any, M>(constructor: F, module: M): F & M;
declare function ProvableBigint<T extends bigint = bigint, TJSON extends string = string>(): ProvableExtended<T, TJSON>;
declare function BinableBigint<T extends bigint = bigint>(sizeInBytes: number): Binable<T>;
declare function bytesToBigInt(bytes: Uint8Array | number[]): bigint;
declare function bigIntToBytes(x: bigint, length: number): number[];
