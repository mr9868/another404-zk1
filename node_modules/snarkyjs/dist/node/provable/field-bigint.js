export { Field, Bool, UInt32, UInt64, Sign };
export { pseudoClass, ProvableBigint, BinableBigint, bigIntToBytes, sizeInBits, bytesToBigInt, };
// TODO: auto-generate
const MODULUS = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
const sizeInBits = MODULUS.toString(2).length;
const sizeInBytes = Math.ceil(sizeInBits / 8);
const minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;
const Field = pseudoClass(function Field(value) {
    return BigInt(value) % MODULUS;
}, { MODULUS, ...ProvableBigint(), ...BinableBigint(sizeInBytes) });
const Bool = pseudoClass(function Bool(value) {
    return BigInt(value);
}, {
    ...ProvableBigint(),
    ...BinableBigint(1),
    toInput(x) {
        return {
            fields: [],
            packed: [[x, 1]],
        };
    },
    toJSON(x) {
        return !!x;
    },
    fromJSON(x) {
        return BigInt(x);
    },
    sizeInBytes() {
        return 1;
    },
    Unsafe: {
        fromField(x) {
            return x;
        },
    },
});
function Unsigned(bits) {
    let maxValue = (1n << BigInt(bits)) - 1n;
    return pseudoClass(function Unsigned(value) {
        let x = BigInt(value);
        if (x < 0n)
            throw Error('Unsigned: input must be positive.');
        if (x > maxValue)
            throw Error(`Unsigned: input must fit in ${bits} bits.`);
        return BigInt(value);
    }, {
        ...ProvableBigint(),
        ...BinableBigint(Math.ceil(bits / 8)),
        toInput(x) {
            return {
                fields: [],
                packed: [[x, bits]],
            };
        },
        maxValue,
    });
}
const UInt32 = Unsigned(32);
const UInt64 = Unsigned(64);
const Sign = pseudoClass(function Sign(value) {
    if (value !== 1 && value !== -1)
        throw Error('Sign: input must be 1 or -1.');
    return (BigInt(value) % MODULUS);
}, {
    ...ProvableBigint(),
    ...BinableBigint(1),
    emptyValue() {
        return 1n;
    },
    toInput(x) {
        return {
            fields: [],
            packed: [[x === 1n ? 1n : 0n, 1]],
        };
    },
    fromFields([x]) {
        if (x === 0n)
            return 1n;
        if (x !== 1n && x !== minusOne)
            throw Error('Sign.fromFields: input must be 0, 1 or -1.');
        return x;
    },
    toJSON(x) {
        return x === 1n ? 'Positive' : 'Negative';
    },
    fromJSON(x) {
        return x === 'Positive' ? 1n : minusOne;
    },
});
// helper
function pseudoClass(constructor, module) {
    return Object.assign(constructor, module);
}
function ProvableBigint() {
    return {
        sizeInFields() {
            return 1;
        },
        toFields(x) {
            return [x];
        },
        toAuxiliary() {
            return [];
        },
        check() { },
        fromFields([x]) {
            return x;
        },
        toInput(x) {
            return { fields: [x], packed: [] };
        },
        toJSON(x) {
            return x.toString();
        },
        fromJSON(x) {
            return BigInt(x);
        },
    };
}
function BinableBigint(sizeInBytes) {
    return {
        toBytes(x) {
            return bigIntToBytes(x, sizeInBytes);
        },
        fromBytes(bytes) {
            return bytesToBigInt(bytes);
        },
        sizeInBytes() {
            return sizeInBytes;
        },
    };
}
function bytesToBigInt(bytes) {
    let x = 0n;
    let bitPosition = 0n;
    for (let byte of bytes) {
        x += BigInt(byte) << bitPosition;
        bitPosition += 8n;
    }
    return x;
}
function bigIntToBytes(x, length) {
    if (x < 0n) {
        throw Error(`bigIntToBytes: negative numbers are not supported, got ${x}`);
    }
    let bytes = Array(length);
    for (let i = 0; i < length; i++, x >>= 8n) {
        bytes[i] = Number(x & 0xffn);
    }
    return bytes;
}
//# sourceMappingURL=field-bigint.js.map