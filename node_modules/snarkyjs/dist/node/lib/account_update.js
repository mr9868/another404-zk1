import { provable, provablePure, cloneCircuitValue, memoizationContext, memoizeWitness, } from './circuit_value.js';
import { Field, Bool, Ledger, Circuit, Pickles } from '../snarky.js';
import { jsLayout } from '../provable/gen/js-layout.js';
import { Types, toJSONEssential } from '../provable/types.js';
import { PrivateKey, PublicKey } from './signature.js';
import { UInt64, UInt32, Int64 } from './int.js';
import * as Mina from './mina.js';
import * as Precondition from './precondition.js';
import { inCheckedComputation, Prover } from './proof_system.js';
import { hashWithPrefix, packToFields, prefixes, TokenSymbol } from './hash.js';
import * as Encoding from './encoding.js';
import { Context } from './global-context.js';
import { Events, SequenceEvents } from '../provable/transaction-leaves.js';
// external API
export { Permissions, AccountUpdate, ZkappPublicInput };
// internal API
export { smartContractContext, Permission, Preconditions, Body, Authorization, ZkappCommand, zkappCommandToJson, addMissingSignatures, addMissingProofs, signJsonTransaction, ZkappStateLength, Events, SequenceEvents, TokenId, Token, CallForest, createChildAccountUpdate, zkAppProver, };
const ZkappStateLength = 8;
let smartContractContext = Context.create();
let zkAppProver = Prover();
function keep(dummy) {
    return { isSome: Bool(false), value: dummy };
}
const True = () => Bool(true);
const False = () => Bool(false);
let Permission = {
    /**
     * Modification is impossible.
     */
    impossible: () => ({
        constant: True(),
        signatureNecessary: True(),
        signatureSufficient: False(),
    }),
    /**
     * Modification is always permitted
     */
    none: () => ({
        constant: True(),
        signatureNecessary: False(),
        signatureSufficient: True(),
    }),
    /**
     * Modification is permitted by zkapp proofs only
     */
    proof: () => ({
        constant: False(),
        signatureNecessary: False(),
        signatureSufficient: False(),
    }),
    /**
     * Modification is permitted by signatures only, using the private key of the zkapp account
     */
    signature: () => ({
        constant: False(),
        signatureNecessary: True(),
        signatureSufficient: True(),
    }),
    /**
     * Modification is permitted by zkapp proofs or signatures
     */
    proofOrSignature: () => ({
        constant: False(),
        signatureNecessary: False(),
        signatureSufficient: True(),
    }),
};
let Permissions = {
    ...Permission,
    /**
     * Default permissions are:
     *
     *   {@link Permissions.editState} = {@link Permission.proof}
     *
     *   {@link Permissions.send} = {@link Permission.signature}
     *
     *   {@link Permissions.receive} = {@link Permission.none}
     *
     *   {@link Permissions.setDelegate} = {@link Permission.signature}
     *
     *   {@link Permissions.setPermissions} = {@link Permission.signature}
     *
     *   {@link Permissions.setVerificationKey} = {@link Permission.signature}
     *
     *   {@link Permissions.setZkappUri} = {@link Permission.signature}
     *
     *   {@link Permissions.editSequenceState} = {@link Permission.proof}
     *
     *   {@link Permissions.setTokenSymbol} = {@link Permission.signature}
     *
     */
    default: () => ({
        editState: Permission.proof(),
        send: Permission.signature(),
        receive: Permission.none(),
        setDelegate: Permission.signature(),
        setPermissions: Permission.signature(),
        setVerificationKey: Permission.signature(),
        setZkappUri: Permission.signature(),
        editSequenceState: Permission.proof(),
        setTokenSymbol: Permission.signature(),
        incrementNonce: Permission.signature(),
        setVotingFor: Permission.signature(),
    }),
    initial: () => ({
        editState: Permission.signature(),
        send: Permission.signature(),
        receive: Permission.none(),
        setDelegate: Permission.signature(),
        setPermissions: Permission.signature(),
        setVerificationKey: Permission.signature(),
        setZkappUri: Permission.signature(),
        editSequenceState: Permission.signature(),
        setTokenSymbol: Permission.signature(),
        incrementNonce: Permission.signature(),
        setVotingFor: Permission.signature(),
    }),
    dummy: () => ({
        editState: Permission.none(),
        send: Permission.none(),
        receive: Permission.none(),
        setDelegate: Permission.none(),
        setPermissions: Permission.none(),
        setVerificationKey: Permission.none(),
        setZkappUri: Permission.none(),
        editSequenceState: Permission.none(),
        setTokenSymbol: Permission.none(),
        incrementNonce: Permission.none(),
        setVotingFor: Permission.none(),
    }),
    fromString: (permission) => {
        switch (permission) {
            case 'None':
                return Permission.none();
            case 'Either':
                return Permission.proofOrSignature();
            case 'Proof':
                return Permission.proof();
            case 'Signature':
                return Permission.signature();
            case 'Impossible':
                return Permission.impossible();
            default:
                throw Error(`Cannot parse invalid permission. ${permission} does not exist.`);
        }
    },
    fromJSON: (permissions) => {
        return Object.fromEntries(Object.entries(permissions).map(([k, v]) => [
            k,
            Permissions.fromString(v),
        ]));
    },
};
const Body = {
    noUpdate() {
        return {
            appState: Array(ZkappStateLength)
                .fill(0)
                .map(() => keep(Field(0))),
            delegate: keep(PublicKey.empty()),
            // TODO
            verificationKey: keep({ data: '', hash: Field(0) }),
            permissions: keep(Permissions.initial()),
            // TODO don't hard code
            zkappUri: keep({
                data: '',
                hash: Field('22930868938364086394602058221028773520482901241511717002947639863679740444066'),
            }),
            // TODO
            tokenSymbol: keep(TokenSymbol.empty),
            timing: keep({
                cliffAmount: UInt64.zero,
                cliffTime: UInt32.zero,
                initialMinimumBalance: UInt64.zero,
                vestingIncrement: UInt64.zero,
                vestingPeriod: UInt32.zero,
            }),
            votingFor: keep(Field(0)),
        };
    },
    /**
     * A body that Don't change part of the underlying account record.
     */
    keepAll(publicKey) {
        return {
            publicKey,
            update: Body.noUpdate(),
            tokenId: TokenId.default,
            balanceChange: Int64.zero,
            events: Events.empty(),
            sequenceEvents: SequenceEvents.empty(),
            caller: TokenId.default,
            callData: Field(0),
            callDepth: 0,
            preconditions: Preconditions.ignoreAll(),
            // the default assumption is that snarkyjs transactions don't include the fee payer
            // so useFullCommitment has to be false for signatures to be correct
            useFullCommitment: Bool(false),
            // this should be set to true if accountUpdates are signed
            incrementNonce: Bool(false),
            authorizationKind: { isSigned: Bool(false), isProved: Bool(false) },
        };
    },
    dummy() {
        return Body.keepAll(PublicKey.empty());
    },
};
const FeePayerBody = {
    keepAll(publicKey, nonce) {
        return {
            publicKey,
            nonce,
            fee: UInt64.zero,
            validUntil: undefined,
        };
    },
};
let NetworkPrecondition = {
    ignoreAll() {
        let stakingEpochData = {
            ledger: { hash: ignore(Field(0)), totalCurrency: ignore(uint64()) },
            seed: ignore(Field(0)),
            startCheckpoint: ignore(Field(0)),
            lockCheckpoint: ignore(Field(0)),
            epochLength: ignore(uint32()),
        };
        let nextEpochData = cloneCircuitValue(stakingEpochData);
        return {
            snarkedLedgerHash: ignore(Field(0)),
            timestamp: ignore(uint64()),
            blockchainLength: ignore(uint32()),
            minWindowDensity: ignore(uint32()),
            totalCurrency: ignore(uint64()),
            globalSlotSinceHardFork: ignore(uint32()),
            globalSlotSinceGenesis: ignore(uint32()),
            stakingEpochData,
            nextEpochData,
        };
    },
};
/**
 * Ignores a `dummy`
 *
 * @param dummy The value to ignore
 * @returns Always an ignored value regardless of the input.
 */
function ignore(dummy) {
    return { isSome: Bool(false), value: dummy };
}
/**
 * Ranges between all uint32 values
 */
const uint32 = () => ({ lower: UInt32.from(0), upper: UInt32.MAXINT() });
/**
 * Ranges between all uint64 values
 */
const uint64 = () => ({ lower: UInt64.from(0), upper: UInt64.MAXINT() });
const AccountPrecondition = {
    ignoreAll() {
        let appState = [];
        for (let i = 0; i < ZkappStateLength; ++i) {
            appState.push(ignore(Field(0)));
        }
        return {
            balance: ignore(uint64()),
            nonce: ignore(uint32()),
            receiptChainHash: ignore(Field(0)),
            delegate: ignore(PublicKey.empty()),
            state: appState,
            sequenceState: ignore(SequenceEvents.emptySequenceState()),
            provedState: ignore(Bool(false)),
            isNew: ignore(Bool(false)),
        };
    },
    nonce(nonce) {
        let p = AccountPrecondition.ignoreAll();
        AccountUpdate.assertEquals(p.nonce, nonce);
        return p;
    },
};
const Preconditions = {
    ignoreAll() {
        return {
            account: AccountPrecondition.ignoreAll(),
            network: NetworkPrecondition.ignoreAll(),
        };
    },
};
const TokenId = {
    ...Types.TokenId,
    ...Encoding.TokenId,
    get default() {
        return Field(1);
    },
};
class Token {
    constructor({ tokenOwner, parentTokenId = TokenId.default, }) {
        this.parentTokenId = parentTokenId;
        this.tokenOwner = tokenOwner;
        try {
            this.id = Token.getId(tokenOwner, parentTokenId);
        }
        catch (e) {
            throw new Error(`Could not create a custom token id:\nError: ${e.message}`);
        }
    }
    static getId(tokenOwner, parentTokenId = TokenId.default) {
        if (tokenOwner.isConstant() && parentTokenId.isConstant()) {
            return Ledger.customTokenId(tokenOwner, parentTokenId);
        }
        else {
            return Ledger.customTokenIdChecked(tokenOwner, parentTokenId);
        }
    }
}
Token.Id = TokenId;
/**
 * An {@link AccountUpdate} is a set of instructions for the Mina network.
 * It includes {@link Preconditions} and a list of state updates, which need to be authorized by either a {@link Signature} or {@link Proof}.
 */
class AccountUpdate {
    constructor(body, authorization = {}, isSelf = false) {
        /**
         * A human-readable label for the account update, indicating how that update was created.
         * Can be modified by applications to add richer information.
         */
        this.label = '';
        this.isDelegateCall = Bool(false);
        this.lazyAuthorization = undefined;
        this.children = {
            callsType: { type: 'None' },
            accountUpdates: [],
        };
        this.parent = undefined;
        this.id = Math.random();
        this.body = body;
        this.authorization = authorization;
        let { account, network } = Precondition.preconditions(this, isSelf);
        this.account = account;
        this.network = network;
        this.isSelf = isSelf;
    }
    /**
     * Clones the {@link AccountUpdate}.
     */
    static clone(accountUpdate) {
        let body = cloneCircuitValue(accountUpdate.body);
        let authorization = cloneCircuitValue(accountUpdate.authorization);
        let cloned = new AccountUpdate(body, authorization, accountUpdate.isSelf);
        cloned.lazyAuthorization = accountUpdate.lazyAuthorization;
        cloned.children.callsType = accountUpdate.children.callsType;
        cloned.children.accountUpdates = accountUpdate.children.accountUpdates.map(AccountUpdate.clone);
        cloned.id = accountUpdate.id;
        cloned.label = accountUpdate.label;
        cloned.parent = accountUpdate.parent;
        cloned.isDelegateCall = accountUpdate.isDelegateCall;
        return cloned;
    }
    token() {
        let thisAccountUpdate = this;
        let customToken = new Token({
            tokenOwner: thisAccountUpdate.body.publicKey,
            parentTokenId: thisAccountUpdate.body.tokenId,
        });
        return {
            id: customToken.id,
            parentTokenId: customToken.parentTokenId,
            tokenOwner: customToken.tokenOwner,
            mint({ address, amount, }) {
                let receiver = AccountUpdate.defaultAccountUpdate(address, this.id);
                thisAccountUpdate.approve(receiver);
                // Add the amount to mint to the receiver's account
                receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
                return receiver;
            },
            burn({ address, amount, }) {
                let sender = AccountUpdate.defaultAccountUpdate(address, this.id);
                thisAccountUpdate.approve(sender);
                sender.body.useFullCommitment = Bool(true);
                // Sub the amount to burn from the sender's account
                sender.body.balanceChange = Int64.fromObject(sender.body.balanceChange).sub(amount);
                // Require signature from the sender account being deducted
                Authorization.setLazySignature(sender);
            },
            send({ from, to, amount, }) {
                // Create a new accountUpdate for the sender to send the amount to the receiver
                let sender = AccountUpdate.defaultAccountUpdate(from, this.id);
                thisAccountUpdate.approve(sender);
                sender.body.useFullCommitment = Bool(true);
                sender.body.balanceChange = Int64.fromObject(sender.body.balanceChange).sub(amount);
                // Require signature from the sender accountUpdate
                Authorization.setLazySignature(sender);
                let receiverAccountUpdate = createChildAccountUpdate(thisAccountUpdate, to, this.id);
                // Add the amount to send to the receiver's account
                let i1 = receiverAccountUpdate.body.balanceChange;
                receiverAccountUpdate.body.balanceChange = new Int64(i1.magnitude, i1.sgn).add(amount);
                return receiverAccountUpdate;
            },
        };
    }
    get tokenId() {
        return this.body.tokenId;
    }
    get tokenSymbol() {
        let accountUpdate = this;
        return {
            set(tokenSymbol) {
                AccountUpdate.setValue(accountUpdate.update.tokenSymbol, TokenSymbol.from(tokenSymbol));
            },
        };
    }
    send({ to, amount, }) {
        let receiver;
        if (to instanceof AccountUpdate) {
            receiver = to;
            receiver.body.tokenId.assertEquals(this.body.tokenId);
        }
        else {
            receiver = AccountUpdate.defaultAccountUpdate(to, this.body.tokenId);
        }
        this.approve(receiver);
        // Sub the amount from the sender's account
        this.body.balanceChange = Int64.fromObject(this.body.balanceChange).sub(amount);
        // Add the amount to send to the receiver's account
        receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
    }
    /**
     * Makes an {@link AccountUpdate} a child-{@link AccountUpdate} of this and approves it.
     */
    approve(childUpdate, layout = AccountUpdate.Layout.NoDelegation) {
        makeChildAccountUpdate(this, childUpdate);
        this.isDelegateCall = Bool(false);
        AccountUpdate.witnessChildren(childUpdate, layout, { skipCheck: true });
    }
    get balance() {
        let accountUpdate = this;
        return {
            addInPlace(x) {
                let { magnitude, sgn } = accountUpdate.body.balanceChange;
                accountUpdate.body.balanceChange = new Int64(magnitude, sgn).add(x);
            },
            subInPlace(x) {
                let { magnitude, sgn } = accountUpdate.body.balanceChange;
                accountUpdate.body.balanceChange = new Int64(magnitude, sgn).sub(x);
            },
        };
    }
    get update() {
        return this.body.update;
    }
    static setValue(maybeValue, value) {
        maybeValue.isSome = Bool(true);
        maybeValue.value = value;
    }
    /** Constrain a property to lie between lower and upper bounds.
     *
     * @param property The property to constrain
     * @param lower The lower bound
     * @param upper The upper bound
     *
     * Example: To constrain the account balance of a SmartContract to lie between 0 and 20 MINA, you can use
     *
     * ```ts
     * \@method onlyRunsWhenBalanceIsLow() {
     *   let lower = UInt64.zero;
     *   let upper = UInt64.from(20e9);
     *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);
     *   // ...
     * }
     * ```
     */
    static assertBetween(property, lower, upper) {
        property.isSome = Bool(true);
        property.value.lower = lower;
        property.value.upper = upper;
    }
    // TODO: assertGreaterThan, assertLowerThan?
    /** Fix a property to a certain value.
     *
     * @param property The property to constrain
     * @param value The value it is fixed to
     *
     * Example: To fix the account nonce of a SmartContract to 0, you can use
     *
     * ```ts
     * \@method onlyRunsWhenNonceIsZero() {
     *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);
     *   // ...
     * }
     * ```
     */
    static assertEquals(property, value) {
        property.isSome = Bool(true);
        if ('lower' in property.value && 'upper' in property.value) {
            property.value.lower = value;
            property.value.upper = value;
        }
        else {
            property.value = value;
        }
    }
    get publicKey() {
        return this.body.publicKey;
    }
    /**
     * Use this command if this account update should be signed by the account owner,
     * instead of not having any authorization.
     *
     * If you use this and are not relying on a wallet to sign your transaction, then you should use the following code
     * before sending your transaction:
     *
     * ```ts
     * let tx = Mina.transaction(...); // create transaction as usual, using `requireSignature()` somewhere
     * tx.sign([privateKey]); // pass the private key of this account to `sign()`!
     * ```
     *
     * Note that an account's {@link Permissions} determine which updates have to be (can be) authorized by a signature.
     */
    requireSignature() {
        let nonce = AccountUpdate.getNonce(this);
        this.account.nonce.assertEquals(nonce);
        this.body.incrementNonce = Bool(true);
        Authorization.setLazySignature(this, {});
    }
    /**
     * @deprecated `.sign()` is deprecated in favor of `.requireSignature()`
     */
    sign(privateKey) {
        let nonce = AccountUpdate.getNonce(this);
        this.account.nonce.assertEquals(nonce);
        this.body.incrementNonce = Bool(true);
        Authorization.setLazySignature(this, { privateKey });
    }
    static signFeePayerInPlace(feePayer, privateKey) {
        feePayer.body.nonce = this.getNonce(feePayer);
        feePayer.authorization = Ledger.dummySignature();
        feePayer.lazyAuthorization = { kind: 'lazy-signature', privateKey };
    }
    static getNonce(accountUpdate) {
        return memoizeWitness(UInt32, () => AccountUpdate.getNonceUnchecked(accountUpdate));
    }
    static getNonceUnchecked(update) {
        let publicKey = update.body.publicKey;
        let tokenId = update instanceof AccountUpdate ? update.body.tokenId : TokenId.default;
        let nonce = Number(Precondition.getAccountPreconditions(update.body).nonce.toString());
        // if the fee payer is the same account update as this one, we have to start the nonce predicate at one higher,
        // bc the fee payer already increases its nonce
        let isFeePayer = Mina.currentTransaction()?.sender?.equals(publicKey);
        let shouldIncreaseNonce = isFeePayer?.and(tokenId.equals(TokenId.default));
        if (shouldIncreaseNonce?.toBoolean())
            nonce++;
        // now, we check how often this accountUpdate already updated its nonce in this tx, and increase nonce from `getAccount` by that amount
        CallForest.forEachPredecessor(Mina.currentTransaction.get().accountUpdates, update, (otherUpdate) => {
            let shouldIncreaseNonce = otherUpdate.publicKey
                .equals(publicKey)
                .and(otherUpdate.tokenId.equals(tokenId))
                .and(otherUpdate.body.incrementNonce);
            if (shouldIncreaseNonce.toBoolean())
                nonce++;
        });
        return UInt32.from(nonce);
    }
    toJSON() {
        return Types.AccountUpdate.toJSON(this);
    }
    static toJSON(a) {
        return Types.AccountUpdate.toJSON(a);
    }
    static fromJSON(json) {
        let accountUpdate = Types.AccountUpdate.fromJSON(json);
        return new AccountUpdate(accountUpdate.body, accountUpdate.authorization);
    }
    hash() {
        // these two ways of hashing are (and have to be) consistent / produce the same hash
        // TODO: there's no reason anymore to use two different hashing methods here!
        // -- the "inCheckedComputation" branch works in all circumstances now
        // we just leave this here for a couple more weeks, because it checks consistency between
        // JS & OCaml hashing on *every single accountUpdate proof* we create. It will give us 100%
        // confidence that the two implementations are equivalent, and catch regressions quickly
        if (inCheckedComputation()) {
            let input = Types.AccountUpdate.toInput(this);
            return hashWithPrefix(prefixes.body, packToFields(input));
        }
        else {
            let json = Types.AccountUpdate.toJSON(this);
            return Ledger.hashAccountUpdateFromJson(JSON.stringify(json));
        }
    }
    // TODO: this was only exposed to be used in a unit test
    // consider removing when we have inline unit tests
    toPublicInput() {
        let accountUpdate = this.hash();
        let calls = CallForest.hashChildren(this);
        return { accountUpdate, calls };
    }
    static defaultAccountUpdate(address, tokenId) {
        const body = Body.keepAll(address);
        if (tokenId) {
            body.tokenId = tokenId;
            body.caller = tokenId;
        }
        return new AccountUpdate(body);
    }
    static dummy() {
        return this.defaultAccountUpdate(PublicKey.empty());
    }
    isDummy() {
        return this.body.publicKey.isEmpty();
    }
    static defaultFeePayer(address, key, nonce) {
        let body = FeePayerBody.keepAll(address, nonce);
        return {
            body,
            authorization: Ledger.dummySignature(),
            lazyAuthorization: { kind: 'lazy-signature', privateKey: key },
        };
    }
    static dummyFeePayer() {
        let body = FeePayerBody.keepAll(PublicKey.empty(), UInt32.zero);
        return { body, authorization: Ledger.dummySignature() };
    }
    static create(publicKey, tokenId) {
        let accountUpdate = AccountUpdate.defaultAccountUpdate(publicKey, tokenId);
        if (smartContractContext.has()) {
            smartContractContext.get().this.self.approve(accountUpdate);
        }
        else {
            Mina.currentTransaction()?.accountUpdates.push(accountUpdate);
        }
        return accountUpdate;
    }
    static attachToTransaction(accountUpdate) {
        if (smartContractContext.has()) {
            let selfUpdate = smartContractContext.get().this.self;
            // avoid redundant attaching & cycle in account update structure, happens
            // when calling attachToTransaction(this.self) inside a @method
            // TODO avoid account update cycles more generally
            if (selfUpdate === accountUpdate)
                return;
            smartContractContext.get().this.self.approve(accountUpdate);
        }
        else {
            if (!Mina.currentTransaction.has())
                return;
            let updates = Mina.currentTransaction.get().accountUpdates;
            if (!updates.find((update) => update.id === accountUpdate.id)) {
                updates.push(accountUpdate);
            }
        }
    }
    static createSigned(signer) {
        let publicKey = signer.toPublicKey();
        if (!Mina.currentTransaction.has()) {
            throw new Error('AccountUpdate.createSigned: Cannot run outside of a transaction');
        }
        let accountUpdate = AccountUpdate.defaultAccountUpdate(publicKey);
        // it's fine to compute the nonce outside the circuit, because we're constraining it with a precondition
        let nonce = Circuit.witness(UInt32, () => AccountUpdate.getNonceUnchecked(accountUpdate));
        accountUpdate.account.nonce.assertEquals(nonce);
        accountUpdate.body.incrementNonce = Bool(true);
        Authorization.setLazySignature(accountUpdate, { privateKey: signer });
        Mina.currentTransaction.get().accountUpdates.push(accountUpdate);
        return accountUpdate;
    }
    /**
     * Use this method to pay the account creation fee for another account.
     * Beware that you _don't_ need to pass in the new account!
     * Instead, the protocol will automatically identify accounts in your transaction that need funding.
     *
     * If you provide an optional `initialBalance`, this will be subtracted from the fee-paying account as well,
     * but you have to separately ensure that it's added to the new account's balance.
     *
     * @param feePayerKey the private key of the account that pays the fee
     * @param initialBalance the initial balance of the new account (default: 0)
     */
    static fundNewAccount(feePayerKey, { initialBalance = UInt64.zero } = {}) {
        let accountUpdate = AccountUpdate.createSigned(feePayerKey);
        let amount = initialBalance instanceof UInt64
            ? initialBalance
            : UInt64.from(`${initialBalance}`);
        accountUpdate.balance.subInPlace(amount.add(Mina.accountCreationFee()));
    }
    toProvable() {
        return { accountUpdate: this, isDelegateCall: this.isDelegateCall };
    }
    static toFields(a) {
        return AccountUpdate.provable.toFields(a.toProvable());
    }
    static toAuxiliary(a) {
        let aux = AccountUpdate.provable.toAuxiliary(a?.toProvable());
        let children = {
            callsType: { type: 'None' },
            accountUpdates: [],
        };
        let lazyAuthorization = a && a.lazyAuthorization;
        if (a) {
            children.callsType = a.children.callsType;
            children.accountUpdates = a.children.accountUpdates.map(AccountUpdate.clone);
        }
        let parent = a?.parent;
        let id = a?.id ?? Math.random();
        let label = a?.label ?? '';
        return [{ lazyAuthorization, children, parent, id, label }, aux];
    }
    static toInput(a) {
        return AccountUpdate.provable.toInput(a.toProvable());
    }
    static check(a) {
        AccountUpdate.provable.check(a.toProvable());
    }
    static fromFields(fields, [other, aux]) {
        let { accountUpdate, isDelegateCall } = AccountUpdate.provable.fromFields(fields, aux);
        return Object.assign(new AccountUpdate(accountUpdate.body, accountUpdate.authorization), { isDelegateCall }, other);
    }
    static witness(type, compute, { skipCheck = false } = {}) {
        // construct the circuit type for a accountUpdate + other result
        let accountUpdateType = skipCheck
            ? { ...provable(AccountUpdate), check() { } }
            : AccountUpdate;
        let combinedType = provable({
            accountUpdate: accountUpdateType,
            result: type,
        });
        return Circuit.witness(combinedType, compute);
    }
    static witnessChildren(accountUpdate, childLayout, options) {
        // just witness children's hash if childLayout === null
        if (childLayout === AccountUpdate.Layout.AnyChildren) {
            accountUpdate.children.callsType = { type: 'Witness' };
            return;
        }
        if (childLayout === AccountUpdate.Layout.NoDelegation) {
            accountUpdate.children.callsType = { type: 'Witness' };
            accountUpdate.isDelegateCall.assertFalse();
            return;
        }
        let childArray = typeof childLayout === 'number'
            ? Array(childLayout).fill(AccountUpdate.Layout.NoChildren)
            : childLayout;
        let n = childArray.length;
        for (let i = 0; i < n; i++) {
            accountUpdate.children.accountUpdates[i] = AccountUpdate.witnessTree(provable(null), childArray[i], () => ({
                accountUpdate: accountUpdate.children.accountUpdates[i] ?? AccountUpdate.dummy(),
                result: null,
            }), options).accountUpdate;
        }
        if (n === 0) {
            accountUpdate.children.callsType = {
                type: 'Equals',
                value: CallForest.emptyHash(),
            };
        }
    }
    /**
     * Like AccountUpdate.witness, but lets you specify a layout for the accountUpdate's children,
     * which also get witnessed
     */
    static witnessTree(resultType, childLayout, compute, options) {
        // witness the root accountUpdate
        let { accountUpdate, result } = AccountUpdate.witness(resultType, compute, options);
        // witness child account updates
        AccountUpdate.witnessChildren(accountUpdate, childLayout, options);
        return { accountUpdate, result };
    }
    /**
     * Returns a JSON representation of only the fields that differ from the default {@link AccountUpdate}.
     */
    toPretty() {
        function short(s) {
            return '..' + s.slice(-4);
        }
        let jsonUpdate = toJSONEssential(jsLayout.AccountUpdate, this);
        let body = jsonUpdate.body;
        delete body.callData;
        body.publicKey = short(body.publicKey);
        if (body.balanceChange?.magnitude === '0')
            delete body.balanceChange;
        if (body.tokenId === TokenId.toBase58(TokenId.default)) {
            delete body.tokenId;
        }
        else {
            body.tokenId = short(body.tokenId);
        }
        if (body.caller === TokenId.toBase58(TokenId.default)) {
            delete body.caller;
        }
        else {
            body.caller = short(body.caller);
        }
        if (body.incrementNonce === false)
            delete body.incrementNonce;
        if (body.useFullCommitment === false)
            delete body.useFullCommitment;
        if (body.events?.length === 0)
            delete body.events;
        if (body.sequenceEvents?.length === 0)
            delete body.sequenceEvents;
        if (body.preconditions?.account) {
            body.preconditions.account = JSON.stringify(body.preconditions.account);
        }
        if (body.preconditions?.network) {
            body.preconditions.network = JSON.stringify(body.preconditions.network);
        }
        if (jsonUpdate.authorization?.proof) {
            jsonUpdate.authorization.proof = short(jsonUpdate.authorization.proof);
        }
        if (jsonUpdate.authorization?.signature) {
            jsonUpdate.authorization.signature = short(jsonUpdate.authorization.signature);
        }
        if (body.update?.verificationKey) {
            body.update.verificationKey = JSON.stringify({
                data: short(body.update.verificationKey.data),
                hash: short(body.update.verificationKey.hash),
            });
        }
        for (let key of ['permissions', 'appState', 'timing']) {
            if (body.update?.[key]) {
                body.update[key] = JSON.stringify(body.update[key]);
            }
        }
        for (let key of ['events', 'sequenceEvents']) {
            if (body[key]) {
                body[key] = JSON.stringify(body[key]);
            }
        }
        if (jsonUpdate.authorization !== undefined ||
            body.authorizationKind !== 'None_given') {
            body.authorization = jsonUpdate.authorization;
        }
        if (this.isDelegateCall.toBoolean())
            body.isDelegateCall = true;
        let pretty = { ...body };
        let withId = false;
        if (withId)
            pretty = { id: Math.floor(this.id * 1000), ...pretty };
        if (this.label)
            pretty = { label: this.label, ...pretty };
        return pretty;
    }
}
AccountUpdate.SequenceEvents = SequenceEvents;
// static methods that implement Provable<[AccountUpdate, Bool]>, where he Bool is for `isDelegateCall`
AccountUpdate.provable = provable({
    accountUpdate: Types.AccountUpdate,
    isDelegateCall: Bool,
});
AccountUpdate.sizeInFields = AccountUpdate.provable.sizeInFields;
/**
 * Describes the children of an account update, which are laid out in a tree.
 *
 * The tree layout is described recursively by using a combination of `AccountUpdate.Layout.NoChildren`, `AccountUpdate.Layout.StaticChildren(...)` and `AccountUpdate.Layout.AnyChildren`.
 * - `NoChildren` means an account update that can't have children
 * - `AnyChildren` means an account update can have an arbitrary amount of children, which means you can't access those children in your circuit (because the circuit is static).
 * - `StaticChildren` means the account update must have a certain static amount of children and expects as arguments a description of each of those children.
 *   As a shortcut, you can also pass `StaticChildren` a number, which means it has that amount of children but no grandchildren.
 *
 * This is best understood by examples:
 *
 * ```ts
 * let { NoChildren, AnyChildren, StaticChildren } = AccounUpdate.Layout;
 *
 * NoChildren                 // an account update with no children
 * AnyChildren                // an account update with arbitrary children
 * StaticChildren(NoChildren) // an account update with 1 child, which doesn't have children itself
 * StaticChildren(1)          // shortcut for StaticChildren(NoChildren)
 * StaticChildren(2)          // shortcut for StaticChildren(NoChildren, NoChildren)
 * StaticChildren(0)          // equivalent to NoChildren
 *
 * // an update with 2 children, of which one has arbitrary children and the other has exactly 1 descendant
 * StaticChildren(AnyChildren, StaticChildren(1))
 * ```
 */
AccountUpdate.Layout = {
    StaticChildren: ((...args) => {
        if (args.length === 1 && typeof args[0] === 'number')
            return args[0];
        if (args.length === 0)
            return 0;
        return args;
    }),
    NoChildren: 0,
    AnyChildren: 'AnyChildren',
    NoDelegation: 'NoDelegation',
};
const CallForest = {
    // similar to Mina_base.ZkappCommand.Call_forest.to_account_updates_list
    // takes a list of accountUpdates, which each can have children, so they form a "forest" (list of trees)
    // returns a flattened list, with `accountUpdate.body.callDepth` specifying positions in the forest
    // also removes any "dummy" accountUpdates
    toFlatList(forest, depth = 0) {
        let accountUpdates = [];
        for (let accountUpdate of forest) {
            if (accountUpdate.isDummy().toBoolean())
                continue;
            accountUpdate.body.callDepth = depth;
            let children = accountUpdate.children.accountUpdates;
            accountUpdates.push(accountUpdate, ...CallForest.toFlatList(children, depth + 1));
        }
        return accountUpdates;
    },
    // Mina_base.Zkapp_command.Digest.Forest.empty
    emptyHash() {
        return Field(0);
    },
    // similar to Mina_base.Zkapp_command.Call_forest.accumulate_hashes
    // hashes a accountUpdate's children (and their children, and ...) to compute the `calls` field of ZkappPublicInput
    hashChildren(update) {
        let { callsType } = update.children;
        // compute hash outside the circuit if callsType is "Witness"
        // i.e., allowing accountUpdates with arbitrary children
        if (callsType.type === 'Witness') {
            return Circuit.witness(Field, () => CallForest.hashChildrenBase(update));
        }
        let calls = CallForest.hashChildrenBase(update);
        if (callsType.type === 'Equals' && inCheckedComputation()) {
            calls.assertEquals(callsType.value);
        }
        return calls;
    },
    hashChildrenBase({ children }) {
        let stackHash = CallForest.emptyHash();
        for (let accountUpdate of [...children.accountUpdates].reverse()) {
            let calls = CallForest.hashChildren(accountUpdate);
            let nodeHash = hashWithPrefix(prefixes.accountUpdateNode, [
                accountUpdate.hash(),
                calls,
            ]);
            let newHash = hashWithPrefix(prefixes.accountUpdateCons, [
                nodeHash,
                stackHash,
            ]);
            // skip accountUpdate if it's a dummy
            stackHash = Circuit.if(accountUpdate.isDummy(), stackHash, newHash);
        }
        return stackHash;
    },
    // Mina_base.Zkapp_command.Call_forest.add_callers
    addCallers(updates, context = {
        self: TokenId.default,
        caller: TokenId.default,
    }) {
        for (let update of updates) {
            let { isDelegateCall } = update;
            let caller = Circuit.if(isDelegateCall, context.caller, context.self);
            let self = Circuit.if(isDelegateCall, context.self, Token.getId(update.body.publicKey, update.body.tokenId));
            update.body.caller = caller;
            let childContext = { caller, self };
            CallForest.addCallers(update.children.accountUpdates, childContext);
        }
    },
    /**
     * Used in the prover to witness the context from which to compute its caller
     */
    computeCallerContext(update) {
        // compute the line of ancestors
        let current = update;
        let ancestors = [];
        while (true) {
            let parent = current.parent;
            if (parent === undefined)
                break;
            ancestors.unshift(parent);
            current = parent;
        }
        let context = { self: TokenId.default, caller: TokenId.default };
        for (let update of ancestors) {
            if (!update.isDelegateCall.toBoolean()) {
                context.caller = context.self;
                context.self = Token.getId(update.body.publicKey, update.body.tokenId);
            }
        }
        return context;
    },
    callerContextType: provablePure({ self: Field, caller: Field }),
    computeCallDepth(update) {
        for (let callDepth = 0;; callDepth++) {
            if (update.parent === undefined)
                return callDepth;
            update = update.parent;
        }
    },
    forEach(updates, callback) {
        for (let update of updates) {
            callback(update);
            CallForest.forEach(update.children.accountUpdates, callback);
        }
    },
    forEachPredecessor(updates, update, callback) {
        let isPredecessor = true;
        CallForest.forEach(updates, (otherUpdate) => {
            if (otherUpdate.id === update.id)
                isPredecessor = false;
            if (isPredecessor)
                callback(otherUpdate);
        });
    },
};
function createChildAccountUpdate(parent, childAddress, tokenId) {
    let child = AccountUpdate.defaultAccountUpdate(childAddress, tokenId);
    makeChildAccountUpdate(parent, child);
    return child;
}
function makeChildAccountUpdate(parent, child) {
    child.body.callDepth = parent.body.callDepth + 1;
    let wasChildAlready = parent.children.accountUpdates.find((update) => update.id === child.id);
    // add to our children if not already here
    if (!wasChildAlready) {
        parent.children.accountUpdates.push(child);
    }
    // remove the child from the top level list / its current parent
    if (child.parent === undefined) {
        let topLevelUpdates = Mina.currentTransaction()?.accountUpdates;
        let i = topLevelUpdates?.findIndex((update) => update.id === child.id);
        if (i !== undefined && i !== -1) {
            topLevelUpdates.splice(i, 1);
        }
    }
    else if (!wasChildAlready) {
        let siblings = child.parent.children.accountUpdates;
        let i = siblings?.findIndex((update) => update.id === child.id);
        if (i !== undefined && i !== -1) {
            siblings.splice(i, 1);
        }
    }
    child.parent = parent;
}
const ZkappCommand = {
    toPretty(transaction) {
        let feePayer = zkappCommandToJson(transaction).feePayer;
        feePayer.body.publicKey = '..' + feePayer.body.publicKey.slice(-4);
        feePayer.body.authorization = '..' + feePayer.authorization.slice(-4);
        if (feePayer.body.validUntil === null)
            delete feePayer.body.validUntil;
        return [
            feePayer.body,
            ...transaction.accountUpdates.map((a) => a.toPretty()),
        ];
    },
};
function zkappCommandToJson({ feePayer, accountUpdates, memo }) {
    memo = Ledger.memoToBase58(memo);
    return Types.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });
}
const Authorization = {
    hasLazyProof(accountUpdate) {
        return accountUpdate.lazyAuthorization?.kind === 'lazy-proof';
    },
    hasAny(accountUpdate) {
        let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;
        return !!(lazyAuth || 'proof' in auth || 'signature' in auth);
    },
    setSignature(accountUpdate, signature) {
        accountUpdate.authorization = { signature };
        accountUpdate.lazyAuthorization = undefined;
    },
    setProof(accountUpdate, proof) {
        accountUpdate.authorization = { proof };
        accountUpdate.lazyAuthorization = undefined;
    },
    setLazySignature(accountUpdate, signature) {
        signature ?? (signature = {});
        accountUpdate.body.authorizationKind.isSigned = Bool(true);
        accountUpdate.body.authorizationKind.isProved = Bool(false);
        accountUpdate.authorization = {};
        accountUpdate.lazyAuthorization = { ...signature, kind: 'lazy-signature' };
    },
    setLazyProof(accountUpdate, proof) {
        accountUpdate.body.authorizationKind.isSigned = Bool(false);
        accountUpdate.body.authorizationKind.isProved = Bool(true);
        accountUpdate.authorization = {};
        accountUpdate.lazyAuthorization = { ...proof, kind: 'lazy-proof' };
    },
    setLazyNone(accountUpdate) {
        accountUpdate.body.authorizationKind.isSigned = Bool(false);
        accountUpdate.body.authorizationKind.isProved = Bool(false);
        accountUpdate.authorization = {};
        accountUpdate.lazyAuthorization = { kind: 'lazy-none' };
    },
};
function addMissingSignatures(zkappCommand, additionalKeys = []) {
    let additionalPublicKeys = additionalKeys.map((sk) => sk.toPublicKey());
    let { commitment, fullCommitment } = Ledger.transactionCommitments(JSON.stringify(zkappCommandToJson(zkappCommand)));
    function addFeePayerSignature(accountUpdate) {
        let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);
        if (lazyAuthorization === undefined)
            return { body, authorization };
        let { privateKey } = lazyAuthorization;
        if (privateKey === undefined) {
            let i = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
            if (i === -1) {
                let pk = PublicKey.toBase58(accountUpdate.body.publicKey);
                throw Error(`addMissingSignatures: Cannot add signature for fee payer (${pk}), private key is missing.`);
            }
            privateKey = additionalKeys[i];
        }
        let signature = Ledger.signFieldElement(fullCommitment, privateKey);
        return { body, authorization: signature };
    }
    function addSignature(accountUpdate) {
        accountUpdate = AccountUpdate.clone(accountUpdate);
        if (accountUpdate.lazyAuthorization?.kind !== 'lazy-signature') {
            return accountUpdate;
        }
        let { privateKey } = accountUpdate.lazyAuthorization;
        if (privateKey === undefined) {
            let i = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
            if (i === -1)
                throw Error(`addMissingSignatures: Cannot add signature for ${accountUpdate.publicKey.toBase58()}, private key is missing.`);
            privateKey = additionalKeys[i];
        }
        let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean()
            ? fullCommitment
            : commitment;
        let signature = Ledger.signFieldElement(transactionCommitment, privateKey);
        Authorization.setSignature(accountUpdate, signature);
        return accountUpdate;
    }
    let { feePayer, accountUpdates, memo } = zkappCommand;
    return {
        feePayer: addFeePayerSignature(feePayer),
        accountUpdates: accountUpdates.map(addSignature),
        memo,
    };
}
let ZkappPublicInput = provablePure({ accountUpdate: Field, calls: Field }, { customObjectKeys: ['accountUpdate', 'calls'] });
async function addMissingProofs(zkappCommand, { proofsEnabled = true }) {
    async function addProof(index, accountUpdate) {
        accountUpdate = AccountUpdate.clone(accountUpdate);
        if (accountUpdate.lazyAuthorization?.kind !== 'lazy-proof') {
            return {
                accountUpdateProved: accountUpdate,
                proof: undefined,
            };
        }
        if (!proofsEnabled) {
            Authorization.setProof(accountUpdate, Pickles.dummyBase64Proof());
            return {
                accountUpdateProved: accountUpdate,
                proof: undefined,
            };
        }
        let { methodName, args, previousProofs, ZkappClass, memoized, blindingValue, } = accountUpdate.lazyAuthorization;
        let publicInput = accountUpdate.toPublicInput();
        let publicInputFields = ZkappPublicInput.toFields(publicInput);
        if (ZkappClass._provers === undefined)
            throw Error(`Cannot prove execution of ${methodName}(), no prover found. ` +
                `Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
        let provers = ZkappClass._provers;
        let methodError = `Error when computing proofs: Method ${methodName} not found. ` +
            `Make sure your environment supports decorators, and annotate with \`@method ${methodName}\`.`;
        if (ZkappClass._methods === undefined)
            throw Error(methodError);
        let i = ZkappClass._methods.findIndex((m) => m.methodName === methodName);
        if (i === -1)
            throw Error(methodError);
        let [, [, proof]] = await zkAppProver.run([accountUpdate.publicKey, accountUpdate.tokenId, ...args], { transaction: zkappCommand, accountUpdate, index }, () => memoizationContext.runWithAsync({ memoized, currentIndex: 0, blindingValue }, async () => {
            try {
                return await provers[i](publicInputFields, previousProofs);
            }
            catch (err) {
                console.error(`Error when proving ${ZkappClass.name}.${methodName}()`);
                throw err;
            }
        }));
        Authorization.setProof(accountUpdate, Pickles.proofToBase64Transaction(proof));
        let maxProofsVerified = ZkappClass._maxProofsVerified;
        const Proof = ZkappClass.Proof();
        return {
            accountUpdateProved: accountUpdate,
            proof: new Proof({ publicInput, proof, maxProofsVerified }),
        };
    }
    let { feePayer, accountUpdates, memo } = zkappCommand;
    // compute proofs serially. in parallel would clash with our global variable hacks
    let accountUpdatesProved = [];
    let proofs = [];
    for (let i = 0; i < accountUpdates.length; i++) {
        let { accountUpdateProved, proof } = await addProof(i, accountUpdates[i]);
        accountUpdatesProved.push(accountUpdateProved);
        proofs.push(proof);
    }
    return {
        zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },
        proofs,
    };
}
/**
 * Sign all accountUpdates of a transaction which belong to the account determined by [[ `privateKey` ]].
 * @returns the modified transaction JSON
 */
function signJsonTransaction(transactionJson, privateKey) {
    if (typeof privateKey === 'string')
        privateKey = PrivateKey.fromBase58(privateKey);
    let publicKey = privateKey.toPublicKey().toBase58();
    let zkappCommand = JSON.parse(transactionJson);
    let feePayer = zkappCommand.feePayer;
    if (feePayer.body.publicKey === publicKey) {
        zkappCommand = JSON.parse(Ledger.signFeePayer(JSON.stringify(zkappCommand), privateKey));
    }
    for (let i = 0; i < zkappCommand.accountUpdates.length; i++) {
        let accountUpdate = zkappCommand.accountUpdates[i];
        if (accountUpdate.body.publicKey === publicKey &&
            accountUpdate.authorization.proof === null) {
            zkappCommand = JSON.parse(Ledger.signAccountUpdate(JSON.stringify(zkappCommand), privateKey, i));
        }
    }
    return JSON.stringify(zkappCommand);
}
//# sourceMappingURL=account_update.js.map