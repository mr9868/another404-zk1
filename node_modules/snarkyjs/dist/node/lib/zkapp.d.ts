import { Field, Bool, ProvablePure, Pickles, Provable } from '../snarky.js';
import { AccountUpdate, Permissions, SetOrKeep, ZkappPublicInput, AccountUpdatesLayout } from './account_update.js';
import { PrivateKey, PublicKey } from './signature.js';
import * as Mina from './mina.js';
import { UInt32, UInt64 } from './int.js';
import { MethodInterface, Proof, GenericArgument } from './proof_system.js';
export { SmartContract, method, deploy, DeployArgs, signFeePayer, declareMethods, Callback, Account, VerificationKey, Reducer, };
/**
 * A decorator to use in a zkApp to mark a method as callable by anyone.
 * You can use inside your zkApp class as:
 *
 * ```
 * \@method myMethod(someArg: Field) {
 *   // your code here
 * }
 * ```
 */
declare function method<T extends SmartContract>(target: T & {
    constructor: any;
}, methodName: keyof T & string, descriptor: PropertyDescriptor): void;
declare class Callback<Result> extends GenericArgument {
    instance: SmartContract;
    methodIntf: MethodInterface & {
        returnType: Provable<Result>;
    };
    args: any[];
    result?: Result;
    accountUpdate: AccountUpdate;
    static create<T extends SmartContract, K extends keyof T>(instance: T, methodName: K, args: T[K] extends (...args: infer A) => any ? A : never): Callback<any>;
    private constructor();
}
/**
 * The main zkapp class. To write a zkapp, extend this class as such:
 *
 * ```
 * class YourSmartContract extends SmartContract {
 *   // your smart contract code here
 * }
 * ```
 *
 */
declare class SmartContract {
    #private;
    address: PublicKey;
    tokenId: Field;
    static _methods?: MethodInterface[];
    static _methodMetadata: Record<string, {
        sequenceEvents: number;
        rows: number;
        digest: string;
        hasReturn: boolean;
    }>;
    static _provers?: Pickles.Prover[];
    static _maxProofsVerified?: 0 | 1 | 2;
    static _verificationKey?: {
        data: string;
        hash: Field;
    };
    /**
     * Returns a Proof type that belongs to this {@link SmartContract}.
     */
    static Proof(): {
        new ({ proof, publicInput, maxProofsVerified, }: {
            proof: unknown;
            publicInput: ZkappPublicInput;
            maxProofsVerified: 0 | 2 | 1;
        }): {
            publicInput: ZkappPublicInput;
            proof: unknown;
            maxProofsVerified: 0 | 2 | 1;
            shouldVerify: Bool;
            verify(): void;
            verifyIf(condition: Bool): void;
            toJSON(): {
                publicInput: string[];
                maxProofsVerified: 0 | 2 | 1;
                proof: string;
            };
        };
        publicInputType: ProvablePure<{
            accountUpdate: Field;
            calls: Field;
        }> & {
            toInput: (x: {
                accountUpdate: Field;
                calls: Field;
            }) => {
                fields?: Field[] | undefined;
                packed?: [Field, number][] | undefined;
            };
            toJSON: (x: {
                accountUpdate: Field;
                calls: Field;
            }) => {
                accountUpdate: string;
                calls: string;
            };
            fromJSON: (x: {
                accountUpdate: string;
                calls: string;
            }) => {
                accountUpdate: Field;
                calls: Field;
            };
        };
        tag: () => typeof SmartContract;
        fromJSON<S extends (new (...args: any) => Proof<unknown>) & {
            prototype: Proof<any>;
            publicInputType: ProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON: typeof Proof.fromJSON;
        } & {
            prototype: Proof<unknown>;
        }>(this: S, { maxProofsVerified, proof, publicInput, }: {
            publicInput: string[];
            maxProofsVerified: 0 | 2 | 1;
            proof: string;
        }): Proof<S["publicInputType"] extends infer T ? T extends S["publicInputType"] ? T extends new (...args: any) => any ? InstanceType<T> : never : never : never>;
    };
    constructor(address: PublicKey, tokenId?: Field);
    /**
     * Compile your smart contract.
     *
     * This generates both the prover functions, needed to create proofs for running `@method`s,
     * and the verification key, needed to deploy your zkApp.
     *
     * Although provers and verification key are returned by this method, they are also cached internally and used when needed,
     * so you don't actually have to use the return value of this function.
     *
     * Under the hood, "compiling" means calling into the lower-level [Pickles and Kimchi libraries](https://o1-labs.github.io/proof-systems/kimchi/overview.html) to
     * create two prover & verifier indices (one for the "step circuit" which combines all of your smart contract methods into one circuit,
     * and one for the "wrap circuit" which wraps it so that proofs end up in the original finite field). These are fairly expensive
     * operations, so **expect compiling to take at least 20 seconds**, up to several minutes if your circuit is large or your hardware
     * is not optimal for these operations.
     */
    static compile(): Promise<{
        verificationKey: {
            data: string;
            hash: string;
        };
        provers: Pickles.Prover[];
        verify: (publicInput: Pickles.PublicInput, proof: unknown) => Promise<boolean>;
    }>;
    /**
     * Computes a hash of your smart contract, which will reliably change _whenever one of your method circuits changes_.
     * This digest is quick to compute. it is designed to help with deciding whether a contract should be re-compiled or
     * a cached verification key can be used.
     * @returns the digest, as a hex string
     */
    static digest(): string;
    /**
     * Deploys a {@link SmartContract}.
     *
     * ```ts
     * let tx = await Mina.transaction(feePayer, () => {
     *    AccountUpdate.fundNewAccount(feePayer, { initialBalance });
     *    zkapp.deploy({ zkappKey });
     * });
     * ```
     */
    deploy({ verificationKey, zkappKey, }?: {
        verificationKey?: {
            data: string;
            hash: Field | string;
        };
        zkappKey?: PrivateKey;
    }): void;
    /**
     * `SmartContract.init()` will be called only when a {@link SmartContract} will be first deployed, not for redeployment.
     * This method can be overridden as follows
     * ```
     * class MyContract extends SmartContract {
     *  init() {
     *    super.init();
     *    this.setPermissions();
     *    this.x.set(Field(1));
     *  }
     * }
     * ```
     */
    init(zkappKey?: PrivateKey): void;
    /**
     * Use this command if the account update created by this SmartContract should be signed by the account owner,
     * instead of authorized with a proof.
     *
     * Note that the smart contract's {@link Permissions} determine which updates have to be (can be) authorized by a signature.
     *
     * If you only want to avoid creating proofs for quicker testing, we advise you to
     * use `LocalBlockchain({ proofsEnabled: false })` instead of `requireSignature()`. Setting
     * `proofsEnabled` to `false` allows you to test your transactions with the same authorization flow as in production,
     * with the only difference being that quick mock proofs are filled in instead of real proofs.
     */
    requireSignature(): void;
    /**
     * @deprecated `this.sign()` is deprecated in favor of `this.requireSignature()`
     */
    sign(zkappKey?: PrivateKey): void;
    /**
     * Use this command if the account update created by this SmartContract should have no authorization on it,
     * instead of being authorized with a proof.
     *
     * WARNING: This is a method that should rarely be useful. If you want to disable proofs for quicker testing, take a look
     * at `LocalBlockchain({ proofsEnabled: false })`, which causes mock proofs to be created and doesn't require changing the
     * authorization flow.
     */
    skipAuthorization(): void;
    /**
     * Returns the current {@link AccountUpdate} associated to this {@link SmartContract}.
     */
    get self(): AccountUpdate;
    /**
     * Same as `SmartContract.self` but explicitly creates a new {@link AccountUpdate}.
     */
    newSelf(): AccountUpdate;
    /**
     * Current account of the {@link SmartContract}.
     */
    get account(): {
        nonce: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        receiptChainHash: {
            get(): Field;
            assertEquals(value: Field): void;
            assertNothing(): void;
        };
        delegate: {
            get(): PublicKey;
            assertEquals(value: PublicKey): void;
            assertNothing(): void;
        };
        balance: {
            get(): UInt64;
            assertEquals(value: UInt64): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt64, upper: UInt64): void;
        };
        sequenceState: {
            get(): Field;
            assertEquals(value: Field): void;
            assertNothing(): void;
        };
        provedState: {
            get(): Bool;
            assertEquals(value: Bool): void;
            assertNothing(): void;
        };
        isNew: {
            get(): Bool;
            assertEquals(value: Bool): void;
            assertNothing(): void;
        };
    };
    /**
     * Current network state of the {@link SmartContract}.
     */
    get network(): {
        snarkedLedgerHash: {
            get(): Field;
            assertEquals(value: Field): void;
            assertNothing(): void;
        };
        timestamp: {
            get(): UInt64;
            assertEquals(value: UInt64): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt64, upper: UInt64): void;
        };
        blockchainLength: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        minWindowDensity: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        totalCurrency: {
            get(): UInt64;
            assertEquals(value: UInt64): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt64, upper: UInt64): void;
        };
        globalSlotSinceHardFork: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        globalSlotSinceGenesis: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        stakingEpochData: {
            ledger: {
                hash: {
                    get(): Field;
                    assertEquals(value: Field): void;
                    assertNothing(): void;
                };
                totalCurrency: {
                    get(): UInt64;
                    assertEquals(value: UInt64): void;
                    assertNothing(): void;
                } & {
                    assertBetween(lower: UInt64, upper: UInt64): void;
                };
            };
            seed: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            startCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            lockCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            epochLength: {
                get(): UInt32;
                assertEquals(value: UInt32): void;
                assertNothing(): void;
            } & {
                assertBetween(lower: UInt32, upper: UInt32): void;
            };
        };
        nextEpochData: {
            ledger: {
                hash: {
                    get(): Field;
                    assertEquals(value: Field): void;
                    assertNothing(): void;
                };
                totalCurrency: {
                    get(): UInt64;
                    assertEquals(value: UInt64): void;
                    assertNothing(): void;
                } & {
                    assertBetween(lower: UInt64, upper: UInt64): void;
                };
            };
            seed: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            startCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            lockCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            epochLength: {
                get(): UInt32;
                assertEquals(value: UInt32): void;
                assertNothing(): void;
            } & {
                assertBetween(lower: UInt32, upper: UInt32): void;
            };
        };
    };
    /**
     * Token of the {@link SmartContract}.
     */
    get token(): {
        id: Field;
        parentTokenId: Field;
        tokenOwner: PublicKey;
        mint({ address, amount, }: {
            address: PublicKey;
            amount: number | bigint | UInt64;
        }): AccountUpdate;
        burn({ address, amount, }: {
            address: PublicKey;
            amount: number | bigint | UInt64;
        }): void;
        send({ from, to, amount, }: {
            from: PublicKey;
            to: PublicKey;
            amount: number | bigint | UInt64;
        }): AccountUpdate;
    };
    /**
     * Approve an account update or callback. This will include the account update in the zkApp's public input,
     * which means it allows you to read and use its content in a proof, make assertions about it, and modify it.
     *
     * If this is called with a callback as the first parameter, it will first extract the account update produced by that callback.
     * The extracted account update is returned.
     *
     * ```ts
     * \@method myApprovingMethod(callback: Callback) {
     *   let approvedUpdate = this.approve(callback);
     * }
     * ```
     *
     * Under the hood, "approving" just means that the account update is made a child of the zkApp in the
     * tree of account updates that forms the transaction.
     * The second parameter `layout` allows you to also make assertions about the approved update's _own_ children,
     * by specifying a certain expected layout of children. See {@link AccountUpdate.Layout}.
     *
     * @param updateOrCallback
     * @param layout
     * @returns The account update that was approved (needed when passing in a Callback)
     */
    approve(updateOrCallback: AccountUpdate | Callback<any>, layout?: AccountUpdatesLayout): AccountUpdate;
    send(args: {
        to: PublicKey | AccountUpdate;
        amount: number | bigint | UInt64;
    }): void;
    /**
     * Token symbol of this token.
     */
    get tokenSymbol(): {
        set(tokenSymbol: string): void;
    };
    /**
     * Balance of this {@link SmartContract}.
     */
    get balance(): {
        addInPlace(x: string | number | bigint | UInt64 | UInt32 | import("./int.js").Int64): void;
        subInPlace(x: string | number | bigint | UInt64 | UInt32 | import("./int.js").Int64): void;
    };
    /**
     * A list of event types that can be emitted using this.emitEvent()`.
     */
    events: {
        [key: string]: ProvablePure<any>;
    };
    /**
     * Emits an event. Events will be emitted as a part of the transaction and can be collected by archive nodes.
     */
    emitEvent<K extends keyof this['events']>(type: K, event: any): void;
    /**
     * Fetches a list of events that have been emitted by this {@link SmartContract}.
     */
    fetchEvents(start?: UInt32, end?: UInt32): Promise<{
        type: string;
        event: ProvablePure<any>;
    }[]>;
    static runOutsideCircuit(run: () => void): void;
    /**
     * This function is run internally before compiling a smart contract, to collect metadata about what each of your
     * smart contract methods does.
     *
     * For external usage, this function can be handy because calling it involves running all methods in the same "mode" as `compile()` does,
     * so it serves as a quick-to-run check for whether your contract can be compiled without errors, which can greatly speed up iterating.
     *
     * `analyzeMethods()` will also return the number of `rows` of each of your method circuits (i.e., the number of constraints in the underlying proof system),
     * which is a good indicator for circuit size and the time it will take to create proofs.
     *
     * Note: If this function was already called before, it will short-circuit and just return the metadata collected the first time.
     *
     * @returns an object, keyed by method name, each entry containing:
     *  - `rows` the size of the constraint system created by this method
     *  - `digest` a digest of the method circuit
     *  - `hasReturn` a boolean indicating whether the method returns a value
     *  - `sequenceEvents` the number of actions the method dispatches
     */
    static analyzeMethods(): Record<string, {
        sequenceEvents: number;
        rows: number;
        digest: string;
        hasReturn: boolean;
    }>;
    setValue<T>(maybeValue: SetOrKeep<T>, value: T): void;
    /**
     * Changes the {@link Permissions} of this {@link SmartContract}.
     */
    setPermissions(permissions: Permissions): void;
}
declare type Reducer<Action> = {
    actionType: ProvablePure<Action>;
};
declare type ReducerReturn<Action> = {
    /**
     * Dispatches an {@link Action}. Similar to normal {@link Event}s,
     * {@link Action}s can be stored by archive nodes and later reduced within a {@link SmartContract} method
     * to change the state of the contract accordingly
     *
     * ```ts
     * this.reducer.dispatch(Field(1)); // emits one action
     * ```
     *
     * */
    dispatch(action: Action): void;
    /**
     * Reduces a list of {@link Action}s, similar to `Array.reduce()`.
     *
     * ```ts
     *  let pendingActions = this.reducer.getActions({
     *    fromActionHash: actionsHash,
     *  });
     *
     *  let { state: newState, actionsHash: newActionsHash } =
     *  this.reducer.reduce(
     *     pendingActions,
     *     Field,
     *     (state: Field, _action: Field) => {
     *       return state.add(1);
     *     },
     *     { state: initialState, actionsHash: initialActionsHash  }
     *   );
     * ```
     *
     */
    reduce<State>(actions: Action[][], stateType: Provable<State>, reduce: (state: State, action: Action) => State, initial: {
        state: State;
        actionsHash: Field;
    }, options?: {
        maxTransactionsWithActions?: number;
    }): {
        state: State;
        actionsHash: Field;
    };
    /**
     * Fetches the list of previously emitted {@link Action}s by this {@link SmartContract}.
     * ```ts
     * let pendingActions = this.reducer.getActions({
     *    fromActionHash: actionsHash,
     * });
     * ```
     */
    getActions({ fromActionHash, endActionHash, }: {
        fromActionHash?: Field;
        endActionHash?: Field;
    }): Action[][];
};
declare const VerificationKey_base: (new (value: {
    data: string;
    hash: Field;
}) => {
    data: string;
    hash: Field;
}) & Provable<{
    data: string;
    hash: Field;
}> & {
    toInput: (x: {
        data: string;
        hash: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        data: string;
        hash: Field;
    }) => string;
    fromJSON: (x: string) => {
        data: string;
        hash: Field;
    };
};
declare class VerificationKey extends VerificationKey_base {
}
declare type DeployArgs = {
    verificationKey?: {
        data: string;
        hash: string | Field;
    };
    zkappKey?: PrivateKey;
} | undefined;
declare function deploy<S extends typeof SmartContract>(SmartContract: S, { zkappKey, verificationKey, initialBalance, feePayer, tokenId, }: {
    zkappKey: PrivateKey;
    verificationKey: {
        data: string;
        hash: string | Field;
    };
    initialBalance?: number | string;
    feePayer?: Mina.FeePayerSpec;
    tokenId?: Field;
}): Promise<string>;
declare function Account(address: PublicKey, tokenId?: Field): {
    nonce: {
        get(): UInt32;
        assertEquals(value: UInt32): void;
        assertNothing(): void;
    } & {
        assertBetween(lower: UInt32, upper: UInt32): void;
    };
    receiptChainHash: {
        get(): Field;
        assertEquals(value: Field): void;
        assertNothing(): void;
    };
    delegate: {
        get(): PublicKey;
        assertEquals(value: PublicKey): void;
        assertNothing(): void;
    };
    balance: {
        get(): UInt64;
        assertEquals(value: UInt64): void;
        assertNothing(): void;
    } & {
        assertBetween(lower: UInt64, upper: UInt64): void;
    };
    sequenceState: {
        get(): Field;
        assertEquals(value: Field): void;
        assertNothing(): void;
    };
    provedState: {
        get(): Bool;
        assertEquals(value: Bool): void;
        assertNothing(): void;
    };
    isNew: {
        get(): Bool;
        assertEquals(value: Bool): void;
        assertNothing(): void;
    };
};
declare function signFeePayer(transactionJson: string, feePayerKey: PrivateKey | string, { transactionFee, feePayerNonce, memo: feePayerMemo, }: {
    transactionFee?: string | number | undefined;
    feePayerNonce?: string | number | undefined;
    memo?: string | undefined;
}): string;
/**
 * `declareMethods` can be used in place of the `@method` decorator
 * to declare SmartContract methods along with their list of arguments.
 * It should be placed _after_ the class declaration.
 * Here is an example of declaring a method `update`, which takes a single argument of type `Field`:
 * ```ts
 * class MyContract extends SmartContract {
 *   // ...
 *   update(x: Field) {
 *     // ...
 *   }
 * }
 * declareMethods(MyContract, { update: [Field] }); // `[Field]` is the list of arguments!
 * ```
 * Note that a method of the same name must still be defined on the class, just without the decorator.
 */
declare function declareMethods<T extends typeof SmartContract>(SmartContract: T, methodArguments: Record<string, Provable<unknown>[]>): void;
declare type InferProvablePure<T extends ProvablePure<any>> = T extends ProvablePure<infer U> ? U : never;
declare const Reducer: (<T extends ProvablePure<any>, A extends InferProvablePure<T>>(reducer: {
    actionType: T;
}) => ReducerReturn<A>) & {
    initialActionsHash: Field;
};
