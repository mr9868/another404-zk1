import 'reflect-metadata';
import { Circuit } from '../snarky.js';
import { Field, Bool } from './core.js';
import { Context } from './global-context.js';
import { inCheckedComputation, snarkContext } from './proof_system.js';
// external API
export { Circuit, CircuitValue, prop, arrayProp, matrixProp, public_, circuitMain, provable, provablePure, Struct, };
// internal API
export { cloneCircuitValue, circuitValueEquals, circuitArray, memoizationContext, memoizeWitness, getBlindingValue, toConstant, HashInput, };
const HashInput = {
    get empty() {
        return {};
    },
    append(input1, input2) {
        if (input2.fields !== undefined) {
            (input1.fields ?? (input1.fields = [])).push(...input2.fields);
        }
        if (input2.packed !== undefined) {
            (input1.packed ?? (input1.packed = [])).push(...input2.packed);
        }
        return input1;
    },
};
/**
 * @deprecated `CircuitValue` is deprecated in favor of {@link Struct}, which features a simpler API and better typing.
 */
class CircuitValue {
    constructor(...props) {
        // if this is called with no arguments, do nothing, to support simple super() calls
        if (props.length === 0)
            return;
        let fields = this.constructor.prototype._fields;
        if (fields === undefined)
            return;
        if (props.length !== fields.length) {
            throw Error(`${this.constructor.name} constructor called with ${props.length} arguments, but expected ${fields.length}`);
        }
        for (let i = 0; i < fields.length; ++i) {
            let [key] = fields[i];
            this[key] = props[i];
        }
    }
    static fromObject(value) {
        return Object.assign(Object.create(this.prototype), value);
    }
    static sizeInFields() {
        const fields = this.prototype._fields;
        return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
    }
    static toFields(v) {
        const res = [];
        const fields = this.prototype._fields;
        if (fields === undefined || fields === null) {
            return res;
        }
        for (let i = 0, n = fields.length; i < n; ++i) {
            const [key, propType] = fields[i];
            const subElts = propType.toFields(v[key]);
            subElts.forEach((x) => res.push(x));
        }
        return res;
    }
    static toAuxiliary() {
        return [];
    }
    static toInput(v) {
        let input = { fields: [], packed: [] };
        let fields = this.prototype._fields;
        if (fields === undefined)
            return input;
        for (let i = 0, n = fields.length; i < n; ++i) {
            let [key, type] = fields[i];
            if ('toInput' in type) {
                HashInput.append(input, type.toInput(v[key]));
                continue;
            }
            // as a fallback, use toFields on the type
            // TODO: this is problematic -- ignores if there's a toInput on a nested type
            // so, remove this? should every provable define toInput?
            let xs = type.toFields(v[key]);
            input.fields.push(...xs);
        }
        return input;
    }
    toFields() {
        return this.constructor.toFields(this);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
    toConstant() {
        return this.constructor.toConstant(this);
    }
    equals(x) {
        return Circuit.equal(this, x);
    }
    assertEquals(x) {
        Circuit.assertEqual(this, x);
    }
    isConstant() {
        return this.toFields().every((x) => x.isConstant());
    }
    static fromFields(xs) {
        const fields = this.prototype._fields;
        if (xs.length < fields.length) {
            throw Error(`${this.name}.fromFields: Expected ${fields.length} field elements, got ${xs?.length}`);
        }
        let offset = 0;
        const props = {};
        for (let i = 0; i < fields.length; ++i) {
            const [key, propType] = fields[i];
            const propSize = propType.sizeInFields();
            const propVal = propType.fromFields(xs.slice(offset, offset + propSize), []);
            props[key] = propVal;
            offset += propSize;
        }
        return Object.assign(Object.create(this.prototype), props);
    }
    static check(v) {
        const fields = this.prototype._fields;
        if (fields === undefined || fields === null) {
            return;
        }
        for (let i = 0; i < fields.length; ++i) {
            const [key, propType] = fields[i];
            const value = v[key];
            if (propType.check === undefined)
                throw Error('bug: CircuitValue without .check()');
            propType.check(value);
        }
    }
    static toConstant(t) {
        const xs = this.toFields(t);
        return this.fromFields(xs.map((x) => x.toConstant()));
    }
    static toJSON(v) {
        const res = {};
        if (this.prototype._fields !== undefined) {
            const fields = this.prototype._fields;
            fields.forEach(([key, propType]) => {
                res[key] = propType.toJSON(v[key]);
            });
        }
        return res;
    }
    static fromJSON(value) {
        let props = {};
        let fields = this.prototype._fields;
        if (typeof value !== 'object' || value === null || Array.isArray(value)) {
            throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
        }
        if (fields !== undefined) {
            for (let i = 0; i < fields.length; ++i) {
                let [key, propType] = fields[i];
                if (value[key] === undefined) {
                    throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
                }
                else {
                    props[key] = propType.fromJSON(value[key]);
                }
            }
        }
        return Object.assign(Object.create(this.prototype), props);
    }
}
function prop(target, key) {
    const fieldType = Reflect.getMetadata('design:type', target, key);
    if (!target.hasOwnProperty('_fields')) {
        target._fields = [];
    }
    if (fieldType === undefined) {
    }
    else if (fieldType.toFields && fieldType.fromFields) {
        target._fields.push([key, fieldType]);
    }
    else {
        console.log(`warning: property ${key} missing field element conversion methods`);
    }
}
function circuitArray(elementType, length) {
    return {
        /**
         * Returns the size of this structure in {@link Field} elements.
         * @returns size of this structure
         */
        sizeInFields() {
            let elementLength = elementType.sizeInFields();
            return elementLength * length;
        },
        /**
         * Serializes this structure into {@link Field} elements.
         * @returns an array of {@link Field} elements
         */
        toFields(array) {
            return array.map((e) => elementType.toFields(e)).flat();
        },
        /**
         * Serializes this structure's auxiliary data.
         * @returns auxiliary data
         */
        toAuxiliary(array) {
            let array_ = array ?? Array(length).fill(undefined);
            return array_?.map((e) => elementType.toAuxiliary(e));
        },
        /**
         * Deserializes an array of {@link Field} elements into this structure.
         */
        fromFields(fields, aux) {
            let array = [];
            let size = elementType.sizeInFields();
            let n = length;
            for (let i = 0, offset = 0; i < n; i++, offset += size) {
                array[i] = elementType.fromFields(fields.slice(offset, offset + size), aux?.[i]);
            }
            return array;
        },
        check(array) {
            for (let i = 0; i < length; i++) {
                elementType.check(array[i]);
            }
        },
        /**
         * Encodes this structure into a JSON-like object.
         */
        toJSON(array) {
            if (!('toJSON' in elementType)) {
                throw Error('circuitArray.toJSON: element type has no toJSON method');
            }
            return array.map((v) => elementType.toJSON(v));
        },
        /**
         * Decodes a JSON-like object into this structure.
         */
        fromJSON(json) {
            if (!('fromJSON' in elementType)) {
                throw Error('circuitArray.fromJSON: element type has no fromJSON method');
            }
            return json.map((a) => elementType.fromJSON(a));
        },
        toInput(array) {
            if (!('toInput' in elementType)) {
                throw Error('circuitArray.toInput: element type has no toInput method');
            }
            return array.reduce((curr, value) => HashInput.append(curr, elementType.toInput(value)), HashInput.empty);
        },
    };
}
function arrayProp(elementType, length) {
    return function (target, key) {
        if (!target.hasOwnProperty('_fields')) {
            target._fields = [];
        }
        target._fields.push([key, circuitArray(elementType, length)]);
    };
}
function matrixProp(elementType, nRows, nColumns) {
    return function (target, key) {
        if (!target.hasOwnProperty('_fields')) {
            target._fields = [];
        }
        target._fields.push([
            key,
            circuitArray(circuitArray(elementType, nColumns), nRows),
        ]);
    };
}
function public_(target, _key, index) {
    // const fieldType = Reflect.getMetadata('design:paramtypes', target, key);
    if (target._public === undefined) {
        target._public = [];
    }
    target._public.push(index);
}
function typeOfArray(typs) {
    return {
        sizeInFields: () => {
            return typs.reduce((acc, typ) => acc + typ.sizeInFields(), 0);
        },
        toFields: (t) => {
            if (t.length !== typs.length) {
                throw new Error(`typOfArray: Expected ${typs.length}, got ${t.length}`);
            }
            let res = [];
            for (let i = 0; i < t.length; ++i) {
                res.push(...typs[i].toFields(t[i]));
            }
            return res;
        },
        toAuxiliary() {
            return [];
        },
        fromFields: (xs) => {
            let offset = 0;
            let res = [];
            typs.forEach((typ) => {
                const n = typ.sizeInFields();
                res.push(typ.fromFields(xs.slice(offset, offset + n)));
                offset += n;
            });
            return res;
        },
        check(xs) {
            typs.forEach((typ, i) => typ.check(xs[i]));
        },
    };
}
function circuitMain(target, propertyName, _descriptor) {
    const paramTypes = Reflect.getMetadata('design:paramtypes', target, propertyName);
    const numArgs = paramTypes.length;
    const publicIndexSet = new Set(target._public);
    const witnessIndexSet = new Set();
    for (let i = 0; i < numArgs; ++i) {
        if (!publicIndexSet.has(i)) {
            witnessIndexSet.add(i);
        }
    }
    target.snarkyMain = (w, pub) => {
        let [, result] = snarkContext.runWith({ inCheckedComputation: true }, () => {
            let args = [];
            for (let i = 0; i < numArgs; ++i) {
                args.push((publicIndexSet.has(i) ? pub : w).shift());
            }
            return target[propertyName].apply(target, args);
        });
        return result;
    };
    target.snarkyWitnessTyp = typeOfArray(Array.from(witnessIndexSet).map((i) => paramTypes[i]));
    target.snarkyPublicTyp = typeOfArray(Array.from(publicIndexSet).map((i) => paramTypes[i]));
}
let primitives = new Set(['Field', 'Bool', 'Scalar', 'Group']);
let complexTypes = new Set(['object', 'function']);
function provable(typeObj, options) {
    let objectKeys = typeof typeObj === 'object' && typeObj !== null
        ? options?.customObjectKeys ?? Object.keys(typeObj).sort()
        : [];
    let nonCircuitPrimitives = new Set([
        Number,
        String,
        Boolean,
        BigInt,
        null,
        undefined,
    ]);
    if (!nonCircuitPrimitives.has(typeObj) &&
        !complexTypes.has(typeof typeObj)) {
        throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function sizeInFields(typeObj) {
        if (nonCircuitPrimitives.has(typeObj))
            return 0;
        if (Array.isArray(typeObj))
            return typeObj.map(sizeInFields).reduce((a, b) => a + b, 0);
        if ('sizeInFields' in typeObj)
            return typeObj.sizeInFields();
        return Object.values(typeObj)
            .map(sizeInFields)
            .reduce((a, b) => a + b, 0);
    }
    function toFields(typeObj, obj, isToplevel = false) {
        if (nonCircuitPrimitives.has(typeObj))
            return [];
        if (!complexTypes.has(typeof typeObj) || typeObj === null)
            return [];
        if (Array.isArray(typeObj))
            return typeObj.map((t, i) => toFields(t, obj[i])).flat();
        if ('toFields' in typeObj)
            return typeObj.toFields(obj);
        return (isToplevel ? objectKeys : Object.keys(typeObj).sort())
            .map((k) => toFields(typeObj[k], obj[k]))
            .flat();
    }
    function toAuxiliary(typeObj, obj, isToplevel = false) {
        if (typeObj === Number)
            return [obj ?? 0];
        if (typeObj === String)
            return [obj ?? ''];
        if (typeObj === Boolean)
            return [obj ?? false];
        if (typeObj === BigInt)
            return [obj ?? 0n];
        if (typeObj === undefined || typeObj === null)
            return [];
        if (Array.isArray(typeObj))
            return typeObj.map((t, i) => toAuxiliary(t, obj?.[i]));
        if ('toAuxiliary' in typeObj)
            return typeObj.toAuxiliary(obj);
        return (isToplevel ? objectKeys : Object.keys(typeObj).sort()).map((k) => toAuxiliary(typeObj[k], obj?.[k]));
    }
    function toInput(typeObj, obj, isToplevel = false) {
        if (nonCircuitPrimitives.has(typeObj))
            return {};
        if (Array.isArray(typeObj)) {
            return typeObj
                .map((t, i) => toInput(t, obj[i]))
                .reduce(HashInput.append, {});
        }
        if ('toInput' in typeObj)
            return typeObj.toInput(obj);
        if ('toFields' in typeObj) {
            return { fields: typeObj.toFields(obj) };
        }
        return (isToplevel ? objectKeys : Object.keys(typeObj).sort())
            .map((k) => toInput(typeObj[k], obj[k]))
            .reduce(HashInput.append, {});
    }
    function toJSON(typeObj, obj, isToplevel = false) {
        if (typeObj === BigInt)
            return obj.toString();
        if (typeObj === String || typeObj === Number || typeObj === Boolean)
            return obj;
        if (typeObj === undefined || typeObj === null)
            return null;
        if (!complexTypes.has(typeof typeObj) || typeObj === null)
            return obj ?? null;
        if (Array.isArray(typeObj))
            return typeObj.map((t, i) => toJSON(t, obj[i]));
        if ('toJSON' in typeObj)
            return typeObj.toJSON(obj);
        return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj).sort()).map((k) => [
            k,
            toJSON(typeObj[k], obj[k]),
        ]));
    }
    function fromFields(typeObj, fields, aux = [], isToplevel = false) {
        if (typeObj === Number ||
            typeObj === String ||
            typeObj === Boolean ||
            typeObj === BigInt)
            return aux[0];
        if (typeObj === undefined || typeObj === null)
            return typeObj;
        if (!complexTypes.has(typeof typeObj) || typeObj === null)
            return null;
        if (Array.isArray(typeObj)) {
            let array = [];
            let i = 0;
            let offset = 0;
            for (let subObj of typeObj) {
                let size = sizeInFields(subObj);
                array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i]));
                offset += size;
                i++;
            }
            return array;
        }
        if ('fromFields' in typeObj)
            return typeObj.fromFields(fields, aux);
        let keys = isToplevel ? objectKeys : Object.keys(typeObj).sort();
        let values = fromFields(keys.map((k) => typeObj[k]), fields, aux);
        return Object.fromEntries(keys.map((k, i) => [k, values[i]]));
    }
    function fromJSON(typeObj, json, isToplevel = false) {
        if (typeObj === BigInt)
            return BigInt(json);
        if (typeObj === String || typeObj === Number || typeObj === Boolean)
            return json;
        if (typeObj === null)
            return undefined;
        if (!complexTypes.has(typeof typeObj))
            return json ?? undefined;
        if (Array.isArray(typeObj))
            return typeObj.map((t, i) => fromJSON(t, json[i]));
        if ('fromJSON' in typeObj)
            return typeObj.fromJSON(json);
        let keys = isToplevel ? objectKeys : Object.keys(typeObj).sort();
        let values = fromJSON(keys.map((k) => typeObj[k]), json);
        return Object.fromEntries(keys.map((k, i) => [k, values[i]]));
    }
    function check(typeObj, obj, isToplevel = false) {
        if (nonCircuitPrimitives.has(typeObj))
            return;
        if (Array.isArray(typeObj))
            return typeObj.forEach((t, i) => check(t, obj[i]));
        if ('check' in typeObj)
            return typeObj.check(obj);
        return (isToplevel ? objectKeys : Object.keys(typeObj).sort()).forEach((k) => check(typeObj[k], obj[k]));
    }
    if (options?.isPure === true) {
        return {
            sizeInFields: () => sizeInFields(typeObj),
            toFields: (obj) => toFields(typeObj, obj, true),
            toAuxiliary: () => [],
            fromFields: (fields) => fromFields(typeObj, fields, [], true),
            toInput: (obj) => toInput(typeObj, obj, true),
            toJSON: (obj) => toJSON(typeObj, obj, true),
            fromJSON: (json) => fromJSON(typeObj, json, true),
            check: (obj) => check(typeObj, obj, true),
        };
    }
    return {
        sizeInFields: () => sizeInFields(typeObj),
        toFields: (obj) => toFields(typeObj, obj, true),
        toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
        fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
        toInput: (obj) => toInput(typeObj, obj, true),
        toJSON: (obj) => toJSON(typeObj, obj, true),
        fromJSON: (json) => fromJSON(typeObj, json, true),
        check: (obj) => check(typeObj, obj, true),
    };
}
function provablePure(typeObj, options = {}) {
    return provable(typeObj, { ...options, isPure: true });
}
/**
 * `Struct` lets you declare composite types for use in snarkyjs circuits.
 *
 * These composite types can be passed in as arguments to smart contract methods, used for on-chain state variables
 * or as event / action types.
 *
 * Here's an example of creating a "Voter" struct, which holds a public key and a collection of votes on 3 different proposals:
 * ```ts
 * let Vote = { hasVoted: Bool, inFavor: Bool };
 *
 * class Voter extends Struct({
 *   publicKey: PublicKey,
 *   votes: [Vote, Vote, Vote]
 * }) {}
 *
 * // use Voter as SmartContract input:
 * class VoterContract extends SmartContract {
 *   \@method register(voter: Voter) {
 *     // ...
 *   }
 * }
 * ```
 * In this example, there are no instance methods on the class. This makes `Voter` type-compatible with an anonymous object of the form
 * `{ publicKey: PublicKey, votes: Vote[] }`.
 * This mean you don't have to create instances by using `new Voter(...)`, you can operate with plain objects:
 * ```ts
 * voterContract.register({ publicKey, votes });
 * ```
 *
 * On the other hand, you can also add your own methods:
 * ```ts
 * class Voter extends Struct({
 *   publicKey: PublicKey,
 *   votes: [Vote, Vote, Vote]
 * }) {
 *   vote(index: number, inFavor: Bool) {
 *     let vote = this.votes[i];
 *     vote.hasVoted = Bool(true);
 *     vote.inFavor = inFavor;
 *   }
 * }
 * ```
 *
 * In this case, you'll need the constructor to create instances of `Voter`. It always takes as input the plain object:
 * ```ts
 * let emptyVote = { hasVoted: Bool(false), inFavor: Bool(false) };
 * let voter = new Voter({ publicKey, votes: Array(3).fill(emptyVote) });
 * voter.vote(1, Bool(true));
 * ```
 *
 * In addition to creating types composed of Field elements, you can also include auxiliary data which does not become part of the proof.
 * This, for example, allows you to re-use the same type outside snarkyjs methods, where you might want to store additional metadata.
 *
 * To declare non-proof values of type `string`, `number`, etc, you can use the built-in objects `String`, `Number`, etc.
 * Here's how we could add the voter's name (a string) as auxiliary data:
 * ```ts
 * class Voter extends Struct({
 *   publicKey: PublicKey,
 *   votes: [Vote, Vote, Vote],
 *   fullName: String
 * }) {}
 * ```
 *
 * Again, it's important to note that this doesn't enable you to prove anything about the `fullName` string.
 * From the circuit point of view, it simply doesn't exist!
 *
 * @param type Object specifying the layout of the `Struct`
 * @param options Advanced option which allows you to force a certain order of object keys
 * @returns Class which you can extend
 */
function Struct(type, options = {}) {
    class Struct_ {
        constructor(value) {
            Object.assign(this, value);
        }
        /**
         * This method is for internal use, you will probably not need it.
         * @returns the size of this struct in field elements
         */
        static sizeInFields() {
            return this.type.sizeInFields();
        }
        /**
         * This method is for internal use, you will probably not need it.
         * @param value
         * @returns the raw list of field elements that represent this struct inside the proof
         */
        static toFields(value) {
            return this.type.toFields(value);
        }
        /**
         * This method is for internal use, you will probably not need it.
         * @param value
         * @returns the raw non-field element data contained in the struct
         */
        static toAuxiliary(value) {
            return this.type.toAuxiliary(value);
        }
        /**
         * This method is for internal use, you will probably not need it.
         * @param value
         * @returns a representation of this struct as field elements, which can be hashed efficiently
         */
        static toInput(value) {
            return this.type.toInput(value);
        }
        /**
         * Convert this struct to a JSON object, consisting only of numbers, strings, booleans, arrays and plain objects.
         * @param value
         * @returns a JSON representation of this struct
         */
        static toJSON(value) {
            return this.type.toJSON(value);
        }
        /**
         * Convert from a JSON object to an instance of this struct.
         * @param json
         * @returns a JSON representation of this struct
         */
        static fromJSON(json) {
            let value = this.type.fromJSON(json);
            let struct = Object.create(this.prototype);
            return Object.assign(struct, value);
        }
        /**
         * This method is for internal use, you will probably not need it.
         * Method to make assertions which should be always made whenever a struct of this type is created in a proof.
         * @param value
         */
        static check(value) {
            return this.type.check(value);
        }
        /**
         * This method is for internal use, you will probably not need it.
         * Recover a struct from its raw field elements and auxiliary data.
         * @param fields the raw fields elements
         * @param aux the raw non-field element data
         */
        static fromFields(fields, aux) {
            let value = this.type.fromFields(fields, aux);
            let struct = Object.create(this.prototype);
            return Object.assign(struct, value);
        }
    }
    Struct_.type = provable(type, options);
    return Struct_;
}
// FIXME: the logic in here to check for obj.constructor.name actually doesn't work
// something that works is Field(1).constructor === obj.constructor etc
function cloneCircuitValue(obj) {
    // primitive JS types and functions aren't cloned
    if (typeof obj !== 'object' || obj === null)
        return obj;
    // HACK: callbacks
    if (['GenericArgument', 'Callback'].includes(obj.constructor?.name)) {
        return obj;
    }
    // built-in JS datatypes with custom cloning strategies
    if (Array.isArray(obj))
        return obj.map(cloneCircuitValue);
    if (obj instanceof Set)
        return new Set([...obj].map(cloneCircuitValue));
    if (obj instanceof Map)
        return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)]));
    if (ArrayBuffer.isView(obj))
        return new obj.constructor(obj);
    // snarkyjs primitives aren't cloned
    if (primitives.has(obj.constructor.name))
        return obj;
    // cloning strategy that works for plain objects AND classes whose constructor only assigns properties
    let propertyDescriptors = {};
    for (let [key, value] of Object.entries(obj)) {
        propertyDescriptors[key] = {
            value: cloneCircuitValue(value),
            writable: true,
            enumerable: true,
            configurable: true,
        };
    }
    return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);
}
function circuitValueEquals(a, b) {
    // primitive JS types and functions are checked for exact equality
    if (typeof a !== 'object' || a === null)
        return a === b;
    // built-in JS datatypes with custom equality checks
    if (Array.isArray(a)) {
        return (Array.isArray(b) &&
            a.length === b.length &&
            a.every((a_, i) => circuitValueEquals(a_, b[i])));
    }
    if (a instanceof Set) {
        return (b instanceof Set && a.size === b.size && [...a].every((a_) => b.has(a_)));
    }
    if (a instanceof Map) {
        return (b instanceof Map &&
            a.size === b.size &&
            [...a].every(([k, v]) => circuitValueEquals(v, b.get(k))));
    }
    if (ArrayBuffer.isView(a) && !(a instanceof DataView)) {
        // typed array
        return (ArrayBuffer.isView(b) &&
            !(b instanceof DataView) &&
            circuitValueEquals([...a], [...b]));
    }
    // the two checks below cover snarkyjs primitives and CircuitValues
    // if we have an .equals method, try to use it
    if ('equals' in a && typeof a.equals === 'function') {
        let isEqual = a.equals(b).toBoolean();
        if (typeof isEqual === 'boolean')
            return isEqual;
        if (isEqual instanceof Bool)
            return isEqual.toBoolean();
    }
    // if we have a .toFields method, try to use it
    if ('toFields' in a &&
        typeof a.toFields === 'function' &&
        'toFields' in b &&
        typeof b.toFields === 'function') {
        let aFields = a.toFields();
        let bFields = b.toFields();
        return aFields.every((a, i) => a.equals(bFields[i]).toBoolean());
    }
    // equality test that works for plain objects AND classes whose constructor only assigns properties
    let aEntries = Object.entries(a).filter(([, v]) => v !== undefined);
    let bEntries = Object.entries(b).filter(([, v]) => v !== undefined);
    if (aEntries.length !== bEntries.length)
        return false;
    return aEntries.every(([key, value]) => key in b && circuitValueEquals(b[key], value));
}
function toConstant(type, value) {
    return type.fromFields(type.toFields(value).map((x) => x.toConstant()), type.toAuxiliary(value));
}
// TODO: move `Circuit` to JS entirely, this patching harms code discoverability
Circuit.witness = function (type, compute) {
    let proverValue;
    let createFields = () => {
        proverValue = compute();
        let fields = type.toFields(proverValue);
        // TODO: enable this check
        // currently it throws for Scalar.. which seems to be flexible about what length is returned by toFields
        // if (fields.length !== type.sizeInFields()) {
        //   throw Error(
        //     `Invalid witness. Expected ${type.sizeInFields()} field elements, got ${
        //       fields.length
        //     }.`
        //   );
        // }
        return fields;
    };
    let ctx = snarkContext.get();
    let fields = inCheckedComputation() && !ctx.inWitnessBlock
        ? snarkContext.runWith({ ...ctx, inWitnessBlock: true }, () => Circuit._witness(type, createFields))[1]
        : createFields();
    let aux = type.toAuxiliary(proverValue);
    let value = type.fromFields(fields, aux);
    type.check(value);
    return value;
};
Circuit.array = circuitArray;
Circuit.switch = function (mask, type, values) {
    // picks the value at the index where mask is true
    let nValues = values.length;
    if (mask.length !== nValues)
        throw Error(`Circuit.switch: \`values\` and \`mask\` have different lengths (${values.length} vs. ${mask.length}), which is not allowed.`);
    let checkMask = () => {
        let nTrue = mask.filter((b) => b.toBoolean()).length;
        if (nTrue > 1) {
            throw Error(`Circuit.switch: \`mask\` must have 0 or 1 true element, found ${nTrue}.`);
        }
    };
    if (mask.every((b) => b.toField().isConstant()))
        checkMask();
    else
        Circuit.asProver(checkMask);
    let size = type.sizeInFields();
    let fields = Array(size).fill(Field(0));
    for (let i = 0; i < nValues; i++) {
        let valueFields = type.toFields(values[i]);
        let maskField = mask[i].toField();
        for (let j = 0; j < size; j++) {
            let maybeField = valueFields[j].mul(maskField);
            fields[j] = fields[j].add(maybeField);
        }
    }
    let aux = auxiliary(type, () => {
        let i = mask.findIndex((b) => b.toBoolean());
        if (i === -1)
            return type.toAuxiliary();
        return type.toAuxiliary(values[i]);
    });
    return type.fromFields(fields, aux);
};
Circuit.constraintSystem = function (f) {
    let [, result] = snarkContext.runWith({ inAnalyze: true, inCheckedComputation: true }, () => {
        let result;
        let { rows, digest, json } = Circuit._constraintSystem(() => {
            result = f();
        });
        return { rows, digest, result: result };
    });
    return result;
};
Circuit.log = function (...args) {
    Circuit.asProver(() => {
        let prettyArgs = [];
        for (let arg of args) {
            if (arg?.toPretty !== undefined)
                prettyArgs.push(arg.toPretty());
            else {
                try {
                    prettyArgs.push(JSON.parse(JSON.stringify(arg)));
                }
                catch {
                    prettyArgs.push(arg);
                }
            }
        }
        console.log(...prettyArgs);
    });
};
function auxiliary(type, compute) {
    let aux;
    if (inCheckedComputation())
        Circuit.asProver(() => (aux = compute()));
    else
        aux = compute();
    return aux ?? type.toAuxiliary();
}
let memoizationContext = Context.create();
/**
 * Like Circuit.witness, but memoizes the witness during transaction construction
 * for reuse by the prover. This is needed to witness non-deterministic values.
 */
function memoizeWitness(type, compute) {
    return Circuit.witness(type, () => {
        if (!memoizationContext.has())
            return compute();
        let context = memoizationContext.get();
        let { memoized, currentIndex } = context;
        let currentValue = memoized[currentIndex];
        if (currentValue === undefined) {
            let value = compute();
            let fields = type.toFields(value).map((x) => x.toConstant());
            let aux = type.toAuxiliary(value);
            currentValue = { fields, aux };
            memoized[currentIndex] = currentValue;
        }
        context.currentIndex += 1;
        return type.fromFields(currentValue.fields, currentValue.aux);
    });
}
function getBlindingValue() {
    if (!memoizationContext.has())
        return Field.random();
    let context = memoizationContext.get();
    if (context.blindingValue === undefined) {
        context.blindingValue = Field.random();
    }
    return context.blindingValue;
}
//# sourceMappingURL=circuit_value.js.map