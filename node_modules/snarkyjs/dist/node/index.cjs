var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// dist/node/index.js
__export(exports, {
  Account: () => Account2,
  AccountUpdate: () => AccountUpdate2,
  Bool: () => Bool,
  Character: () => Character,
  Circuit: () => Circuit,
  CircuitString: () => CircuitString,
  CircuitValue: () => CircuitValue,
  Encoding: () => encoding_exports,
  Encryption: () => encryption_exports,
  Experimental: () => Experimental,
  Field: () => Field,
  Group: () => Group,
  Int64: () => Int64,
  Ledger: () => Ledger,
  MerkleMap: () => MerkleMap,
  MerkleMapWitness: () => MerkleMapWitness,
  MerkleTree: () => MerkleTree,
  MerkleWitness: () => MerkleWitness,
  Mina: () => mina_exports,
  Permissions: () => Permissions,
  Poseidon: () => Poseidon2,
  PrivateKey: () => PrivateKey,
  Proof: () => Proof,
  PublicKey: () => PublicKey,
  Reducer: () => Reducer,
  Scalar: () => Scalar,
  SelfProof: () => SelfProof,
  Sign: () => Sign,
  Signature: () => Signature,
  SmartContract: () => SmartContract,
  State: () => State,
  Struct: () => Struct,
  Token: () => Token,
  TokenSymbol: () => TokenSymbol,
  Types: () => transaction_exports,
  UInt32: () => UInt32,
  UInt64: () => UInt64,
  VerificationKey: () => VerificationKey,
  ZkappPublicInput: () => ZkappPublicInput,
  addCachedAccount: () => addCachedAccount,
  arrayProp: () => arrayProp,
  circuitMain: () => circuitMain,
  declareMethods: () => declareMethods,
  declareState: () => declareState,
  deploy: () => deploy,
  fetchAccount: () => fetchAccount,
  fetchLastBlock: () => fetchLastBlock,
  getSrs: () => getSrs,
  isReady: () => isReady,
  matrixProp: () => matrixProp,
  method: () => method,
  prop: () => prop,
  provable: () => provable,
  provablePure: () => provablePure,
  public_: () => public_,
  recoverVerificationKey: () => recoverVerificationKey,
  sendZkapp: () => sendZkapp,
  serializeVerificationKey: () => serializeVerificationKey,
  setGraphqlEndpoint: () => setGraphqlEndpoint,
  shutdown: () => shutdown,
  signFeePayer: () => signFeePayer,
  state: () => state,
  verify: () => verify,
  zkappCommandToJson: () => zkappCommandToJson
});

// dist/node/snarky/wrapper.js
var import_snarky_js_node_bc = __toModule(require("./_node_bindings/snarky_js_node.bc.cjs"));
var getSnarky = () => import_snarky_js_node_bc.default;
var snarky_ready = import_snarky_js_node_bc.default.snarky_ready;
function getWasm() {
  return globalThis.jsoo_runtime.plonk_wasm;
}
async function shutdown() {
  process.exit(0);
}

// dist/node/snarky/snarky-class-spec.js
var snarky_class_spec_default = [
  {
    name: "Field",
    props: [
      {
        name: "one",
        type: "object"
      },
      {
        name: "zero",
        type: "object"
      },
      {
        name: "minusOne",
        type: "object"
      },
      {
        name: "ORDER",
        type: "bigint"
      },
      {
        name: "random",
        type: "function"
      },
      {
        name: "add",
        type: "function"
      },
      {
        name: "sub",
        type: "function"
      },
      {
        name: "mul",
        type: "function"
      },
      {
        name: "div",
        type: "function"
      },
      {
        name: "neg",
        type: "function"
      },
      {
        name: "inv",
        type: "function"
      },
      {
        name: "square",
        type: "function"
      },
      {
        name: "sqrt",
        type: "function"
      },
      {
        name: "toString",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "assertBoolean",
        type: "function"
      },
      {
        name: "isZero",
        type: "function"
      },
      {
        name: "fromBits",
        type: "function"
      },
      {
        name: "toBits",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      },
      {
        name: "fromNumber",
        type: "function"
      },
      {
        name: "fromString",
        type: "function"
      },
      {
        name: "fromBigInt",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      }
    ]
  },
  {
    name: "Bool",
    props: [
      {
        name: "true",
        type: "object"
      },
      {
        name: "false",
        type: "object"
      },
      {
        name: "toField",
        type: "function"
      },
      {
        name: "Unsafe",
        type: "object"
      },
      {
        name: "not",
        type: "function"
      },
      {
        name: "and",
        type: "function"
      },
      {
        name: "or",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "count",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      }
    ]
  },
  {
    name: "Circuit",
    props: [
      {
        name: "runAndCheck",
        type: "function"
      },
      {
        name: "_constraintSystem",
        type: "function"
      },
      {
        name: "asProver",
        type: "function"
      },
      {
        name: "_witness",
        type: "function"
      },
      {
        name: "array",
        type: "function"
      },
      {
        name: "generateKeypair",
        type: "function"
      },
      {
        name: "prove",
        type: "function"
      },
      {
        name: "verify",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "inProver",
        type: "function"
      },
      {
        name: "inCheckedComputation",
        type: "function"
      },
      {
        name: "if",
        type: "function"
      },
      {
        name: "getVerificationKey",
        type: "function"
      }
    ]
  },
  {
    name: "Poseidon",
    props: [
      {
        name: "hash",
        type: "function"
      },
      {
        name: "update",
        type: "function"
      },
      {
        name: "prefixes",
        type: "object"
      },
      {
        name: "spongeCreate",
        type: "function"
      },
      {
        name: "spongeAbsorb",
        type: "function"
      },
      {
        name: "spongeSqueeze",
        type: "function"
      }
    ]
  },
  {
    name: "Group",
    props: [
      {
        name: "generator",
        type: "object"
      },
      {
        name: "add",
        type: "function"
      },
      {
        name: "sub",
        type: "function"
      },
      {
        name: "neg",
        type: "function"
      },
      {
        name: "scale",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      }
    ]
  },
  {
    name: "Scalar",
    props: [
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "random",
        type: "function"
      },
      {
        name: "fromBits",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      }
    ]
  },
  {
    name: "Ledger",
    props: [
      {
        name: "create",
        type: "function"
      },
      {
        name: "customTokenId",
        type: "function"
      },
      {
        name: "customTokenIdChecked",
        type: "function"
      },
      {
        name: "createTokenAccount",
        type: "function"
      },
      {
        name: "hashTransaction",
        type: "function"
      },
      {
        name: "hashTransactionChecked",
        type: "function"
      },
      {
        name: "transactionCommitments",
        type: "function"
      },
      {
        name: "zkappPublicInput",
        type: "function"
      },
      {
        name: "signFieldElement",
        type: "function"
      },
      {
        name: "dummySignature",
        type: "function"
      },
      {
        name: "signFeePayer",
        type: "function"
      },
      {
        name: "signOtherAccountUpdate",
        type: "function"
      },
      {
        name: "publicKeyToString",
        type: "function"
      },
      {
        name: "publicKeyOfString",
        type: "function"
      },
      {
        name: "privateKeyToString",
        type: "function"
      },
      {
        name: "privateKeyOfString",
        type: "function"
      },
      {
        name: "fieldToBase58",
        type: "function"
      },
      {
        name: "fieldOfBase58",
        type: "function"
      },
      {
        name: "memoToBase58",
        type: "function"
      },
      { name: "memoHashBase58", type: "function" },
      {
        name: "checkAccountUpdateSignature",
        type: "function"
      },
      {
        name: "fieldsOfJson",
        type: "function"
      },
      {
        name: "hashAccountUpdateFromFields",
        type: "function"
      },
      {
        name: "hashAccountUpdateFromJson",
        type: "function"
      },
      {
        name: "hashInputFromJson",
        type: "object"
      },
      { name: "encoding", type: "object" }
    ]
  },
  {
    name: "Pickles",
    props: [
      {
        name: "compile",
        type: "function"
      },
      {
        name: "circuitDigest",
        type: "function"
      },
      {
        name: "verify",
        type: "function"
      },
      {
        name: "dummyBase64Proof",
        type: "function"
      },
      {
        name: "proofToBase64",
        type: "function"
      },
      {
        name: "proofOfBase64",
        type: "function"
      },
      {
        name: "proofToBase64Transaction",
        type: "function"
      }
    ]
  }
];

// dist/node/snarky/proxy.js
function proxyClasses(getModuleObject, isItReady2, moduleSpec) {
  let moduleProxy = {};
  for (let classSpec of moduleSpec) {
    let className = classSpec.name;
    let Class = function(...args) {
      if (!isItReady2())
        throw Error(constructError(className));
      let moduleObject = getModuleObject();
      return new moduleObject[className](...args);
    };
    for (let prop2 of classSpec.props) {
      let propName = prop2.name;
      if (prop2.type === "function") {
        Class[propName] = function(...args) {
          if (!isItReady2())
            throw Error(methodError(className, propName));
          let moduleObject = getModuleObject();
          return moduleObject[className][propName].apply(this, args);
        };
      } else {
        Object.defineProperty(Class, propName, {
          get: function() {
            let moduleObject = getModuleObject();
            return moduleObject[className][propName];
          }
        });
      }
    }
    moduleProxy[className] = Class;
  }
  return moduleProxy;
}
var constructError = (className) => `Cannot call class constructor because snarkyjs has not finished loading.
Try calling \`await isReady\` before \`new ${className}()\``;
var methodError = (className, methodName) => `Cannot call static method because snarkyjs has not finished loading.
Try calling \`await isReady\` before \`${className}.${methodName}()\``;

// dist/node/snarky.js
var isReadyBoolean = false;
var isReady = snarky_ready.then(() => isReadyBoolean = true);
var isItReady = () => isReadyBoolean;
var { Field, Bool, Circuit, Poseidon, Group, Scalar, Ledger, Pickles } = proxyClasses(getSnarky, isItReady, snarky_class_spec_default);

// dist/node/lib/core.js
Field.toAuxiliary = () => [];
Bool.toAuxiliary = () => [];
Scalar.toAuxiliary = () => [];
Group.toAuxiliary = () => [];
Field.toInput = function(x) {
  return { fields: [x] };
};
Field.toBytes = function(x) {
  return [...x.toConstant().value[1]];
};
Field.fromBytes = function(bytes) {
  let uint8array = new Uint8Array(32);
  uint8array.set(bytes);
  return Object.assign(Object.create(Field(1).constructor.prototype), {
    value: [0, uint8array]
  });
};
Field.sizeInBytes = () => 32;
Bool.toInput = function(x) {
  return { packed: [[x.toField(), 1]] };
};
Bool.toBytes = function(b) {
  return [Number(b.toBoolean())];
};
Bool.fromBytes = function([b]) {
  return Bool(!!b);
};
Bool.sizeInBytes = () => 1;

// dist/node/snarky/addons.js
function getJsooRuntime() {
  return globalThis.jsoo_runtime;
}
function getSrs(keypair) {
  return keypair.value[2][4];
}
function serializeVerificationKey(verificationKey) {
  let wasm = getWasm();
  let runtime = getJsooRuntime();
  let isFp = verificationKey.value[4].constructor.name === "WasmFpSrs";
  return isFp ? wasm.caml_pasta_fp_plonk_verifier_index_serialize(runtime.caml_pasta_fp_plonk_verifier_index_to_rust(verificationKey.value)) : wasm.caml_pasta_fq_plonk_verifier_index_serialize(runtime.caml_pasta_fq_plonk_verifier_index_to_rust(verificationKey.value));
}
function recoverVerificationKey(srs, serializedVk) {
  let vkRust = getWasm().caml_pasta_fp_plonk_verifier_index_deserialize(srs, serializedVk);
  let vk = getJsooRuntime().caml_pasta_fp_plonk_verifier_index_of_rust(vkRust);
  return Circuit.getVerificationKey(vk);
}

// dist/node/lib/circuit_value.js
var import_reflect_metadata = __toModule(require("reflect-metadata"));

// dist/node/lib/global-context.js
var Context = { create };
function create(options = {
  allowsNesting: true,
  default: void 0
}) {
  let t = Object.assign(function() {
    return t.data[t.data.length - 1]?.context;
  }, {
    data: [],
    allowsNesting: options.allowsNesting ?? true,
    get: () => get(t),
    has: () => t.data.length !== 0,
    runWith: (context, func) => runWith(t, context, func),
    runWithAsync: (context, func) => runWithAsync(t, context, func),
    enter: (context) => enter(t, context),
    leave: (id) => leave(t, id),
    id: () => {
      if (t.data.length === 0)
        throw Error(contextConflictMessage);
      return t.data[t.data.length - 1].id;
    }
  });
  if (options.default !== void 0)
    enter(t, options.default);
  return t;
}
function enter(t, context) {
  if (t.data.length > 0 && !t.allowsNesting) {
    throw Error(contextConflictMessage);
  }
  let id = Math.random();
  t.data.push({ context, id });
  return id;
}
function leave(t, id) {
  let current = t.data.pop();
  if (current === void 0)
    throw Error(contextConflictMessage);
  if (current.id !== id)
    throw Error(contextConflictMessage);
  return current.context;
}
function get(t) {
  if (t.data.length === 0)
    throw Error(contextConflictMessage);
  let current = t.data[t.data.length - 1];
  return current.context;
}
function runWith(t, context, func) {
  let id = enter(t, context);
  let result;
  let resultContext;
  try {
    result = func(context);
  } finally {
    resultContext = leave(t, id);
  }
  return [resultContext, result];
}
async function runWithAsync(t, context, func) {
  let id = enter(t, context);
  let result;
  let resultContext;
  try {
    result = await func(context);
  } finally {
    resultContext = leave(t, id);
  }
  return [resultContext, result];
}
var contextConflictMessage = "It seems you're running multiple provers concurrently within the same JavaScript thread, which, at the moment, is not supported and would lead to bugs.";

// dist/node/lib/proof_system.js
var snarkContext = Context.create({ default: {} });
var Proof = class {
  constructor({ proof, publicInput, maxProofsVerified }) {
    this.shouldVerify = Bool(false);
    this.publicInput = publicInput;
    this.proof = proof;
    this.maxProofsVerified = maxProofsVerified;
  }
  verify() {
    this.shouldVerify = Bool(true);
  }
  verifyIf(condition) {
    this.shouldVerify = condition;
  }
  toJSON() {
    return {
      publicInput: getPublicInputType(this.constructor).toFields(this.publicInput).map(String),
      maxProofsVerified: this.maxProofsVerified,
      proof: Pickles.proofToBase64([this.maxProofsVerified, this.proof])
    };
  }
  static fromJSON({ maxProofsVerified, proof: proofString, publicInput: publicInputJson }) {
    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);
    let publicInput = getPublicInputType(this).fromFields(publicInputJson.map(Field));
    return new this({ publicInput, proof, maxProofsVerified });
  }
};
Proof.publicInputType = void 0;
Proof.tag = () => {
  throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput> { ... }`);
};
function verify(proof, verificationKey) {
  if (typeof proof.proof === "string") {
    let [, picklesProof] = Pickles.proofOfBase64(proof.proof, proof.maxProofsVerified);
    let publicInputFields = proof.publicInput.map(Field);
    return Pickles.verify(publicInputFields, picklesProof, verificationKey);
  } else {
    let publicInputFields = getPublicInputType(proof.constructor).toFields(proof.publicInput);
    return Pickles.verify(publicInputFields, proof.proof, verificationKey);
  }
}
var compiledTags = new WeakMap();
var CompiledTag = {
  get(tag) {
    return compiledTags.get(tag);
  },
  store(tag, compiledTag) {
    compiledTags.set(tag, compiledTag);
  }
};
function ZkProgram({ publicInput: publicInputType, methods }) {
  let selfTag = { name: `Program${i++}` };
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = publicInputType;
  SelfProof2.tag = () => selfTag;
  let keys = Object.keys(methods).sort();
  let methodIntfs = keys.map((key) => sortMethodArguments("program", key, methods[key].privateInputs, SelfProof2));
  let methodFunctions = keys.map((key) => methods[key].method);
  let maxProofsVerified = methodIntfs.reduce((acc, { proofArgs }) => Math.max(acc, proofArgs.length), 0);
  let compileOutput;
  async function compile() {
    let { provers: provers2, verify: verify3, getVerificationKeyArtifact } = compileProgram(publicInputType, methodIntfs, methodFunctions, selfTag);
    compileOutput = { provers: provers2, verify: verify3 };
    return { verificationKey: getVerificationKeyArtifact().data };
  }
  function toProver(key, i2) {
    async function prove(publicInput, ...args) {
      let picklesProver = compileOutput?.provers?.[i2];
      if (picklesProver === void 0) {
        throw Error(`Cannot prove execution of program.${key}(), no prover found. Try calling \`await program.compile()\` first, this will cache provers in the background.`);
      }
      let publicInputFields = publicInputType.toFields(publicInput);
      let previousProofs = getPreviousProofsForProver(args, methodIntfs[i2]);
      let [, proof] = await snarkContext.runWithAsync({ witnesses: args, inProver: true }, () => picklesProver(publicInputFields, previousProofs));
      class ProgramProof extends Proof {
      }
      ProgramProof.publicInputType = publicInputType;
      ProgramProof.tag = () => selfTag;
      return new ProgramProof({ publicInput, proof, maxProofsVerified });
    }
    return [key, prove];
  }
  let provers = Object.fromEntries(keys.map(toProver));
  function verify2(proof) {
    if (compileOutput?.verify === void 0) {
      throw Error(`Cannot verify proof, verification key not found. Try calling \`await program.compile()\` first.`);
    }
    return compileOutput.verify(publicInputType.toFields(proof.publicInput), proof.proof);
  }
  function digest() {
    let methodData = methodIntfs.map((methodEntry, i2) => analyzeMethod(publicInputType, methodEntry, methodFunctions[i2]));
    let hash = Poseidon.hash(Object.values(methodData).map((d) => Field(BigInt("0x" + d.digest))), false);
    return hash.toBigInt().toString(16);
  }
  return Object.assign(selfTag, { compile, verify: verify2, digest, publicInputType }, provers);
}
var i = 0;
var SelfProof = class extends Proof {
};
function sortMethodArguments(programName, methodName, privateInputs, selfProof) {
  let witnessArgs = [];
  let proofArgs = [];
  let allArgs = [];
  let genericArgs = [];
  for (let i2 = 0; i2 < privateInputs.length; i2++) {
    let privateInput = privateInputs[i2];
    if (isProof(privateInput)) {
      if (privateInput === Proof) {
        throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput> { ... }`);
      }
      allArgs.push({ type: "proof", index: proofArgs.length });
      if (privateInput === SelfProof) {
        proofArgs.push(selfProof);
      } else {
        proofArgs.push(privateInput);
      }
    } else if (isAsFields(privateInput)) {
      allArgs.push({ type: "witness", index: witnessArgs.length });
      witnessArgs.push(privateInput);
    } else if (isGeneric(privateInput)) {
      allArgs.push({ type: "generic", index: genericArgs.length });
      genericArgs.push(privateInput);
    } else {
      throw Error(`Argument ${i2 + 1} of method ${methodName} is not a provable type: ${privateInput}`);
    }
  }
  if (proofArgs.length > 2) {
    throw Error(`${programName}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  return {
    methodName,
    witnessArgs,
    proofArgs,
    allArgs,
    genericArgs
  };
}
function isAsFields(type) {
  return (typeof type === "function" || typeof type === "object") && type !== null && ["toFields", "fromFields", "sizeInFields", "toAuxiliary"].every((s) => s in type);
}
function isProof(type) {
  return type === Proof || typeof type === "function" && type.prototype instanceof Proof;
}
var GenericArgument = class {
  constructor(isEmpty = false) {
    this.isEmpty = isEmpty;
  }
};
var emptyGeneric = () => new GenericArgument(true);
function isGeneric(type) {
  return type === GenericArgument || typeof type === "function" && type.prototype instanceof GenericArgument;
}
function getPreviousProofsForProver(methodArgs, { allArgs, proofArgs }) {
  let previousProofs = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = allArgs[i2];
    if (arg.type === "proof") {
      let { proof, publicInput } = methodArgs[i2];
      let publicInputType = getPublicInputType(proofArgs[arg.index]);
      previousProofs[arg.index] = {
        publicInput: publicInputType.toFields(publicInput),
        proof
      };
    }
  }
  return previousProofs;
}
function compileProgram(publicInputType, methodIntfs, methods, proofSystemTag) {
  let rules = methodIntfs.map((methodEntry, i2) => picklesRuleFromFunction(publicInputType, methods[i2], proofSystemTag, methodEntry));
  let [, { getVerificationKeyArtifact, provers, verify: verify2, tag }] = snarkContext.runWith({ inCompile: true }, () => Pickles.compile(rules, publicInputType.sizeInFields()));
  CompiledTag.store(proofSystemTag, tag);
  return { getVerificationKeyArtifact, provers, verify: verify2, tag };
}
function analyzeMethod(publicInputType, methodIntf, method2) {
  return Circuit.constraintSystem(() => {
    let args = synthesizeMethodArguments(methodIntf, true);
    let publicInput = emptyWitness(publicInputType);
    return method2(publicInput, ...args);
  });
}
function picklesRuleFromFunction(publicInputType, func, proofSystemTag, { methodName, witnessArgs, proofArgs, allArgs }) {
  function main(publicInput, previousInputs) {
    let { witnesses: argsWithoutPublicInput } = snarkContext.get();
    let finalArgs = [];
    let proofs = [];
    for (let i2 = 0; i2 < allArgs.length; i2++) {
      let arg = allArgs[i2];
      if (arg.type === "witness") {
        let type = witnessArgs[arg.index];
        finalArgs[i2] = argsWithoutPublicInput ? Circuit.witness(type, () => argsWithoutPublicInput[i2]) : emptyWitness(type);
      } else if (arg.type === "proof") {
        let Proof2 = proofArgs[arg.index];
        let publicInput2 = getPublicInputType(Proof2).fromFields(previousInputs[arg.index]);
        let proofInstance;
        if (argsWithoutPublicInput) {
          let { proof } = argsWithoutPublicInput[i2];
          proofInstance = new Proof2({ publicInput: publicInput2, proof });
        } else {
          proofInstance = new Proof2({ publicInput: publicInput2, proof: void 0 });
        }
        finalArgs[i2] = proofInstance;
        proofs.push(proofInstance);
      } else if (arg.type === "generic") {
        finalArgs[i2] = argsWithoutPublicInput?.[i2] ?? emptyGeneric();
      }
    }
    func(publicInputType.fromFields(publicInput), ...finalArgs);
    return proofs.map((proof) => proof.shouldVerify);
  }
  if (proofArgs.length > 2) {
    throw Error(`${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  let proofsToVerify = proofArgs.map((Proof2) => {
    let tag = Proof2.tag();
    if (tag === proofSystemTag)
      return { isSelf: true };
    else {
      let compiledTag = CompiledTag.get(tag);
      if (compiledTag === void 0) {
        throw Error(`${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.
Try to run ${tag.name}.compile() first.`);
      }
      return { isSelf: false, tag: compiledTag };
    }
  });
  return { identifier: methodName, main, proofsToVerify };
}
function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }, asVariables = false) {
  let args = [];
  let empty = asVariables ? emptyWitness : emptyValue;
  for (let arg of allArgs) {
    if (arg.type === "witness") {
      args.push(empty(witnessArgs[arg.index]));
    } else if (arg.type === "proof") {
      let Proof2 = proofArgs[arg.index];
      let publicInput = empty(getPublicInputType(Proof2));
      args.push(new Proof2({ publicInput, proof: void 0 }));
    } else if (arg.type === "generic") {
      args.push(emptyGeneric());
    }
  }
  return args;
}
function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }, args) {
  let constArgs = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = args[i2];
    let { type, index } = allArgs[i2];
    if (type === "witness") {
      constArgs.push(toConstant(witnessArgs[index], arg));
    } else if (type === "proof") {
      let Proof2 = proofArgs[index];
      let publicInput = toConstant(getPublicInputType(Proof2), arg.publicInput);
      constArgs.push(new Proof2({ publicInput, proof: arg.proof }));
    } else if (type === "generic") {
      constArgs.push(arg);
    }
  }
  return constArgs;
}
var Generic = provable(null);
function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }, args) {
  let typesAndValues = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = args[i2];
    let { type, index } = allArgs[i2];
    if (type === "witness") {
      typesAndValues.push({ type: witnessArgs[index], value: arg });
    } else if (type === "proof") {
      let Proof2 = proofArgs[index];
      typesAndValues.push({
        type: getPublicInputType(Proof2),
        value: arg.publicInput
      });
    } else if (type === "generic") {
      typesAndValues.push({ type: Generic, value: arg });
    }
  }
  return typesAndValues;
}
function emptyValue(type) {
  return type.fromFields(Array(type.sizeInFields()).fill(Field(0)), type.toAuxiliary());
}
function emptyWitness(type) {
  return Circuit.witness(type, () => emptyValue(type));
}
function getPublicInputType(Proof2) {
  if (Proof2.publicInputType === void 0) {
    throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput> { ... }`);
  }
  return Proof2.publicInputType;
}
ZkProgram.Proof = function(program) {
  var _a;
  return _a = class ZkProgramProof extends Proof {
  }, _a.publicInputType = program.publicInputType, _a.tag = () => program, _a;
};
function Prover() {
  return {
    async run(witnesses, proverData, callback) {
      return snarkContext.runWithAsync({ witnesses, proverData, inProver: true }, callback);
    },
    getData() {
      return snarkContext.get().proverData;
    }
  };
}
function inProver() {
  return !!snarkContext.get().inProver;
}
function inAnalyze() {
  return !!snarkContext.get().inAnalyze;
}
function inCheckedComputation() {
  let ctx = snarkContext.get();
  return !!ctx.inCompile || !!ctx.inProver || !!ctx.inCheckedComputation;
}

// dist/node/lib/circuit_value.js
var HashInput = {
  get empty() {
    return {};
  },
  append(input1, input2) {
    if (input2.fields !== void 0) {
      (input1.fields ?? (input1.fields = [])).push(...input2.fields);
    }
    if (input2.packed !== void 0) {
      (input1.packed ?? (input1.packed = [])).push(...input2.packed);
    }
    return input1;
  }
};
var CircuitValue = class {
  constructor(...props) {
    if (props.length === 0)
      return;
    let fields = this.constructor.prototype._fields;
    if (fields === void 0)
      return;
    if (props.length !== fields.length) {
      throw Error(`${this.constructor.name} constructor called with ${props.length} arguments, but expected ${fields.length}`);
    }
    for (let i2 = 0; i2 < fields.length; ++i2) {
      let [key] = fields[i2];
      this[key] = props[i2];
    }
  }
  static fromObject(value) {
    return Object.assign(Object.create(this.prototype), value);
  }
  static sizeInFields() {
    const fields = this.prototype._fields;
    return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
  }
  static toFields(v) {
    const res = [];
    const fields = this.prototype._fields;
    if (fields === void 0 || fields === null) {
      return res;
    }
    for (let i2 = 0, n = fields.length; i2 < n; ++i2) {
      const [key, propType] = fields[i2];
      const subElts = propType.toFields(v[key]);
      subElts.forEach((x) => res.push(x));
    }
    return res;
  }
  static toAuxiliary() {
    return [];
  }
  static toInput(v) {
    let input = { fields: [], packed: [] };
    let fields = this.prototype._fields;
    if (fields === void 0)
      return input;
    for (let i2 = 0, n = fields.length; i2 < n; ++i2) {
      let [key, type] = fields[i2];
      if ("toInput" in type) {
        HashInput.append(input, type.toInput(v[key]));
        continue;
      }
      let xs = type.toFields(v[key]);
      input.fields.push(...xs);
    }
    return input;
  }
  toFields() {
    return this.constructor.toFields(this);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
  toConstant() {
    return this.constructor.toConstant(this);
  }
  equals(x) {
    return Circuit.equal(this, x);
  }
  assertEquals(x) {
    Circuit.assertEqual(this, x);
  }
  isConstant() {
    return this.toFields().every((x) => x.isConstant());
  }
  static fromFields(xs) {
    const fields = this.prototype._fields;
    if (xs.length < fields.length) {
      throw Error(`${this.name}.fromFields: Expected ${fields.length} field elements, got ${xs?.length}`);
    }
    let offset = 0;
    const props = {};
    for (let i2 = 0; i2 < fields.length; ++i2) {
      const [key, propType] = fields[i2];
      const propSize = propType.sizeInFields();
      const propVal = propType.fromFields(xs.slice(offset, offset + propSize), []);
      props[key] = propVal;
      offset += propSize;
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  static check(v) {
    const fields = this.prototype._fields;
    if (fields === void 0 || fields === null) {
      return;
    }
    for (let i2 = 0; i2 < fields.length; ++i2) {
      const [key, propType] = fields[i2];
      const value = v[key];
      if (propType.check === void 0)
        throw Error("bug: CircuitValue without .check()");
      propType.check(value);
    }
  }
  static toConstant(t) {
    const xs = this.toFields(t);
    return this.fromFields(xs.map((x) => x.toConstant()));
  }
  static toJSON(v) {
    const res = {};
    if (this.prototype._fields !== void 0) {
      const fields = this.prototype._fields;
      fields.forEach(([key, propType]) => {
        res[key] = propType.toJSON(v[key]);
      });
    }
    return res;
  }
  static fromJSON(value) {
    let props = {};
    let fields = this.prototype._fields;
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
    }
    if (fields !== void 0) {
      for (let i2 = 0; i2 < fields.length; ++i2) {
        let [key, propType] = fields[i2];
        if (value[key] === void 0) {
          throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
        } else {
          props[key] = propType.fromJSON(value[key]);
        }
      }
    }
    return Object.assign(Object.create(this.prototype), props);
  }
};
function prop(target, key) {
  const fieldType = Reflect.getMetadata("design:type", target, key);
  if (!target.hasOwnProperty("_fields")) {
    target._fields = [];
  }
  if (fieldType === void 0) {
  } else if (fieldType.toFields && fieldType.fromFields) {
    target._fields.push([key, fieldType]);
  } else {
    console.log(`warning: property ${key} missing field element conversion methods`);
  }
}
function circuitArray(elementType, length) {
  return {
    sizeInFields() {
      let elementLength = elementType.sizeInFields();
      return elementLength * length;
    },
    toFields(array) {
      return array.map((e) => elementType.toFields(e)).flat();
    },
    toAuxiliary(array) {
      let array_ = array ?? Array(length).fill(void 0);
      return array_?.map((e) => elementType.toAuxiliary(e));
    },
    fromFields(fields, aux) {
      let array = [];
      let size = elementType.sizeInFields();
      let n = length;
      for (let i2 = 0, offset = 0; i2 < n; i2++, offset += size) {
        array[i2] = elementType.fromFields(fields.slice(offset, offset + size), aux?.[i2]);
      }
      return array;
    },
    check(array) {
      for (let i2 = 0; i2 < length; i2++) {
        elementType.check(array[i2]);
      }
    },
    toJSON(array) {
      if (!("toJSON" in elementType)) {
        throw Error("circuitArray.toJSON: element type has no toJSON method");
      }
      return array.map((v) => elementType.toJSON(v));
    },
    fromJSON(json) {
      if (!("fromJSON" in elementType)) {
        throw Error("circuitArray.fromJSON: element type has no fromJSON method");
      }
      return json.map((a) => elementType.fromJSON(a));
    },
    toInput(array) {
      if (!("toInput" in elementType)) {
        throw Error("circuitArray.toInput: element type has no toInput method");
      }
      return array.reduce((curr, value) => HashInput.append(curr, elementType.toInput(value)), HashInput.empty);
    }
  };
}
function arrayProp(elementType, length) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([key, circuitArray(elementType, length)]);
  };
}
function matrixProp(elementType, nRows, nColumns) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([
      key,
      circuitArray(circuitArray(elementType, nColumns), nRows)
    ]);
  };
}
function public_(target, _key, index) {
  if (target._public === void 0) {
    target._public = [];
  }
  target._public.push(index);
}
function typeOfArray(typs) {
  return {
    sizeInFields: () => {
      return typs.reduce((acc, typ) => acc + typ.sizeInFields(), 0);
    },
    toFields: (t) => {
      if (t.length !== typs.length) {
        throw new Error(`typOfArray: Expected ${typs.length}, got ${t.length}`);
      }
      let res = [];
      for (let i2 = 0; i2 < t.length; ++i2) {
        res.push(...typs[i2].toFields(t[i2]));
      }
      return res;
    },
    toAuxiliary() {
      return [];
    },
    fromFields: (xs) => {
      let offset = 0;
      let res = [];
      typs.forEach((typ) => {
        const n = typ.sizeInFields();
        res.push(typ.fromFields(xs.slice(offset, offset + n)));
        offset += n;
      });
      return res;
    },
    check(xs) {
      typs.forEach((typ, i2) => typ.check(xs[i2]));
    }
  };
}
function circuitMain(target, propertyName, _descriptor) {
  const paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyName);
  const numArgs = paramTypes.length;
  const publicIndexSet = new Set(target._public);
  const witnessIndexSet = new Set();
  for (let i2 = 0; i2 < numArgs; ++i2) {
    if (!publicIndexSet.has(i2)) {
      witnessIndexSet.add(i2);
    }
  }
  target.snarkyMain = (w, pub) => {
    let [, result] = snarkContext.runWith({ inCheckedComputation: true }, () => {
      let args = [];
      for (let i2 = 0; i2 < numArgs; ++i2) {
        args.push((publicIndexSet.has(i2) ? pub : w).shift());
      }
      return target[propertyName].apply(target, args);
    });
    return result;
  };
  target.snarkyWitnessTyp = typeOfArray(Array.from(witnessIndexSet).map((i2) => paramTypes[i2]));
  target.snarkyPublicTyp = typeOfArray(Array.from(publicIndexSet).map((i2) => paramTypes[i2]));
}
var primitives = new Set(["Field", "Bool", "Scalar", "Group"]);
var complexTypes = new Set(["object", "function"]);
function provable(typeObj, options) {
  let objectKeys = typeof typeObj === "object" && typeObj !== null ? options?.customObjectKeys ?? Object.keys(typeObj).sort() : [];
  let nonCircuitPrimitives = new Set([
    Number,
    String,
    Boolean,
    BigInt,
    null,
    void 0
  ]);
  if (!nonCircuitPrimitives.has(typeObj) && !complexTypes.has(typeof typeObj)) {
    throw Error(`provable: unsupported type "${typeObj}"`);
  }
  function sizeInFields(typeObj2) {
    if (nonCircuitPrimitives.has(typeObj2))
      return 0;
    if (Array.isArray(typeObj2))
      return typeObj2.map(sizeInFields).reduce((a, b) => a + b, 0);
    if ("sizeInFields" in typeObj2)
      return typeObj2.sizeInFields();
    return Object.values(typeObj2).map(sizeInFields).reduce((a, b) => a + b, 0);
  }
  function toFields(typeObj2, obj, isToplevel = false) {
    if (nonCircuitPrimitives.has(typeObj2))
      return [];
    if (!complexTypes.has(typeof typeObj2) || typeObj2 === null)
      return [];
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => toFields(t, obj[i2])).flat();
    if ("toFields" in typeObj2)
      return typeObj2.toFields(obj);
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toFields(typeObj2[k], obj[k])).flat();
  }
  function toAuxiliary(typeObj2, obj, isToplevel = false) {
    if (typeObj2 === Number)
      return [obj ?? 0];
    if (typeObj2 === String)
      return [obj ?? ""];
    if (typeObj2 === Boolean)
      return [obj ?? false];
    if (typeObj2 === BigInt)
      return [obj ?? 0n];
    if (typeObj2 === void 0 || typeObj2 === null)
      return [];
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => toAuxiliary(t, obj?.[i2]));
    if ("toAuxiliary" in typeObj2)
      return typeObj2.toAuxiliary(obj);
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toAuxiliary(typeObj2[k], obj?.[k]));
  }
  function toInput(typeObj2, obj, isToplevel = false) {
    if (nonCircuitPrimitives.has(typeObj2))
      return {};
    if (Array.isArray(typeObj2)) {
      return typeObj2.map((t, i2) => toInput(t, obj[i2])).reduce(HashInput.append, {});
    }
    if ("toInput" in typeObj2)
      return typeObj2.toInput(obj);
    if ("toFields" in typeObj2) {
      return { fields: typeObj2.toFields(obj) };
    }
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toInput(typeObj2[k], obj[k])).reduce(HashInput.append, {});
  }
  function toJSON(typeObj2, obj, isToplevel = false) {
    if (typeObj2 === BigInt)
      return obj.toString();
    if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
      return obj;
    if (typeObj2 === void 0 || typeObj2 === null)
      return null;
    if (!complexTypes.has(typeof typeObj2) || typeObj2 === null)
      return obj ?? null;
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => toJSON(t, obj[i2]));
    if ("toJSON" in typeObj2)
      return typeObj2.toJSON(obj);
    return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => [
      k,
      toJSON(typeObj2[k], obj[k])
    ]));
  }
  function fromFields(typeObj2, fields, aux = [], isToplevel = false) {
    if (typeObj2 === Number || typeObj2 === String || typeObj2 === Boolean || typeObj2 === BigInt)
      return aux[0];
    if (typeObj2 === void 0 || typeObj2 === null)
      return typeObj2;
    if (!complexTypes.has(typeof typeObj2) || typeObj2 === null)
      return null;
    if (Array.isArray(typeObj2)) {
      let array = [];
      let i2 = 0;
      let offset = 0;
      for (let subObj of typeObj2) {
        let size = sizeInFields(subObj);
        array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i2]));
        offset += size;
        i2++;
      }
      return array;
    }
    if ("fromFields" in typeObj2)
      return typeObj2.fromFields(fields, aux);
    let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
    let values = fromFields(keys.map((k) => typeObj2[k]), fields, aux);
    return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
  }
  function fromJSON(typeObj2, json, isToplevel = false) {
    if (typeObj2 === BigInt)
      return BigInt(json);
    if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
      return json;
    if (typeObj2 === null)
      return void 0;
    if (!complexTypes.has(typeof typeObj2))
      return json ?? void 0;
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => fromJSON(t, json[i2]));
    if ("fromJSON" in typeObj2)
      return typeObj2.fromJSON(json);
    let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
    let values = fromJSON(keys.map((k) => typeObj2[k]), json);
    return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
  }
  function check(typeObj2, obj, isToplevel = false) {
    if (nonCircuitPrimitives.has(typeObj2))
      return;
    if (Array.isArray(typeObj2))
      return typeObj2.forEach((t, i2) => check(t, obj[i2]));
    if ("check" in typeObj2)
      return typeObj2.check(obj);
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).forEach((k) => check(typeObj2[k], obj[k]));
  }
  if (options?.isPure === true) {
    return {
      sizeInFields: () => sizeInFields(typeObj),
      toFields: (obj) => toFields(typeObj, obj, true),
      toAuxiliary: () => [],
      fromFields: (fields) => fromFields(typeObj, fields, [], true),
      toInput: (obj) => toInput(typeObj, obj, true),
      toJSON: (obj) => toJSON(typeObj, obj, true),
      fromJSON: (json) => fromJSON(typeObj, json, true),
      check: (obj) => check(typeObj, obj, true)
    };
  }
  return {
    sizeInFields: () => sizeInFields(typeObj),
    toFields: (obj) => toFields(typeObj, obj, true),
    toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
    fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
    toInput: (obj) => toInput(typeObj, obj, true),
    toJSON: (obj) => toJSON(typeObj, obj, true),
    fromJSON: (json) => fromJSON(typeObj, json, true),
    check: (obj) => check(typeObj, obj, true)
  };
}
function provablePure(typeObj, options = {}) {
  return provable(typeObj, { ...options, isPure: true });
}
function Struct(type, options = {}) {
  class Struct_ {
    constructor(value) {
      Object.assign(this, value);
    }
    static sizeInFields() {
      return this.type.sizeInFields();
    }
    static toFields(value) {
      return this.type.toFields(value);
    }
    static toAuxiliary(value) {
      return this.type.toAuxiliary(value);
    }
    static toInput(value) {
      return this.type.toInput(value);
    }
    static toJSON(value) {
      return this.type.toJSON(value);
    }
    static fromJSON(json) {
      let value = this.type.fromJSON(json);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    static check(value) {
      return this.type.check(value);
    }
    static fromFields(fields, aux) {
      let value = this.type.fromFields(fields, aux);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
  }
  Struct_.type = provable(type, options);
  return Struct_;
}
function cloneCircuitValue(obj) {
  if (typeof obj !== "object" || obj === null)
    return obj;
  if (["GenericArgument", "Callback"].includes(obj.constructor?.name)) {
    return obj;
  }
  if (Array.isArray(obj))
    return obj.map(cloneCircuitValue);
  if (obj instanceof Set)
    return new Set([...obj].map(cloneCircuitValue));
  if (obj instanceof Map)
    return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)]));
  if (ArrayBuffer.isView(obj))
    return new obj.constructor(obj);
  if (primitives.has(obj.constructor.name))
    return obj;
  let propertyDescriptors = {};
  for (let [key, value] of Object.entries(obj)) {
    propertyDescriptors[key] = {
      value: cloneCircuitValue(value),
      writable: true,
      enumerable: true,
      configurable: true
    };
  }
  return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);
}
function circuitValueEquals(a, b) {
  if (typeof a !== "object" || a === null)
    return a === b;
  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every((a_, i2) => circuitValueEquals(a_, b[i2]));
  }
  if (a instanceof Set) {
    return b instanceof Set && a.size === b.size && [...a].every((a_) => b.has(a_));
  }
  if (a instanceof Map) {
    return b instanceof Map && a.size === b.size && [...a].every(([k, v]) => circuitValueEquals(v, b.get(k)));
  }
  if (ArrayBuffer.isView(a) && !(a instanceof DataView)) {
    return ArrayBuffer.isView(b) && !(b instanceof DataView) && circuitValueEquals([...a], [...b]);
  }
  if ("equals" in a && typeof a.equals === "function") {
    let isEqual = a.equals(b).toBoolean();
    if (typeof isEqual === "boolean")
      return isEqual;
    if (isEqual instanceof Bool)
      return isEqual.toBoolean();
  }
  if ("toFields" in a && typeof a.toFields === "function" && "toFields" in b && typeof b.toFields === "function") {
    let aFields = a.toFields();
    let bFields = b.toFields();
    return aFields.every((a2, i2) => a2.equals(bFields[i2]).toBoolean());
  }
  let aEntries = Object.entries(a).filter(([, v]) => v !== void 0);
  let bEntries = Object.entries(b).filter(([, v]) => v !== void 0);
  if (aEntries.length !== bEntries.length)
    return false;
  return aEntries.every(([key, value]) => key in b && circuitValueEquals(b[key], value));
}
function toConstant(type, value) {
  return type.fromFields(type.toFields(value).map((x) => x.toConstant()), type.toAuxiliary(value));
}
Circuit.witness = function(type, compute) {
  let proverValue;
  let createFields = () => {
    proverValue = compute();
    let fields2 = type.toFields(proverValue);
    return fields2;
  };
  let ctx = snarkContext.get();
  let fields = inCheckedComputation() && !ctx.inWitnessBlock ? snarkContext.runWith({ ...ctx, inWitnessBlock: true }, () => Circuit._witness(type, createFields))[1] : createFields();
  let aux = type.toAuxiliary(proverValue);
  let value = type.fromFields(fields, aux);
  type.check(value);
  return value;
};
Circuit.array = circuitArray;
Circuit.switch = function(mask, type, values) {
  let nValues = values.length;
  if (mask.length !== nValues)
    throw Error(`Circuit.switch: \`values\` and \`mask\` have different lengths (${values.length} vs. ${mask.length}), which is not allowed.`);
  let checkMask = () => {
    let nTrue = mask.filter((b) => b.toBoolean()).length;
    if (nTrue > 1) {
      throw Error(`Circuit.switch: \`mask\` must have 0 or 1 true element, found ${nTrue}.`);
    }
  };
  if (mask.every((b) => b.toField().isConstant()))
    checkMask();
  else
    Circuit.asProver(checkMask);
  let size = type.sizeInFields();
  let fields = Array(size).fill(Field(0));
  for (let i2 = 0; i2 < nValues; i2++) {
    let valueFields = type.toFields(values[i2]);
    let maskField = mask[i2].toField();
    for (let j = 0; j < size; j++) {
      let maybeField = valueFields[j].mul(maskField);
      fields[j] = fields[j].add(maybeField);
    }
  }
  let aux = auxiliary(type, () => {
    let i2 = mask.findIndex((b) => b.toBoolean());
    if (i2 === -1)
      return type.toAuxiliary();
    return type.toAuxiliary(values[i2]);
  });
  return type.fromFields(fields, aux);
};
Circuit.constraintSystem = function(f) {
  let [, result] = snarkContext.runWith({ inAnalyze: true, inCheckedComputation: true }, () => {
    let result2;
    let { rows, digest, json } = Circuit._constraintSystem(() => {
      result2 = f();
    });
    return { rows, digest, result: result2 };
  });
  return result;
};
Circuit.log = function(...args) {
  Circuit.asProver(() => {
    let prettyArgs = [];
    for (let arg of args) {
      if (arg?.toPretty !== void 0)
        prettyArgs.push(arg.toPretty());
      else {
        try {
          prettyArgs.push(JSON.parse(JSON.stringify(arg)));
        } catch {
          prettyArgs.push(arg);
        }
      }
    }
    console.log(...prettyArgs);
  });
};
function auxiliary(type, compute) {
  let aux;
  if (inCheckedComputation())
    Circuit.asProver(() => aux = compute());
  else
    aux = compute();
  return aux ?? type.toAuxiliary();
}
var memoizationContext = Context.create();
function memoizeWitness(type, compute) {
  return Circuit.witness(type, () => {
    if (!memoizationContext.has())
      return compute();
    let context = memoizationContext.get();
    let { memoized, currentIndex } = context;
    let currentValue = memoized[currentIndex];
    if (currentValue === void 0) {
      let value = compute();
      let fields = type.toFields(value).map((x) => x.toConstant());
      let aux = type.toAuxiliary(value);
      currentValue = { fields, aux };
      memoized[currentIndex] = currentValue;
    }
    context.currentIndex += 1;
    return type.fromFields(currentValue.fields, currentValue.aux);
  });
}
function getBlindingValue() {
  if (!memoizationContext.has())
    return Field.random();
  let context = memoizationContext.get();
  if (context.blindingValue === void 0) {
    context.blindingValue = Field.random();
  }
  return context.blindingValue;
}

// dist/node/lib/hash.js
var Sponge = class {
  constructor() {
    let isChecked = inCheckedComputation();
    this.sponge = Poseidon.spongeCreate(isChecked);
  }
  absorb(x) {
    Poseidon.spongeAbsorb(this.sponge, x);
  }
  squeeze() {
    return Poseidon.spongeSqueeze(this.sponge);
  }
};
var Poseidon2 = {
  hash(input) {
    let isChecked = !input.every((x) => x.isConstant());
    return Poseidon.hash(input, isChecked);
  },
  update(state2, input) {
    let isChecked = !(state2.every((x) => x.isConstant()) && input.every((x) => x.isConstant()));
    return Poseidon.update(state2, input, isChecked);
  },
  get initialState() {
    return [Field(0), Field(0), Field(0)];
  },
  Sponge
};
function emptyHashWithPrefix(prefix) {
  return salt(prefix)[0];
}
function hashWithPrefix(prefix, input) {
  let init = salt(prefix);
  return Poseidon2.update(init, input)[0];
}
var prefixes = new Proxy({}, {
  get(_target, prop2) {
    return Poseidon.prefixes[prop2];
  }
});
function salt(prefix) {
  return Poseidon2.update(Poseidon2.initialState, [prefixToField(prefix)]);
}
function prefixToField(prefix) {
  if (prefix.length * 8 >= 255)
    throw Error("prefix too long");
  let bits2 = [...prefix].map((char) => {
    let bits3 = [];
    for (let j = 0, c = char.charCodeAt(0); j < 8; j++, c >>= 1) {
      bits3.push(!!(c & 1));
    }
    return bits3;
  }).flat();
  return Field.fromBits(bits2);
}
function packToFields({ fields = [], packed = [] }) {
  if (packed.length === 0)
    return fields;
  let packedBits = [];
  let currentPackedField = Field(0);
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField.mul(Field(1n << BigInt(size))).add(field);
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields.concat(packedBits);
}
var TokenSymbolPure = {
  toFields({ field }) {
    return [field];
  },
  toAuxiliary(value) {
    return [value?.symbol ?? ""];
  },
  fromFields([field], [symbol]) {
    return { symbol, field };
  },
  sizeInFields() {
    return 1;
  },
  check({ field }) {
    let actual = field.rangeCheckHelper(48);
    actual.assertEquals(field);
  },
  toJSON({ symbol }) {
    return symbol;
  },
  fromJSON(symbol) {
    let field = prefixToField(symbol);
    return { symbol, field };
  },
  toInput({ field }) {
    return { packed: [[field, 48]] };
  }
};
var TokenSymbol = class extends Struct(TokenSymbolPure) {
  static get empty() {
    return { symbol: "", field: Field(0) };
  }
  static from(symbol) {
    if (symbol.length > 6)
      throw Error("Token symbol length should be a maximum of 6");
    let field = prefixToField(symbol);
    return { symbol, field };
  }
};
function emptyReceiptChainHash() {
  return emptyHashWithPrefix("CodaReceiptEmpty");
}

// dist/node/lib/signature.js
var import_tslib = __toModule(require("tslib"));
var PrivateKey = class extends CircuitValue {
  static random() {
    return new PrivateKey(Scalar.random());
  }
  static fromBits(bs) {
    return new PrivateKey(Scalar.fromBits(bs));
  }
  toPublicKey() {
    return PublicKey.fromPrivateKey(this);
  }
  static fromBase58(privateKeyBase58) {
    let scalar = Ledger.privateKeyOfString(privateKeyBase58);
    return new PrivateKey(scalar);
  }
  toBase58() {
    return PrivateKey.toBase58(this);
  }
  static toBase58(privateKey) {
    return Ledger.privateKeyToString(privateKey);
  }
};
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Scalar)
], PrivateKey.prototype, "s", void 0);
var PublicKey = class extends CircuitValue {
  toGroup() {
    let { x, isOdd } = this;
    let ySquared = x.mul(x).mul(x).add(5);
    let someY = ySquared.sqrt();
    let isTheRightY = isOdd.equals(someY.toBits()[0]);
    let y = isTheRightY.toField().mul(someY).add(isTheRightY.not().toField().mul(someY.neg()));
    return new Group(x, y);
  }
  static fromGroup({ x, y }) {
    let isOdd = y.toBits()[0];
    return PublicKey.fromObject({ x, isOdd });
  }
  static fromPrivateKey({ s }) {
    return PublicKey.fromGroup(Group.generator.scale(s));
  }
  static from(g) {
    return PublicKey.fromObject(g);
  }
  static empty() {
    return PublicKey.from({ x: Field(0), isOdd: Bool(false) });
  }
  isEmpty() {
    return this.x.isZero();
  }
  static fromBase58(publicKeyBase58) {
    let pk = Ledger.publicKeyOfString(publicKeyBase58);
    return PublicKey.from(pk);
  }
  toBase58() {
    return PublicKey.toBase58(this);
  }
  static toBase58(publicKey) {
    return Ledger.publicKeyToString(publicKey);
  }
  static toJSON(publicKey) {
    return publicKey.toBase58();
  }
  static fromJSON(publicKey) {
    return PublicKey.fromBase58(publicKey);
  }
};
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Field)
], PublicKey.prototype, "x", void 0);
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Bool)
], PublicKey.prototype, "isOdd", void 0);
var Signature = class extends CircuitValue {
  static create(privKey, msg) {
    const publicKey = PublicKey.fromPrivateKey(privKey).toGroup();
    const d = privKey.s;
    const kPrime = Scalar.random();
    let { x: r, y: ry } = Group.generator.scale(kPrime);
    const k = ry.toBits()[0].toBoolean() ? kPrime.neg() : kPrime;
    const e = Scalar.fromBits(Poseidon2.hash(msg.concat([publicKey.x, publicKey.y, r])).toBits());
    const s = e.mul(d).add(k);
    return new Signature(r, s);
  }
  verify(publicKey, msg) {
    const point = publicKey.toGroup();
    let e = Scalar.fromBits(Poseidon2.hash(msg.concat([point.x, point.y, this.r])).toBits());
    let r = point.scale(e).neg().add(Group.generator.scale(this.s));
    return Bool.and(r.x.equals(this.r), r.y.toBits()[0].equals(false));
  }
};
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Field)
], Signature.prototype, "r", void 0);
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Scalar)
], Signature.prototype, "s", void 0);

// dist/node/lib/int.js
var import_tslib2 = __toModule(require("tslib"));
var UInt64 = class extends CircuitValue {
  static get zero() {
    return new UInt64(Field(0));
  }
  static get one() {
    return new UInt64(Field(1));
  }
  toString() {
    return this.value.toString();
  }
  toBigInt() {
    return this.value.toBigInt();
  }
  static check(x) {
    let actual = x.value.rangeCheckHelper(64);
    actual.assertEquals(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 64]] };
  }
  static toJSON(x) {
    return x.value.toString();
  }
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt64: Expected number between 0 and 2^64 - 1, got ${xBig}`);
    }
    return x;
  }
  static from(x) {
    if (x instanceof UInt64 || x instanceof UInt32)
      x = x.value;
    return new this(this.checkConstant(Field(x)));
  }
  static MAXINT() {
    return new UInt64(Field((1n << 64n) - 1n));
  }
  divMod(y) {
    let x = this.value;
    let y_ = UInt64.from(y).value;
    if (this.value.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q3 = xn / yn;
      let r2 = xn - q3 * yn;
      return {
        quotient: new UInt64(Field(q3)),
        rest: new UInt64(Field(r2))
      };
    }
    y_ = y_.seal();
    let q2 = Circuit.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));
    q2.rangeCheckHelper(UInt64.NUM_BITS).assertEquals(q2);
    let r = x.sub(q2.mul(y_)).seal();
    r.rangeCheckHelper(UInt64.NUM_BITS).assertEquals(r);
    let r_ = new UInt64(r);
    let q_ = new UInt64(q2);
    r_.assertLt(new UInt64(y_));
    return { quotient: q_, rest: r_ };
  }
  div(y) {
    return this.divMod(y).quotient;
  }
  mod(y) {
    return this.divMod(y).rest;
  }
  mul(y) {
    let z = this.value.mul(UInt64.from(y).value);
    z.rangeCheckHelper(UInt64.NUM_BITS).assertEquals(z);
    return new UInt64(z);
  }
  add(y) {
    let z = this.value.add(UInt64.from(y).value);
    z.rangeCheckHelper(UInt64.NUM_BITS).assertEquals(z);
    return new UInt64(z);
  }
  sub(y) {
    let z = this.value.sub(UInt64.from(y).value);
    z.rangeCheckHelper(UInt64.NUM_BITS).assertEquals(z);
    return new UInt64(z);
  }
  lte(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = xMinusY.rangeCheckHelper(UInt64.NUM_BITS).equals(xMinusY);
      let yMinusXFits = yMinusX.rangeCheckHelper(UInt64.NUM_BITS).equals(yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  assertLte(y, message) {
    let yMinusX = y.value.sub(this.value).seal();
    yMinusX.rangeCheckHelper(UInt64.NUM_BITS).assertEquals(yMinusX, message);
  }
  lt(y) {
    return this.lte(y).and(this.value.equals(y.value).not());
  }
  assertLt(y, message) {
    this.lt(y).assertEquals(true, message);
  }
  gt(y) {
    return y.lt(this);
  }
  assertGt(y, message) {
    y.assertLt(this, message);
  }
  gte(y) {
    return this.lt(y).not();
  }
  assertGte(y, message) {
    y.assertLte(this, message);
  }
};
UInt64.NUM_BITS = 64;
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Field)
], UInt64.prototype, "value", void 0);
var UInt32 = class extends CircuitValue {
  static get zero() {
    return new UInt32(Field(0));
  }
  static get one() {
    return new UInt32(Field(1));
  }
  toString() {
    return this.value.toString();
  }
  toBigint() {
    return this.value.toBigInt();
  }
  toUInt64() {
    return new UInt64(this.value);
  }
  static check(x) {
    let actual = x.value.rangeCheckHelper(32);
    actual.assertEquals(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 32]] };
  }
  static toJSON(x) {
    return x.value.toString();
  }
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt32: Expected number between 0 and 2^32 - 1, got ${xBig}`);
    }
    return x;
  }
  static from(x) {
    if (x instanceof UInt32)
      x = x.value;
    return new this(this.checkConstant(Field(x)));
  }
  static MAXINT() {
    return new UInt32(Field((1n << 32n) - 1n));
  }
  divMod(y) {
    let x = this.value;
    let y_ = UInt32.from(y).value;
    if (x.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q3 = xn / yn;
      let r2 = xn - q3 * yn;
      return {
        quotient: new UInt32(new Field(q3.toString())),
        rest: new UInt32(new Field(r2.toString()))
      };
    }
    y_ = y_.seal();
    let q2 = Circuit.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));
    q2.rangeCheckHelper(UInt32.NUM_BITS).assertEquals(q2);
    let r = x.sub(q2.mul(y_)).seal();
    r.rangeCheckHelper(UInt32.NUM_BITS).assertEquals(r);
    let r_ = new UInt32(r);
    let q_ = new UInt32(q2);
    r_.assertLt(new UInt32(y_));
    return { quotient: q_, rest: r_ };
  }
  div(y) {
    return this.divMod(y).quotient;
  }
  mod(y) {
    return this.divMod(y).rest;
  }
  mul(y) {
    let z = this.value.mul(UInt32.from(y).value);
    z.rangeCheckHelper(UInt32.NUM_BITS).assertEquals(z);
    return new UInt32(z);
  }
  add(y) {
    let z = this.value.add(UInt32.from(y).value);
    z.rangeCheckHelper(UInt32.NUM_BITS).assertEquals(z);
    return new UInt32(z);
  }
  sub(y) {
    let z = this.value.sub(UInt32.from(y).value);
    z.rangeCheckHelper(UInt32.NUM_BITS).assertEquals(z);
    return new UInt32(z);
  }
  lte(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = xMinusY.rangeCheckHelper(UInt32.NUM_BITS).equals(xMinusY);
      let yMinusXFits = yMinusX.rangeCheckHelper(UInt32.NUM_BITS).equals(yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  assertLte(y, message) {
    let yMinusX = y.value.sub(this.value).seal();
    yMinusX.rangeCheckHelper(UInt32.NUM_BITS).assertEquals(yMinusX, message);
  }
  lt(y) {
    return this.lte(y).and(this.value.equals(y.value).not());
  }
  assertLt(y, message) {
    this.lt(y).assertEquals(true, message);
  }
  gt(y) {
    return y.lt(this);
  }
  assertGt(y, message) {
    y.assertLt(this, message);
  }
  gte(y) {
    return this.lt(y).not();
  }
  assertGte(y, message) {
    y.assertLte(this, message);
  }
};
UInt32.NUM_BITS = 32;
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Field)
], UInt32.prototype, "value", void 0);
var Sign = class extends CircuitValue {
  static get one() {
    return new Sign(Field(1));
  }
  static get minusOne() {
    return new Sign(Field(-1));
  }
  static check(x) {
    x.value.square().assertEquals(Field(1));
  }
  static toInput(x) {
    return { packed: [[x.isPositive().toField(), 1]] };
  }
  static toJSON(x) {
    if (x.toString() === "1")
      return "Positive";
    if (x.neg().toString() === "1")
      return "Negative";
    throw Error(`Invalid Sign: ${x}`);
  }
  static fromJSON(x) {
    return x === "Positive" ? new Sign(Field(1)) : new Sign(Field(-1));
  }
  neg() {
    return new Sign(this.value.neg());
  }
  mul(y) {
    return new Sign(this.value.mul(y.value));
  }
  isPositive() {
    return this.value.equals(Field(1));
  }
  toString() {
    return this.value.toString();
  }
};
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Field)
], Sign.prototype, "value", void 0);
var Int64 = class extends CircuitValue {
  constructor(magnitude, sgn = Sign.one) {
    super(magnitude, sgn);
  }
  static fromFieldUnchecked(x) {
    let TWO64 = 1n << 64n;
    let xBigInt = x.toBigInt();
    let isValidPositive = xBigInt < TWO64;
    let isValidNegative = Field.ORDER - xBigInt < TWO64;
    if (!isValidPositive && !isValidNegative)
      throw Error(`Int64: Expected a value between (-2^64, 2^64), got ${x}`);
    let magnitude = Field(isValidPositive ? x.toString() : x.neg().toString());
    let sign = isValidPositive ? Sign.one : Sign.minusOne;
    return new Int64(new UInt64(magnitude), sign);
  }
  static fromUnsigned(x) {
    return new Int64(x instanceof UInt32 ? x.toUInt64() : x);
  }
  static from(x) {
    if (x instanceof Int64)
      return x;
    if (x instanceof UInt64 || x instanceof UInt32) {
      return Int64.fromUnsigned(x);
    }
    return Int64.fromFieldUnchecked(Field(x));
  }
  toString() {
    let abs = this.magnitude.toString();
    let sgn = this.isPositive().toBoolean() || abs === "0" ? "" : "-";
    return sgn + abs;
  }
  isConstant() {
    return this.magnitude.value.isConstant() && this.sgn.isConstant();
  }
  static get zero() {
    return new Int64(UInt64.zero);
  }
  static get one() {
    return new Int64(UInt64.one);
  }
  static get minusOne() {
    return new Int64(UInt64.one).neg();
  }
  toField() {
    return this.magnitude.value.mul(this.sgn.value);
  }
  static fromField(x) {
    if (x.isConstant())
      return Int64.fromFieldUnchecked(x);
    let xInt = Circuit.witness(Int64, () => Int64.fromFieldUnchecked(x));
    xInt.toField().assertEquals(x);
    return xInt;
  }
  neg() {
    return new Int64(this.magnitude, this.sgn.neg());
  }
  add(y) {
    let y_ = Int64.from(y);
    return Int64.fromField(this.toField().add(y_.toField()));
  }
  sub(y) {
    let y_ = Int64.from(y);
    return Int64.fromField(this.toField().sub(y_.toField()));
  }
  mul(y) {
    let y_ = Int64.from(y);
    return Int64.fromField(this.toField().mul(y_.toField()));
  }
  div(y) {
    let y_ = Int64.from(y);
    let { quotient } = this.magnitude.divMod(y_.magnitude);
    let sign = this.sgn.mul(y_.sgn);
    return new Int64(quotient, sign);
  }
  mod(y) {
    let y_ = UInt64.from(y);
    let rest = this.magnitude.divMod(y_).rest.value;
    rest = Circuit.if(this.isPositive(), rest, y_.value.sub(rest));
    return new Int64(new UInt64(rest));
  }
  equals(y) {
    let y_ = Int64.from(y);
    return this.toField().equals(y_.toField());
  }
  assertEquals(y, message) {
    let y_ = Int64.from(y);
    this.toField().assertEquals(y_.toField(), message);
  }
  isPositive() {
    return this.sgn.isPositive();
  }
};
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", UInt64)
], Int64.prototype, "magnitude", void 0);
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Sign)
], Int64.prototype, "sgn", void 0);

// dist/node/provable/gen/transaction.js
var transaction_exports = {};
__export(transaction_exports, {
  AccountUpdate: () => AccountUpdate,
  AuthRequired: () => AuthRequired,
  AuthorizationKind: () => AuthorizationKind,
  Bool: () => Bool,
  Events: () => Events,
  Field: () => Field,
  Json: () => transaction_json_exports,
  PublicKey: () => PublicKey,
  SequenceEvents: () => SequenceEvents,
  SequenceState: () => SequenceState,
  Sign: () => Sign,
  StringWithHash: () => StringWithHash,
  TokenId: () => TokenId,
  TokenSymbol: () => TokenSymbol2,
  UInt32: () => UInt32,
  UInt64: () => UInt64,
  ZkappCommand: () => ZkappCommand,
  customTypes: () => customTypes,
  provableFromLayout: () => provableFromLayout,
  toJSONEssential: () => toJSONEssential
});

// dist/node/provable/provable-generic.js
function createProvable() {
  const HashInput2 = {
    get empty() {
      return {};
    },
    append(input1, input2) {
      if (input2.fields !== void 0) {
        (input1.fields ?? (input1.fields = [])).push(...input2.fields);
      }
      if (input2.packed !== void 0) {
        (input1.packed ?? (input1.packed = [])).push(...input2.packed);
      }
      return input1;
    }
  };
  let complexTypes2 = new Set(["object", "function"]);
  function provable2(typeObj, options) {
    let objectKeys = typeof typeObj === "object" && typeObj !== null ? options?.customObjectKeys ?? Object.keys(typeObj).sort() : [];
    let nonCircuitPrimitives = new Set([
      Number,
      String,
      Boolean,
      BigInt,
      null,
      void 0
    ]);
    if (!nonCircuitPrimitives.has(typeObj) && !complexTypes2.has(typeof typeObj)) {
      throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function sizeInFields(typeObj2) {
      if (nonCircuitPrimitives.has(typeObj2))
        return 0;
      if (Array.isArray(typeObj2))
        return typeObj2.map(sizeInFields).reduce((a, b) => a + b, 0);
      if ("sizeInFields" in typeObj2)
        return typeObj2.sizeInFields();
      return Object.values(typeObj2).map(sizeInFields).reduce((a, b) => a + b, 0);
    }
    function toFields(typeObj2, obj, isToplevel = false) {
      if (nonCircuitPrimitives.has(typeObj2))
        return [];
      if (!complexTypes2.has(typeof typeObj2) || typeObj2 === null)
        return [];
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toFields(t, obj[i2])).flat();
      if ("toFields" in typeObj2)
        return typeObj2.toFields(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toFields(typeObj2[k], obj[k])).flat();
    }
    function toAuxiliary(typeObj2, obj, isToplevel = false) {
      if (typeObj2 === Number)
        return [obj ?? 0];
      if (typeObj2 === String)
        return [obj ?? ""];
      if (typeObj2 === Boolean)
        return [obj ?? false];
      if (typeObj2 === BigInt)
        return [obj ?? 0n];
      if (typeObj2 === void 0 || typeObj2 === null)
        return [];
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toAuxiliary(t, obj?.[i2]));
      if ("toAuxiliary" in typeObj2)
        return typeObj2.toAuxiliary(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toAuxiliary(typeObj2[k], obj?.[k]));
    }
    function toInput(typeObj2, obj, isToplevel = false) {
      if (nonCircuitPrimitives.has(typeObj2))
        return {};
      if (Array.isArray(typeObj2)) {
        return typeObj2.map((t, i2) => toInput(t, obj[i2])).reduce(HashInput2.append, {});
      }
      if ("toInput" in typeObj2)
        return typeObj2.toInput(obj);
      if ("toFields" in typeObj2) {
        return { fields: typeObj2.toFields(obj) };
      }
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toInput(typeObj2[k], obj[k])).reduce(HashInput2.append, {});
    }
    function toJSON(typeObj2, obj, isToplevel = false) {
      if (typeObj2 === BigInt)
        return obj.toString();
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return obj;
      if (typeObj2 === void 0 || typeObj2 === null)
        return null;
      if (!complexTypes2.has(typeof typeObj2) || typeObj2 === null)
        return obj ?? null;
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toJSON(t, obj[i2]));
      if ("toJSON" in typeObj2)
        return typeObj2.toJSON(obj);
      return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => [
        k,
        toJSON(typeObj2[k], obj[k])
      ]));
    }
    function fromFields(typeObj2, fields, aux = [], isToplevel = false) {
      if (typeObj2 === Number || typeObj2 === String || typeObj2 === Boolean || typeObj2 === BigInt)
        return aux[0];
      if (typeObj2 === void 0 || typeObj2 === null)
        return typeObj2;
      if (!complexTypes2.has(typeof typeObj2))
        return null;
      if (Array.isArray(typeObj2)) {
        let array = [];
        let i2 = 0;
        let offset = 0;
        for (let subObj of typeObj2) {
          let size = sizeInFields(subObj);
          array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i2]));
          offset += size;
          i2++;
        }
        return array;
      }
      if ("fromFields" in typeObj2)
        return typeObj2.fromFields(fields, aux);
      let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
      let values = fromFields(keys.map((k) => typeObj2[k]), fields, aux);
      return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
    }
    function fromJSON(typeObj2, json, isToplevel = false) {
      if (typeObj2 === BigInt)
        return BigInt(json);
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return json;
      if (typeObj2 === null)
        return void 0;
      if (!complexTypes2.has(typeof typeObj2))
        return json ?? void 0;
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => fromJSON(t, json[i2]));
      if ("fromJSON" in typeObj2)
        return typeObj2.fromJSON(json);
      let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
      let values = fromJSON(keys.map((k) => typeObj2[k]), json);
      return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
    }
    function check(typeObj2, obj, isToplevel = false) {
      if (nonCircuitPrimitives.has(typeObj2))
        return;
      if (Array.isArray(typeObj2))
        return typeObj2.forEach((t, i2) => check(t, obj[i2]));
      if ("check" in typeObj2)
        return typeObj2.check(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).forEach((k) => check(typeObj2[k], obj[k]));
    }
    if (options?.isPure === true) {
      return {
        sizeInFields: () => sizeInFields(typeObj),
        toFields: (obj) => toFields(typeObj, obj, true),
        toAuxiliary: () => [],
        fromFields: (fields) => fromFields(typeObj, fields, [], true),
        toInput: (obj) => toInput(typeObj, obj, true),
        toJSON: (obj) => toJSON(typeObj, obj, true),
        fromJSON: (json) => fromJSON(typeObj, json, true),
        check: (obj) => check(typeObj, obj, true)
      };
    }
    return {
      sizeInFields: () => sizeInFields(typeObj),
      toFields: (obj) => toFields(typeObj, obj, true),
      toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
      fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
      toInput: (obj) => toInput(typeObj, obj, true),
      toJSON: (obj) => toJSON(typeObj, obj, true),
      fromJSON: (json) => fromJSON(typeObj, json, true),
      check: (obj) => check(typeObj, obj, true)
    };
  }
  return provable2;
}

// dist/node/js_crypto/constants.js
var versionBytes = {
  "tokenIdKey": 28,
  "receiptChainHash": 12,
  "ledgerHash": 5,
  "epochSeed": 13,
  "stateHash": 16,
  "publicKey": 203,
  "userCommandMemo": 20,
  "privateKey": 90,
  "signature": 154
};

// dist/node/provable/binable.js
function withVersionNumber(binable, versionNumber) {
  return {
    toBytes(t) {
      let bytes = binable.toBytes(t);
      if (versionNumber !== void 0)
        bytes.unshift(versionNumber);
      return bytes;
    },
    fromBytes(bytes) {
      if (versionNumber !== void 0)
        bytes.shift();
      return binable.fromBytes(bytes);
    },
    sizeInBytes() {
      let size = binable.sizeInBytes();
      return versionNumber !== void 0 ? size + 1 : size;
    }
  };
}
function base58(binable, versionByte) {
  return {
    toBase58(t) {
      let bytes = binable.toBytes(t);
      let binaryString = String.fromCharCode(...bytes);
      let ocamlBytes = { t: 9, c: binaryString, l: bytes.length };
      return Ledger.encoding.toBase58(ocamlBytes, versionByte);
    },
    fromBase58(base582) {
      let ocamlBytes = Ledger.encoding.ofBase58(base582, versionByte);
      let bytes = [...ocamlBytes.c].map((_, i2) => ocamlBytes.c.charCodeAt(i2));
      return binable.fromBytes(bytes);
    }
  };
}
function customEncoding(Field2, versionByte, versionNumber) {
  return base58(withVersionNumber(Field2, versionNumber), versionByte);
}
var RECEIPT_CHAIN_HASH_VERSION = 1;
var LEDGER_HASH_VERSION = 1;
var EPOCH_SEED_VERSION = 1;
var STATE_HASH_VERSION = 1;
function fieldEncodings(Field2) {
  const TokenId4 = customEncoding(Field2, versionBytes.tokenIdKey);
  const ReceiptChainHash2 = customEncoding(Field2, versionBytes.receiptChainHash, RECEIPT_CHAIN_HASH_VERSION);
  const LedgerHash2 = customEncoding(Field2, versionBytes.ledgerHash, LEDGER_HASH_VERSION);
  const EpochSeed2 = customEncoding(Field2, versionBytes.epochSeed, EPOCH_SEED_VERSION);
  const StateHash2 = customEncoding(Field2, versionBytes.stateHash, STATE_HASH_VERSION);
  return { TokenId: TokenId4, ReceiptChainHash: ReceiptChainHash2, LedgerHash: LedgerHash2, EpochSeed: EpochSeed2, StateHash: StateHash2 };
}
function prefixToField2(Field2, prefix) {
  if (prefix.length >= Field2.sizeInBytes())
    throw Error("prefix too long");
  let bytes = [...prefix].map((char) => char.charCodeAt(0));
  return Field2.fromBytes(bytes);
}

// dist/node/provable/derived-leaves.js
function derivedLeafTypes({ Field: Field2, Bool: Bool2 }) {
  let provable2 = createProvable();
  const Encoding4 = fieldEncodings(Field2);
  const defaultTokenId = 1;
  const TokenId4 = {
    ...provable2(Field2),
    emptyValue() {
      return Field2(defaultTokenId);
    },
    toJSON(x) {
      return Encoding4.TokenId.toBase58(x);
    },
    fromJSON(x) {
      return Encoding4.TokenId.fromBase58(x);
    }
  };
  const TokenSymbol3 = {
    ...provable2({ field: Field2, symbol: String }),
    toInput({ field }) {
      return { packed: [[field, 48]] };
    },
    toJSON({ symbol }) {
      return symbol;
    },
    fromJSON(symbol) {
      return { symbol, field: prefixToField2(Field2, symbol) };
    }
  };
  const AuthRequired2 = {
    ...provable2({ constant: Bool2, signatureNecessary: Bool2, signatureSufficient: Bool2 }, {
      customObjectKeys: [
        "constant",
        "signatureNecessary",
        "signatureSufficient"
      ]
    }),
    emptyValue() {
      return {
        constant: Bool2(true),
        signatureNecessary: Bool2(false),
        signatureSufficient: Bool2(true)
      };
    },
    toJSON(x) {
      let c = Number(Bool2.toJSON(x.constant));
      let n = Number(Bool2.toJSON(x.signatureNecessary));
      let s = Number(Bool2.toJSON(x.signatureSufficient));
      switch (`${c}${n}${s}`) {
        case "110":
          return "Impossible";
        case "101":
          return "None";
        case "000":
          return "Proof";
        case "011":
          return "Signature";
        case "001":
          return "Either";
        default:
          throw Error("Unexpected permission");
      }
    },
    fromJSON(json) {
      let map = {
        Impossible: "110",
        None: "101",
        Proof: "000",
        Signature: "011",
        Either: "001"
      };
      let code = map[json];
      if (code === void 0)
        throw Error("Unexpected permission");
      let [constant, signatureNecessary, signatureSufficient] = code.split("").map((s) => Bool2(!!Number(s)));
      return { constant, signatureNecessary, signatureSufficient };
    }
  };
  const AuthorizationKind2 = {
    ...provable2({ isSigned: Bool2, isProved: Bool2 }, {
      customObjectKeys: ["isSigned", "isProved"]
    }),
    toJSON(x) {
      let isSigned = Number(Bool2.toJSON(x.isSigned));
      let isProved = Number(Bool2.toJSON(x.isProved));
      switch (`${isSigned}${isProved}`) {
        case "00":
          return "None_given";
        case "10":
          return "Signature";
        case "01":
          return "Proof";
        default:
          throw Error("Unexpected authorization kind");
      }
    },
    fromJSON(json) {
      let booleans = {
        None_given: [false, false],
        Signature: [true, false],
        Proof: [false, true]
      }[json];
      if (booleans === void 0)
        throw Error("Unexpected authorization kind");
      let [isSigned, isProved] = booleans.map(Bool2);
      return { isSigned, isProved };
    }
  };
  return { TokenId: TokenId4, TokenSymbol: TokenSymbol3, AuthRequired: AuthRequired2, AuthorizationKind: AuthorizationKind2 };
}

// dist/node/lib/events.js
var prefixes2 = new Proxy({}, {
  get(_target, prop2) {
    return Poseidon.prefixes[prop2];
  }
});
function createEvents({ Field: Field2, Poseidon: Poseidon3 }) {
  function initialState() {
    return [Field2(0), Field2(0), Field2(0)];
  }
  function salt2(prefix) {
    return Poseidon3.update(initialState(), [prefixToField2(Field2, prefix)]);
  }
  function hashWithPrefix2(prefix, input) {
    let init = salt2(prefix);
    return Poseidon3.update(init, input)[0];
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  const Events2 = {
    empty() {
      let hash = emptyHashWithPrefix2("MinaZkappEventsEmpty");
      return { hash, data: [] };
    },
    pushEvent(events, event) {
      let eventHash = hashWithPrefix2(prefixes2.event, event);
      let hash = hashWithPrefix2(prefixes2.events, [events.hash, eventHash]);
      return { hash, data: [event, ...events.data] };
    },
    hash(events) {
      return [...events].reverse().reduce(Events2.pushEvent, Events2.empty()).hash;
    }
  };
  const EventsProvable = {
    ...Events2,
    ...dataAsHash({
      emptyValue: Events2.empty,
      toJSON(data) {
        return data.map((row) => row.map((e) => Field2.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field2.fromJSON(e)));
        let hash = Events2.hash(data);
        return { data, hash };
      }
    })
  };
  const SequenceEvents2 = {
    empty() {
      let hash = emptyHashWithPrefix2("MinaZkappSequenceEmpty");
      return { hash, data: [] };
    },
    pushEvent(sequenceEvents, event) {
      let eventHash = hashWithPrefix2(prefixes2.event, event);
      let hash = hashWithPrefix2(prefixes2.sequenceEvents, [
        sequenceEvents.hash,
        eventHash
      ]);
      return { hash, data: [event, ...sequenceEvents.data] };
    },
    hash(events) {
      return [...events].reverse().reduce(SequenceEvents2.pushEvent, SequenceEvents2.empty()).hash;
    },
    emptySequenceState() {
      return emptyHashWithPrefix2("MinaZkappSequenceStateEmptyElt");
    },
    updateSequenceState(state2, sequenceEventsHash) {
      return hashWithPrefix2(prefixes2.sequenceEvents, [
        state2,
        sequenceEventsHash
      ]);
    }
  };
  const SequenceEventsProvable = {
    ...SequenceEvents2,
    ...dataAsHash({
      emptyValue: SequenceEvents2.empty,
      toJSON(data) {
        return data.map((row) => row.map((e) => Field2.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field2.fromJSON(e)));
        let hash = SequenceEvents2.hash(data);
        return { data, hash };
      }
    })
  };
  return { Events: EventsProvable, SequenceEvents: SequenceEventsProvable };
}
function dataAsHash({ emptyValue: emptyValue2, toJSON, fromJSON }) {
  return {
    emptyValue: emptyValue2,
    sizeInFields() {
      return 1;
    },
    toFields({ hash }) {
      return [hash];
    },
    toAuxiliary(value) {
      return [value?.data ?? emptyValue2().data];
    },
    fromFields([hash], [data]) {
      return { data, hash };
    },
    toJSON({ data }) {
      return toJSON(data);
    },
    fromJSON(json) {
      return fromJSON(json);
    },
    check() {
    },
    toInput({ hash }) {
      return { fields: [hash] };
    }
  };
}

// dist/node/provable/transaction-leaves.js
var { TokenId, TokenSymbol: TokenSymbol2, AuthRequired, AuthorizationKind } = derivedLeafTypes({ Field, Bool });
var { Events, SequenceEvents } = createEvents({ Field, Poseidon: Poseidon2 });
var SequenceState = {
  ...provable(Field),
  emptyValue: SequenceEvents.emptySequenceState
};
var StringWithHash = dataAsHash({
  emptyValue() {
    return {
      data: "",
      hash: Field("22930868938364086394602058221028773520482901241511717002947639863679740444066")
    };
  },
  toJSON(data) {
    return data;
  },
  fromJSON(json) {
    let data = json;
    throw Error("unimplemented");
  }
});

// dist/node/provable/generic.js
var emptyType = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: () => [],
  fromFields: () => null,
  check: () => {
  },
  toInput: () => ({}),
  toJSON: () => null,
  fromJSON: () => null
};
var primitiveTypes = new Set(["number", "string", "null"]);
function primitiveTypeMap() {
  return {
    number: {
      ...emptyType,
      toAuxiliary: (value = 0) => [value],
      toJSON: (value) => value,
      fromJSON: (value) => value,
      fromFields: (_, [value]) => value
    },
    string: {
      ...emptyType,
      toAuxiliary: (value = "") => [value],
      toJSON: (value) => value,
      fromJSON: (value) => value,
      fromFields: (_, [value]) => value
    },
    null: emptyType
  };
}

// dist/node/provable/from-layout.js
function ProvableFromLayout(TypeMap2, customTypes2) {
  const Field2 = TypeMap2.Field;
  const PrimitiveMap = primitiveTypeMap();
  function provableFromLayout2(typeData) {
    return {
      sizeInFields() {
        return sizeInFields(typeData);
      },
      toFields(value) {
        return toFields(typeData, value);
      },
      toAuxiliary(value) {
        return toAuxiliary(typeData, value);
      },
      fromFields(fields, aux) {
        return fromFields(typeData, fields, aux);
      },
      toJSON(value) {
        return toJSON(typeData, value);
      },
      fromJSON(json) {
        return fromJSON(typeData, json);
      },
      check(value) {
        check(typeData, value);
      },
      toInput(value) {
        return toInput(typeData, value);
      },
      emptyValue() {
        return emptyValue2(typeData);
      }
    };
  }
  function toJSON(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  function fromJSON(typeData, json) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes2[checkedTypeName].fromJSON(json);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      return json.map((json2) => fromJSON(arrayTypeData.inner, json2));
    }
    if (typeData.type === "option") {
      let optionTypeData = typeData;
      switch (optionTypeData.optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let isSome = TypeMap2.Bool.fromJSON(json !== null);
          let value;
          if (json !== null) {
            value = fromJSON(optionTypeData.inner, json);
          } else {
            value = emptyValue2(optionTypeData.inner);
            if (optionTypeData.optionType === "closedInterval") {
              let innerInner = optionTypeData.inner.entries.lower;
              let innerType = TypeMap2[innerInner.type];
              value.lower = innerType.fromJSON(optionTypeData.rangeMin);
              value.upper = innerType.fromJSON(optionTypeData.rangeMax);
            }
          }
          return { isSome, value };
        }
        case "orUndefined": {
          return json === null ? void 0 : fromJSON(optionTypeData.inner, json);
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        values[keys[i2]] = fromJSON(typeEntry, json[keys[i2]]);
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return PrimitiveMap[typeData.type].fromJSON(json);
    }
    return TypeMap2[typeData.type].fromJSON(json);
  }
  function toFields(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toFields(value2);
      },
      reduceArray(array) {
        return array.flat();
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).flat();
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return [isSome, value2].flat();
      },
      reduceOrUndefined(_) {
        return [];
      }
    }, typeData, value);
  }
  function toAuxiliary(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toAuxiliary(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]);
      },
      reduceFlaggedOption({ value: value2 }) {
        return value2;
      },
      reduceOrUndefined(value2) {
        return value2 === void 0 ? [false] : [true, value2];
      }
    }, typeData, value);
  }
  function sizeInFields(typeData) {
    let spec = {
      map(type) {
        return type.sizeInFields();
      },
      reduceArray(_, { inner, staticLength }) {
        let length = staticLength ?? NaN;
        return length * layoutFold(spec, inner);
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).reduce((x, y) => x + y);
      },
      reduceFlaggedOption({ isSome, value }) {
        return isSome + value;
      },
      reduceOrUndefined(_) {
        return 0;
      }
    };
    return layoutFold(spec, typeData);
  }
  function fromFields(typeData, fields, aux) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes2[checkedTypeName].fromFields(fields, aux);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      let size = sizeInFields(arrayTypeData.inner);
      let length = aux.length;
      let value = [];
      for (let i2 = 0, offset = 0; i2 < length; i2++, offset += size) {
        value[i2] = fromFields(arrayTypeData.inner, fields.slice(offset, offset + size), aux[i2]);
      }
      return value;
    }
    if (typeData.type === "option") {
      let { optionType, inner } = typeData;
      switch (optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let [first, ...rest] = fields;
          let isSome = TypeMap2.Bool.fromFields([first], []);
          let value = fromFields(inner, rest, aux);
          return { isSome, value };
        }
        case "orUndefined": {
          let [isDefined, value] = aux;
          return isDefined ? fromFields(inner, fields, value) : void 0;
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      let offset = 0;
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        let size = sizeInFields(typeEntry);
        values[keys[i2]] = fromFields(typeEntry, fields.slice(offset, offset + size), aux[i2]);
        offset += size;
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return PrimitiveMap[typeData.type].fromFields(fields, aux);
    }
    return TypeMap2[typeData.type].fromFields(fields, aux);
  }
  function emptyValue2(typeData) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return emptyValueBase(typeData);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      let { inner, staticLength } = arrayTypeData;
      if (staticLength == null)
        return [];
      return Array(staticLength).fill(emptyValue2(inner));
    }
    if (typeData.type === "option") {
      let optionTypeData = typeData;
      switch (optionTypeData.optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let isSome = TypeMap2.Bool.fromJSON(false);
          let value = emptyValue2(optionTypeData.inner);
          if (optionTypeData.optionType === "closedInterval") {
            let innerInner = optionTypeData.inner.entries.lower;
            let innerType = TypeMap2[innerInner.type];
            value.lower = innerType.fromJSON(optionTypeData.rangeMin);
            value.upper = innerType.fromJSON(optionTypeData.rangeMax);
          }
          return { isSome, value };
        }
        case "orUndefined": {
          return void 0;
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        values[keys[i2]] = emptyValue2(typeEntry);
      }
      return values;
    }
    return emptyValueBase(typeData);
  }
  function emptyValueBase(typeData) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      let checkedType = customTypes2[checkedTypeName];
      if (checkedType.emptyValue)
        return checkedType.emptyValue();
    }
    let typeName = typeData.type;
    if (TypeMap2[typeName]) {
      let type = TypeMap2[typeName];
      if (type.emptyValue)
        return type.emptyValue();
    }
    let zero = Field2.fromJSON("0");
    let fields = Array(sizeInFields(typeData)).fill(zero);
    return fromFields(typeData, fields, toAuxiliary(typeData));
  }
  function check(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.check(value2);
      },
      reduceArray() {
      },
      reduceObject() {
      },
      reduceFlaggedOption() {
      },
      reduceOrUndefined() {
      }
    }, typeData, value);
  }
  function toInput(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toInput(value2);
      },
      reduceArray(array) {
        let acc = { fields: [], packed: [] };
        for (let { fields, packed } of array) {
          if (fields)
            acc.fields.push(...fields);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceObject(keys, object) {
        let acc = { fields: [], packed: [] };
        for (let key of keys) {
          let { fields, packed } = object[key];
          if (fields)
            acc.fields.push(...fields);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return {
          fields: value2.fields,
          packed: isSome.packed.concat(value2.packed ?? [])
        };
      },
      reduceOrUndefined(_) {
        return {};
      }
    }, typeData, value);
  }
  function layoutFold(spec, typeData, value) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return spec.map(customTypes2[checkedTypeName], value);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      let v = value;
      if (arrayTypeData.staticLength != null && v === void 0) {
        v = Array(arrayTypeData.staticLength).fill(void 0);
      }
      let array = v?.map((x) => layoutFold(spec, arrayTypeData.inner, x)) ?? [];
      return spec.reduceArray(array, arrayTypeData);
    }
    if (typeData.type === "option") {
      let { optionType, inner } = typeData;
      switch (optionType) {
        case "closedInterval":
        case "flaggedOption":
          let v = value;
          return spec.reduceFlaggedOption({
            isSome: spec.map(TypeMap2.Bool, v?.isSome),
            value: layoutFold(spec, inner, v?.value)
          });
        case "orUndefined":
          let mapped = value === void 0 ? void 0 : layoutFold(spec, inner, value);
          return spec.reduceOrUndefined(mapped);
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let v = value;
      let object = {};
      keys.forEach((key) => {
        object[key] = layoutFold(spec, entries[key], v?.[key]);
      });
      return spec.reduceObject(keys, object);
    }
    if (primitiveTypes.has(typeData.type)) {
      return spec.map(PrimitiveMap[typeData.type], value);
    }
    return spec.map(TypeMap2[typeData.type], value);
  }
  function toJSONEssential2(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        if (array.length === 0 || array.every((x) => x === null))
          return null;
        return array;
      },
      reduceObject(_, object) {
        for (let key in object) {
          if (object[key] === null) {
            delete object[key];
          }
        }
        if (Object.keys(object).length === 0)
          return null;
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  return { provableFromLayout: provableFromLayout2, toJSONEssential: toJSONEssential2 };
}

// dist/node/provable/gen/transaction-json.js
var transaction_json_exports = {};
__markAsModule(transaction_json_exports);

// dist/node/provable/gen/js-layout.js
var jsLayout = {
  ZkappCommand: {
    type: "object",
    name: "ZkappCommand",
    docs: null,
    keys: ["feePayer", "accountUpdates", "memo"],
    entries: {
      feePayer: {
        type: "object",
        name: "ZkappFeePayer",
        docs: null,
        keys: ["body", "authorization"],
        entries: {
          body: {
            type: "object",
            name: "FeePayerBody",
            docs: null,
            keys: ["publicKey", "fee", "validUntil", "nonce"],
            entries: {
              publicKey: { type: "PublicKey" },
              fee: { type: "UInt64" },
              validUntil: {
                type: "option",
                optionType: "orUndefined",
                inner: { type: "UInt32" }
              },
              nonce: { type: "UInt32" }
            },
            docEntries: {
              publicKey: null,
              fee: null,
              validUntil: null,
              nonce: null
            }
          },
          authorization: { type: "string" }
        },
        docEntries: { body: null, authorization: null }
      },
      accountUpdates: {
        type: "array",
        inner: {
          type: "object",
          name: "ZkappAccountUpdate",
          docs: "An account update in a zkApp transaction",
          keys: ["body", "authorization"],
          entries: {
            body: {
              type: "object",
              name: "AccountUpdateBody",
              docs: null,
              keys: [
                "publicKey",
                "tokenId",
                "update",
                "balanceChange",
                "incrementNonce",
                "events",
                "sequenceEvents",
                "callData",
                "callDepth",
                "preconditions",
                "useFullCommitment",
                "caller",
                "authorizationKind"
              ],
              entries: {
                publicKey: { type: "PublicKey" },
                tokenId: { type: "TokenId" },
                update: {
                  type: "object",
                  name: "AccountUpdateModification",
                  docs: null,
                  keys: [
                    "appState",
                    "delegate",
                    "verificationKey",
                    "permissions",
                    "zkappUri",
                    "tokenSymbol",
                    "timing",
                    "votingFor"
                  ],
                  entries: {
                    appState: {
                      type: "array",
                      inner: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      staticLength: 8
                    },
                    delegate: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "PublicKey" }
                    },
                    verificationKey: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "VerificationKeyWithHash",
                        docs: null,
                        keys: ["data", "hash"],
                        entries: {
                          data: { type: "string" },
                          hash: { type: "Field" }
                        },
                        docEntries: { data: null, hash: null }
                      }
                    },
                    permissions: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Permissions",
                        docs: null,
                        keys: [
                          "editState",
                          "send",
                          "receive",
                          "setDelegate",
                          "setPermissions",
                          "setVerificationKey",
                          "setZkappUri",
                          "editSequenceState",
                          "setTokenSymbol",
                          "incrementNonce",
                          "setVotingFor"
                        ],
                        entries: {
                          editState: { type: "AuthRequired" },
                          send: { type: "AuthRequired" },
                          receive: { type: "AuthRequired" },
                          setDelegate: { type: "AuthRequired" },
                          setPermissions: { type: "AuthRequired" },
                          setVerificationKey: { type: "AuthRequired" },
                          setZkappUri: { type: "AuthRequired" },
                          editSequenceState: { type: "AuthRequired" },
                          setTokenSymbol: { type: "AuthRequired" },
                          incrementNonce: { type: "AuthRequired" },
                          setVotingFor: { type: "AuthRequired" }
                        },
                        docEntries: {
                          editState: null,
                          send: null,
                          receive: null,
                          setDelegate: null,
                          setPermissions: null,
                          setVerificationKey: null,
                          setZkappUri: null,
                          editSequenceState: null,
                          setTokenSymbol: null,
                          incrementNonce: null,
                          setVotingFor: null
                        }
                      }
                    },
                    zkappUri: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Events",
                          docs: null,
                          keys: ["data", "hash"],
                          entries: {
                            data: { type: "string" },
                            hash: { type: "Field" }
                          },
                          docEntries: { data: null, hash: null }
                        },
                        checkedTypeName: "StringWithHash"
                      }
                    },
                    tokenSymbol: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: { type: "TokenSymbol" },
                        checkedTypeName: "TokenSymbol"
                      }
                    },
                    timing: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Timing",
                        docs: null,
                        keys: [
                          "initialMinimumBalance",
                          "cliffTime",
                          "cliffAmount",
                          "vestingPeriod",
                          "vestingIncrement"
                        ],
                        entries: {
                          initialMinimumBalance: { type: "UInt64" },
                          cliffTime: { type: "UInt32" },
                          cliffAmount: { type: "UInt64" },
                          vestingPeriod: { type: "UInt32" },
                          vestingIncrement: { type: "UInt64" }
                        },
                        docEntries: {
                          initialMinimumBalance: null,
                          cliffTime: null,
                          cliffAmount: null,
                          vestingPeriod: null,
                          vestingIncrement: null
                        }
                      }
                    },
                    votingFor: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "Field" }
                    }
                  },
                  docEntries: {
                    appState: null,
                    delegate: null,
                    verificationKey: null,
                    permissions: null,
                    zkappUri: null,
                    tokenSymbol: null,
                    timing: null,
                    votingFor: null
                  }
                },
                balanceChange: {
                  type: "object",
                  name: "BalanceChange",
                  docs: null,
                  keys: ["magnitude", "sgn"],
                  entries: {
                    magnitude: { type: "UInt64" },
                    sgn: { type: "Sign" }
                  },
                  docEntries: { magnitude: null, sgn: null }
                },
                incrementNonce: { type: "Bool" },
                events: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Events"
                },
                sequenceEvents: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "SequenceEvents"
                },
                callData: { type: "Field" },
                callDepth: { type: "number" },
                preconditions: {
                  type: "object",
                  name: "Preconditions",
                  docs: null,
                  keys: ["network", "account"],
                  entries: {
                    network: {
                      type: "object",
                      name: "NetworkPrecondition",
                      docs: null,
                      keys: [
                        "snarkedLedgerHash",
                        "timestamp",
                        "blockchainLength",
                        "minWindowDensity",
                        "totalCurrency",
                        "globalSlotSinceHardFork",
                        "globalSlotSinceGenesis",
                        "stakingEpochData",
                        "nextEpochData"
                      ],
                      entries: {
                        snarkedLedgerHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        timestamp: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "BlockTimeInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        blockchainLength: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        minWindowDensity: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        totalCurrency: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "CurrencyAmountInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        globalSlotSinceHardFork: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "GlobalSlotInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        globalSlotSinceGenesis: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "GlobalSlotInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        stakingEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        },
                        nextEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        }
                      },
                      docEntries: {
                        snarkedLedgerHash: null,
                        timestamp: null,
                        blockchainLength: null,
                        minWindowDensity: null,
                        totalCurrency: null,
                        globalSlotSinceHardFork: null,
                        globalSlotSinceGenesis: null,
                        stakingEpochData: null,
                        nextEpochData: null
                      }
                    },
                    account: {
                      type: "object",
                      name: "AccountPrecondition",
                      docs: null,
                      keys: [
                        "balance",
                        "nonce",
                        "receiptChainHash",
                        "delegate",
                        "state",
                        "sequenceState",
                        "provedState",
                        "isNew"
                      ],
                      entries: {
                        balance: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "BalanceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        nonce: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "NonceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        receiptChainHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        delegate: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "PublicKey" }
                        },
                        state: {
                          type: "array",
                          inner: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          staticLength: 8
                        },
                        sequenceState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: {
                            type: "Field",
                            checkedType: { type: "Field" },
                            checkedTypeName: "SequenceState"
                          }
                        },
                        provedState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        },
                        isNew: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        }
                      },
                      docEntries: {
                        balance: null,
                        nonce: null,
                        receiptChainHash: null,
                        delegate: null,
                        state: null,
                        sequenceState: null,
                        provedState: null,
                        isNew: null
                      }
                    }
                  },
                  docEntries: { network: null, account: null }
                },
                useFullCommitment: { type: "Bool" },
                caller: { type: "TokenId" },
                authorizationKind: { type: "AuthorizationKind" }
              },
              docEntries: {
                publicKey: null,
                tokenId: null,
                update: null,
                balanceChange: null,
                incrementNonce: null,
                events: null,
                sequenceEvents: null,
                callData: null,
                callDepth: null,
                preconditions: null,
                useFullCommitment: null,
                caller: null,
                authorizationKind: null
              }
            },
            authorization: {
              type: "object",
              name: "Control",
              docs: null,
              keys: ["proof", "signature"],
              entries: {
                proof: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                },
                signature: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                }
              },
              docEntries: { proof: null, signature: null }
            }
          },
          docEntries: { body: null, authorization: null }
        },
        staticLength: null
      },
      memo: { type: "string" }
    },
    docEntries: { feePayer: null, accountUpdates: null, memo: null }
  },
  AccountUpdate: {
    type: "object",
    name: "ZkappAccountUpdate",
    docs: "An account update in a zkApp transaction",
    keys: ["body", "authorization"],
    entries: {
      body: {
        type: "object",
        name: "AccountUpdateBody",
        docs: null,
        keys: [
          "publicKey",
          "tokenId",
          "update",
          "balanceChange",
          "incrementNonce",
          "events",
          "sequenceEvents",
          "callData",
          "callDepth",
          "preconditions",
          "useFullCommitment",
          "caller",
          "authorizationKind"
        ],
        entries: {
          publicKey: { type: "PublicKey" },
          tokenId: { type: "TokenId" },
          update: {
            type: "object",
            name: "AccountUpdateModification",
            docs: null,
            keys: [
              "appState",
              "delegate",
              "verificationKey",
              "permissions",
              "zkappUri",
              "tokenSymbol",
              "timing",
              "votingFor"
            ],
            entries: {
              appState: {
                type: "array",
                inner: {
                  type: "option",
                  optionType: "flaggedOption",
                  inner: { type: "Field" }
                },
                staticLength: 8
              },
              delegate: {
                type: "option",
                optionType: "flaggedOption",
                inner: { type: "PublicKey" }
              },
              verificationKey: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "VerificationKeyWithHash",
                  docs: null,
                  keys: ["data", "hash"],
                  entries: {
                    data: { type: "string" },
                    hash: { type: "Field" }
                  },
                  docEntries: { data: null, hash: null }
                }
              },
              permissions: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Permissions",
                  docs: null,
                  keys: [
                    "editState",
                    "send",
                    "receive",
                    "setDelegate",
                    "setPermissions",
                    "setVerificationKey",
                    "setZkappUri",
                    "editSequenceState",
                    "setTokenSymbol",
                    "incrementNonce",
                    "setVotingFor"
                  ],
                  entries: {
                    editState: { type: "AuthRequired" },
                    send: { type: "AuthRequired" },
                    receive: { type: "AuthRequired" },
                    setDelegate: { type: "AuthRequired" },
                    setPermissions: { type: "AuthRequired" },
                    setVerificationKey: { type: "AuthRequired" },
                    setZkappUri: { type: "AuthRequired" },
                    editSequenceState: { type: "AuthRequired" },
                    setTokenSymbol: { type: "AuthRequired" },
                    incrementNonce: { type: "AuthRequired" },
                    setVotingFor: { type: "AuthRequired" }
                  },
                  docEntries: {
                    editState: null,
                    send: null,
                    receive: null,
                    setDelegate: null,
                    setPermissions: null,
                    setVerificationKey: null,
                    setZkappUri: null,
                    editSequenceState: null,
                    setTokenSymbol: null,
                    incrementNonce: null,
                    setVotingFor: null
                  }
                }
              },
              zkappUri: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: { type: "string" },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "StringWithHash"
                }
              },
              tokenSymbol: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: { type: "TokenSymbol" },
                  checkedTypeName: "TokenSymbol"
                }
              },
              timing: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Timing",
                  docs: null,
                  keys: [
                    "initialMinimumBalance",
                    "cliffTime",
                    "cliffAmount",
                    "vestingPeriod",
                    "vestingIncrement"
                  ],
                  entries: {
                    initialMinimumBalance: { type: "UInt64" },
                    cliffTime: { type: "UInt32" },
                    cliffAmount: { type: "UInt64" },
                    vestingPeriod: { type: "UInt32" },
                    vestingIncrement: { type: "UInt64" }
                  },
                  docEntries: {
                    initialMinimumBalance: null,
                    cliffTime: null,
                    cliffAmount: null,
                    vestingPeriod: null,
                    vestingIncrement: null
                  }
                }
              },
              votingFor: {
                type: "option",
                optionType: "flaggedOption",
                inner: { type: "Field" }
              }
            },
            docEntries: {
              appState: null,
              delegate: null,
              verificationKey: null,
              permissions: null,
              zkappUri: null,
              tokenSymbol: null,
              timing: null,
              votingFor: null
            }
          },
          balanceChange: {
            type: "object",
            name: "BalanceChange",
            docs: null,
            keys: ["magnitude", "sgn"],
            entries: { magnitude: { type: "UInt64" }, sgn: { type: "Sign" } },
            docEntries: { magnitude: null, sgn: null }
          },
          incrementNonce: { type: "Bool" },
          events: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Events"
          },
          sequenceEvents: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "SequenceEvents"
          },
          callData: { type: "Field" },
          callDepth: { type: "number" },
          preconditions: {
            type: "object",
            name: "Preconditions",
            docs: null,
            keys: ["network", "account"],
            entries: {
              network: {
                type: "object",
                name: "NetworkPrecondition",
                docs: null,
                keys: [
                  "snarkedLedgerHash",
                  "timestamp",
                  "blockchainLength",
                  "minWindowDensity",
                  "totalCurrency",
                  "globalSlotSinceHardFork",
                  "globalSlotSinceGenesis",
                  "stakingEpochData",
                  "nextEpochData"
                ],
                entries: {
                  snarkedLedgerHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  timestamp: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "BlockTimeInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  blockchainLength: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  minWindowDensity: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  totalCurrency: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "CurrencyAmountInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  globalSlotSinceHardFork: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "GlobalSlotInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  globalSlotSinceGenesis: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "GlobalSlotInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  stakingEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  },
                  nextEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  }
                },
                docEntries: {
                  snarkedLedgerHash: null,
                  timestamp: null,
                  blockchainLength: null,
                  minWindowDensity: null,
                  totalCurrency: null,
                  globalSlotSinceHardFork: null,
                  globalSlotSinceGenesis: null,
                  stakingEpochData: null,
                  nextEpochData: null
                }
              },
              account: {
                type: "object",
                name: "AccountPrecondition",
                docs: null,
                keys: [
                  "balance",
                  "nonce",
                  "receiptChainHash",
                  "delegate",
                  "state",
                  "sequenceState",
                  "provedState",
                  "isNew"
                ],
                entries: {
                  balance: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "BalanceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  nonce: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "NonceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  receiptChainHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  delegate: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "PublicKey" }
                  },
                  state: {
                    type: "array",
                    inner: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "Field" }
                    },
                    staticLength: 8
                  },
                  sequenceState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: {
                      type: "Field",
                      checkedType: { type: "Field" },
                      checkedTypeName: "SequenceState"
                    }
                  },
                  provedState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  },
                  isNew: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  }
                },
                docEntries: {
                  balance: null,
                  nonce: null,
                  receiptChainHash: null,
                  delegate: null,
                  state: null,
                  sequenceState: null,
                  provedState: null,
                  isNew: null
                }
              }
            },
            docEntries: { network: null, account: null }
          },
          useFullCommitment: { type: "Bool" },
          caller: { type: "TokenId" },
          authorizationKind: { type: "AuthorizationKind" }
        },
        docEntries: {
          publicKey: null,
          tokenId: null,
          update: null,
          balanceChange: null,
          incrementNonce: null,
          events: null,
          sequenceEvents: null,
          callData: null,
          callDepth: null,
          preconditions: null,
          useFullCommitment: null,
          caller: null,
          authorizationKind: null
        }
      },
      authorization: {
        type: "object",
        name: "Control",
        docs: null,
        keys: ["proof", "signature"],
        entries: {
          proof: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          },
          signature: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          }
        },
        docEntries: { proof: null, signature: null }
      }
    },
    docEntries: { body: null, authorization: null }
  }
};

// dist/node/provable/gen/transaction.js
var TypeMap = {
  PublicKey,
  UInt64,
  UInt32,
  TokenId,
  Field,
  Bool,
  AuthRequired,
  Sign,
  AuthorizationKind
};
var customTypes = {
  StringWithHash,
  TokenSymbol: TokenSymbol2,
  Events,
  SequenceEvents,
  SequenceState
};
var { provableFromLayout, toJSONEssential } = ProvableFromLayout(TypeMap, customTypes);
var ZkappCommand = provableFromLayout(jsLayout.ZkappCommand);
var AccountUpdate = provableFromLayout(jsLayout.AccountUpdate);

// dist/node/lib/mina.js
var mina_exports = {};
__export(mina_exports, {
  BerkeleyQANet: () => BerkeleyQANet,
  LocalBlockchain: () => LocalBlockchain,
  Network: () => Network2,
  accountCreationFee: () => accountCreationFee,
  createTransaction: () => createTransaction,
  currentSlot: () => currentSlot,
  currentTransaction: () => currentTransaction,
  fetchEvents: () => fetchEvents,
  getAccount: () => getAccount,
  getActions: () => getActions,
  getBalance: () => getBalance,
  getNetworkState: () => getNetworkState,
  hasAccount: () => hasAccount,
  sendTransaction: () => sendTransaction,
  setActiveInstance: () => setActiveInstance,
  transaction: () => transaction
});

// dist/node/lib/precondition.js
function preconditions(accountUpdate, isSelf) {
  initializePreconditions(accountUpdate, isSelf);
  return { account: Account(accountUpdate), network: Network(accountUpdate) };
}
function Network(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.network;
  let context = getPreconditionContextExn(accountUpdate);
  return preconditionClass(layout, "network", accountUpdate, context);
}
function Account(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.account;
  let context = getPreconditionContextExn(accountUpdate);
  return preconditionClass(layout, "account", accountUpdate, context);
}
var unimplementedPreconditions = [
  "network.stakingEpochData.seed",
  "network.nextEpochData.seed",
  "account.provedState"
];
var baseMap = { UInt64, UInt32, Field, Bool, PublicKey };
function preconditionClass(layout, baseKey, accountUpdate, context) {
  if (layout.type === "option") {
    if (layout.optionType === "closedInterval") {
      let lower = layout.inner.entries.lower.type;
      let baseType = baseMap[lower];
      return {
        ...preconditionSubclass(accountUpdate, baseKey, baseType, context),
        assertBetween(lower2, upper) {
          context.constrained.add(baseKey);
          let property = getPath(accountUpdate.body.preconditions, baseKey);
          property.isSome = Bool(true);
          property.value.lower = lower2;
          property.value.upper = upper;
        }
      };
    } else if (layout.optionType === "flaggedOption") {
      let baseType = baseMap[layout.inner.type];
      return preconditionSubclass(accountUpdate, baseKey, baseType, context);
    }
  } else if (layout.type === "array") {
    return {};
  } else if (layout.type === "object") {
    return Object.fromEntries(layout.keys.map((key) => {
      let value = layout.entries[key];
      return [
        key,
        preconditionClass(value, `${baseKey}.${key}`, accountUpdate, context)
      ];
    }));
  } else
    throw Error("bug");
}
function preconditionSubclass(accountUpdate, longKey, fieldType, context) {
  if (fieldType === void 0) {
    throw Error(`this.${longKey}: fieldType undefined`);
  }
  return {
    get() {
      if (unimplementedPreconditions.includes(longKey)) {
        let self = context.isSelf ? "this" : "accountUpdate";
        throw Error(`${self}.${longKey}.get() is not implemented yet.`);
      }
      let { read, vars } = context;
      read.add(longKey);
      return vars[longKey] ?? (vars[longKey] = getVariable(accountUpdate, longKey, fieldType));
    },
    assertEquals(value) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      if ("isSome" in property) {
        property.isSome = Bool(true);
        if ("lower" in property.value && "upper" in property.value) {
          property.value.lower = value;
          property.value.upper = value;
        } else {
          property.value = value;
        }
      } else {
        setPath(accountUpdate.body.preconditions, longKey, value);
      }
    },
    assertNothing() {
      context.constrained.add(longKey);
    }
  };
}
function getVariable(accountUpdate, longKey, fieldType) {
  return Circuit.witness(fieldType, () => {
    let [accountOrNetwork, ...rest] = longKey.split(".");
    let key = rest.join(".");
    let value;
    if (accountOrNetwork === "account") {
      let account = getAccountPreconditions(accountUpdate.body);
      value = account[key];
    } else if (accountOrNetwork === "network") {
      let networkState = getNetworkState();
      value = getPath(networkState, key);
    } else {
      throw Error("impossible");
    }
    return value;
  });
}
function getAccountPreconditions(body) {
  let { publicKey, tokenId } = body;
  let hasAccount2 = hasAccount(publicKey, tokenId);
  if (!hasAccount2) {
    return {
      balance: UInt64.zero,
      nonce: UInt32.zero,
      receiptChainHash: emptyReceiptChainHash(),
      sequenceState: SequenceEvents.emptySequenceState(),
      delegate: publicKey,
      provedState: Bool(false),
      isNew: Bool(true)
    };
  }
  let account = getAccount(publicKey, tokenId);
  return {
    balance: account.balance,
    nonce: account.nonce,
    receiptChainHash: account.receiptChainHash,
    sequenceState: account.sequenceState ?? SequenceEvents.emptySequenceState(),
    delegate: account.delegate ?? account.publicKey,
    provedState: account.provedState,
    isNew: Bool(false)
  };
}
function initializePreconditions(accountUpdate, isSelf) {
  preconditionContexts.set(accountUpdate, {
    read: new Set(),
    constrained: new Set(),
    vars: {},
    isSelf
  });
}
function cleanPreconditionsCache(accountUpdate) {
  let context = preconditionContexts.get(accountUpdate);
  if (context !== void 0)
    context.vars = {};
}
function assertPreconditionInvariants(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  let self = context.isSelf ? "this" : "accountUpdate";
  let dummyPreconditions = Preconditions.ignoreAll();
  for (let preconditionPath of context.read) {
    if (context.constrained.has(preconditionPath))
      continue;
    let precondition = getPath(accountUpdate.body.preconditions, preconditionPath);
    let dummy = getPath(dummyPreconditions, preconditionPath);
    if (!circuitValueEquals(precondition, dummy))
      continue;
    let hasAssertBetween = isRangeCondition(precondition);
    let shortPath = preconditionPath.split(".").pop();
    let errorMessage = `You used \`${self}.${preconditionPath}.get()\` without adding a precondition that links it to the actual ${shortPath}.
Consider adding this line to your code:
${self}.${preconditionPath}.assertEquals(${self}.${preconditionPath}.get());${hasAssertBetween ? `
You can also add more flexible preconditions with \`${self}.${preconditionPath}.assertBetween(...)\`.` : ""}`;
    throw Error(errorMessage);
  }
}
function getPreconditionContextExn(accountUpdate) {
  let c = preconditionContexts.get(accountUpdate);
  if (c === void 0)
    throw Error("bug: precondition context not found");
  return c;
}
var preconditionContexts = new WeakMap();
function isRangeCondition(condition) {
  return "isSome" in condition && "lower" in condition.value;
}
function getPath(obj, path) {
  let pathArray = path.split(".").reverse();
  while (pathArray.length > 0) {
    let key = pathArray.pop();
    obj = obj[key];
  }
  return obj;
}
function setPath(obj, path, value) {
  let pathArray = path.split(".");
  let key = pathArray.pop();
  getPath(obj, pathArray.join("."))[key] = value;
}

// dist/node/lib/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  Bijective: () => Bijective,
  EpochSeed: () => EpochSeed,
  LedgerHash: () => LedgerHash,
  ReceiptChainHash: () => ReceiptChainHash,
  StateHash: () => StateHash,
  TokenId: () => TokenId2,
  bytesFromFields: () => bytesFromFields,
  bytesToFields: () => bytesToFields,
  stringFromFields: () => stringFromFields,
  stringToFields: () => stringToFields
});
var { TokenId: TokenId2, ReceiptChainHash, EpochSeed, LedgerHash, StateHash } = fieldEncodings(Field);
function stringToFields(message) {
  let bytes = new TextEncoder().encode(message);
  return bytesToFields(bytes);
}
function stringFromFields(fields) {
  let bytes = bytesFromFields(fields);
  return new TextDecoder().decode(bytes);
}
var STOP = 1;
function bytesToFields(bytes) {
  let fields = [];
  let currentBigInt = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    currentBigInt += BigInt(byte) << bitPosition;
    bitPosition += 8n;
    if (bitPosition === 248n) {
      fields.push(Field(currentBigInt.toString()));
      currentBigInt = 0n;
      bitPosition = 0n;
    }
  }
  currentBigInt += BigInt(STOP) << bitPosition;
  fields.push(Field(currentBigInt.toString()));
  return fields;
}
function bytesFromFields(fields) {
  let lastChunk = fields.pop();
  if (lastChunk === void 0)
    return new Uint8Array();
  let lastChunkBytes = bytesOfConstantField(lastChunk);
  let i2 = lastChunkBytes.lastIndexOf(STOP, 30);
  if (i2 === -1)
    throw Error("Error (bytesFromFields): Invalid encoding.");
  let bytes = new Uint8Array(fields.length * 31 + i2);
  bytes.set(lastChunkBytes.subarray(0, i2), fields.length * 31);
  i2 = 0;
  for (let field of fields) {
    bytes.set(bytesOfConstantField(field).subarray(0, 31), i2);
    i2 += 31;
  }
  fields.push(lastChunk);
  return bytes;
}
var p = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var bytesPerBigInt = 32;
var bytesBase = 256n ** BigInt(bytesPerBigInt);
var Bijective = {
  Fp: {
    toBytes: (fields) => toBytesBijective(fields, p),
    fromBytes: (bytes) => toFieldsBijective(bytes, p),
    toString(fields) {
      return new TextDecoder().decode(toBytesBijective(fields, p));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, p);
    }
  },
  Fq: {
    toBytes: (fields) => toBytesBijective(fields, q),
    fromBytes: (bytes) => toFieldsBijective(bytes, q),
    toString(fields) {
      return new TextDecoder().decode(toBytesBijective(fields, q));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, q);
    }
  }
};
function toBytesBijective(fields, p2) {
  let fieldsBigInts = fields.map(fieldToBigInt);
  let bytesBig = changeBase(fieldsBigInts, p2, bytesBase);
  let bytes = bigIntArrayToBytes(bytesBig, bytesPerBigInt);
  return bytes;
}
function toFieldsBijective(bytes, p2) {
  let bytesBig = bytesToBigIntArray(bytes, bytesPerBigInt);
  let fieldsBigInts = changeBase(bytesBig, bytesBase, p2);
  let fields = fieldsBigInts.map(bigIntToField);
  return fields;
}
function changeBase(digits, base, newBase) {
  let x = fromBase(digits, base);
  let newDigits = toBase(x, newBase);
  return newDigits;
}
function fromBase(digits, base) {
  let basePowers = [];
  for (let power = base, n = 1; n < digits.length; power **= 2n, n *= 2) {
    basePowers.push(power);
  }
  let k = basePowers.length;
  digits = digits.concat(Array(2 ** k - digits.length).fill(0n));
  for (let i2 = 0; i2 < k; i2++) {
    let newDigits = Array(digits.length >> 1);
    let basePower = basePowers[i2];
    for (let j = 0; j < newDigits.length; j++) {
      newDigits[j] = digits[2 * j] + basePower * digits[2 * j + 1];
    }
    digits = newDigits;
  }
  console.assert(digits.length === 1);
  let [digit] = digits;
  return digit;
}
function toBase(x, base) {
  let basePowers = [];
  for (let power = base; power < x; power **= 2n) {
    basePowers.push(power);
  }
  let digits = [x];
  let k = basePowers.length;
  for (let i2 = 0; i2 < k; i2++) {
    let newDigits = Array(2 * digits.length);
    let basePower = basePowers[k - 1 - i2];
    for (let j = 0; j < digits.length; j++) {
      let x2 = digits[j];
      let high = x2 / basePower;
      newDigits[2 * j + 1] = high;
      newDigits[2 * j] = x2 - high * basePower;
    }
    digits = newDigits;
  }
  while (digits[digits.length - 1] === 0n) {
    digits.pop();
  }
  return digits;
}
function bytesOfConstantField(field) {
  let value = field.value;
  if (value[0] !== 0)
    throw Error("Field is not constant");
  return value[1];
}
function fieldToBigInt(field) {
  let bytes = bytesOfConstantField(field);
  return bytesToBigInt(bytes);
}
function bigIntToField(x) {
  let field = Field(1);
  field.value = [0, bigIntToBytes(x, 32)];
  return field;
}
function bytesToBigInt(bytes) {
  let x = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    x += BigInt(byte) << bitPosition;
    bitPosition += 8n;
  }
  return x;
}
function bigIntToBytes(x, length) {
  let bytes = [];
  for (; x > 0; x >>= 8n) {
    bytes.push(Number(x & 0xffn));
  }
  let array = new Uint8Array(bytes);
  if (length === void 0)
    return array;
  if (array.length > length)
    throw Error(`bigint doesn't fit into ${length} bytes.`);
  let sizedArray = new Uint8Array(length);
  sizedArray.set(array);
  return sizedArray;
}
function bytesToBigIntArray(bytes, bytesPerBigInt2) {
  let bigints = [];
  for (let i2 = 0; i2 < bytes.byteLength; i2 += bytesPerBigInt2) {
    bigints.push(bytesToBigInt(bytes.subarray(i2, i2 + bytesPerBigInt2)));
  }
  return bigints;
}
function bigIntArrayToBytes(bigints, bytesPerBigInt2) {
  let bytes = new Uint8Array(bigints.length * bytesPerBigInt2);
  let offset = 0;
  for (let b of bigints) {
    bytes.set(bigIntToBytes(b, bytesPerBigInt2), offset);
    offset += bytesPerBigInt2;
  }
  let i2 = bytes.byteLength - 1;
  for (; i2 >= 0; i2--) {
    if (bytes[i2] !== 0)
      break;
  }
  return bytes.slice(0, i2 + 1);
}

// dist/node/lib/account_update.js
var ZkappStateLength = 8;
var smartContractContext = Context.create();
var zkAppProver = Prover();
function keep(dummy) {
  return { isSome: Bool(false), value: dummy };
}
var True = () => Bool(true);
var False = () => Bool(false);
var Permission = {
  impossible: () => ({
    constant: True(),
    signatureNecessary: True(),
    signatureSufficient: False()
  }),
  none: () => ({
    constant: True(),
    signatureNecessary: False(),
    signatureSufficient: True()
  }),
  proof: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: False()
  }),
  signature: () => ({
    constant: False(),
    signatureNecessary: True(),
    signatureSufficient: True()
  }),
  proofOrSignature: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: True()
  })
};
var Permissions = {
  ...Permission,
  default: () => ({
    editState: Permission.proof(),
    send: Permission.signature(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.signature(),
    setZkappUri: Permission.signature(),
    editSequenceState: Permission.proof(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature()
  }),
  initial: () => ({
    editState: Permission.signature(),
    send: Permission.signature(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.signature(),
    setZkappUri: Permission.signature(),
    editSequenceState: Permission.signature(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature()
  }),
  dummy: () => ({
    editState: Permission.none(),
    send: Permission.none(),
    receive: Permission.none(),
    setDelegate: Permission.none(),
    setPermissions: Permission.none(),
    setVerificationKey: Permission.none(),
    setZkappUri: Permission.none(),
    editSequenceState: Permission.none(),
    setTokenSymbol: Permission.none(),
    incrementNonce: Permission.none(),
    setVotingFor: Permission.none()
  }),
  fromString: (permission) => {
    switch (permission) {
      case "None":
        return Permission.none();
      case "Either":
        return Permission.proofOrSignature();
      case "Proof":
        return Permission.proof();
      case "Signature":
        return Permission.signature();
      case "Impossible":
        return Permission.impossible();
      default:
        throw Error(`Cannot parse invalid permission. ${permission} does not exist.`);
    }
  },
  fromJSON: (permissions) => {
    return Object.fromEntries(Object.entries(permissions).map(([k, v]) => [
      k,
      Permissions.fromString(v)
    ]));
  }
};
var Body = {
  noUpdate() {
    return {
      appState: Array(ZkappStateLength).fill(0).map(() => keep(Field(0))),
      delegate: keep(PublicKey.empty()),
      verificationKey: keep({ data: "", hash: Field(0) }),
      permissions: keep(Permissions.initial()),
      zkappUri: keep({
        data: "",
        hash: Field("22930868938364086394602058221028773520482901241511717002947639863679740444066")
      }),
      tokenSymbol: keep(TokenSymbol.empty),
      timing: keep({
        cliffAmount: UInt64.zero,
        cliffTime: UInt32.zero,
        initialMinimumBalance: UInt64.zero,
        vestingIncrement: UInt64.zero,
        vestingPeriod: UInt32.zero
      }),
      votingFor: keep(Field(0))
    };
  },
  keepAll(publicKey) {
    return {
      publicKey,
      update: Body.noUpdate(),
      tokenId: TokenId3.default,
      balanceChange: Int64.zero,
      events: Events.empty(),
      sequenceEvents: SequenceEvents.empty(),
      caller: TokenId3.default,
      callData: Field(0),
      callDepth: 0,
      preconditions: Preconditions.ignoreAll(),
      useFullCommitment: Bool(false),
      incrementNonce: Bool(false),
      authorizationKind: { isSigned: Bool(false), isProved: Bool(false) }
    };
  },
  dummy() {
    return Body.keepAll(PublicKey.empty());
  }
};
var FeePayerBody = {
  keepAll(publicKey, nonce) {
    return {
      publicKey,
      nonce,
      fee: UInt64.zero,
      validUntil: void 0
    };
  }
};
var NetworkPrecondition = {
  ignoreAll() {
    let stakingEpochData = {
      ledger: { hash: ignore(Field(0)), totalCurrency: ignore(uint64()) },
      seed: ignore(Field(0)),
      startCheckpoint: ignore(Field(0)),
      lockCheckpoint: ignore(Field(0)),
      epochLength: ignore(uint32())
    };
    let nextEpochData = cloneCircuitValue(stakingEpochData);
    return {
      snarkedLedgerHash: ignore(Field(0)),
      timestamp: ignore(uint64()),
      blockchainLength: ignore(uint32()),
      minWindowDensity: ignore(uint32()),
      totalCurrency: ignore(uint64()),
      globalSlotSinceHardFork: ignore(uint32()),
      globalSlotSinceGenesis: ignore(uint32()),
      stakingEpochData,
      nextEpochData
    };
  }
};
function ignore(dummy) {
  return { isSome: Bool(false), value: dummy };
}
var uint32 = () => ({ lower: UInt32.from(0), upper: UInt32.MAXINT() });
var uint64 = () => ({ lower: UInt64.from(0), upper: UInt64.MAXINT() });
var AccountPrecondition = {
  ignoreAll() {
    let appState = [];
    for (let i2 = 0; i2 < ZkappStateLength; ++i2) {
      appState.push(ignore(Field(0)));
    }
    return {
      balance: ignore(uint64()),
      nonce: ignore(uint32()),
      receiptChainHash: ignore(Field(0)),
      delegate: ignore(PublicKey.empty()),
      state: appState,
      sequenceState: ignore(SequenceEvents.emptySequenceState()),
      provedState: ignore(Bool(false)),
      isNew: ignore(Bool(false))
    };
  },
  nonce(nonce) {
    let p2 = AccountPrecondition.ignoreAll();
    AccountUpdate2.assertEquals(p2.nonce, nonce);
    return p2;
  }
};
var Preconditions = {
  ignoreAll() {
    return {
      account: AccountPrecondition.ignoreAll(),
      network: NetworkPrecondition.ignoreAll()
    };
  }
};
var TokenId3 = {
  ...transaction_exports.TokenId,
  ...TokenId2,
  get default() {
    return Field(1);
  }
};
var Token = class {
  constructor({ tokenOwner, parentTokenId = TokenId3.default }) {
    this.parentTokenId = parentTokenId;
    this.tokenOwner = tokenOwner;
    try {
      this.id = Token.getId(tokenOwner, parentTokenId);
    } catch (e) {
      throw new Error(`Could not create a custom token id:
Error: ${e.message}`);
    }
  }
  static getId(tokenOwner, parentTokenId = TokenId3.default) {
    if (tokenOwner.isConstant() && parentTokenId.isConstant()) {
      return Ledger.customTokenId(tokenOwner, parentTokenId);
    } else {
      return Ledger.customTokenIdChecked(tokenOwner, parentTokenId);
    }
  }
};
Token.Id = TokenId3;
var AccountUpdate2 = class {
  constructor(body, authorization = {}, isSelf = false) {
    this.label = "";
    this.isDelegateCall = Bool(false);
    this.lazyAuthorization = void 0;
    this.children = {
      callsType: { type: "None" },
      accountUpdates: []
    };
    this.parent = void 0;
    this.id = Math.random();
    this.body = body;
    this.authorization = authorization;
    let { account, network } = preconditions(this, isSelf);
    this.account = account;
    this.network = network;
    this.isSelf = isSelf;
  }
  static clone(accountUpdate) {
    let body = cloneCircuitValue(accountUpdate.body);
    let authorization = cloneCircuitValue(accountUpdate.authorization);
    let cloned = new AccountUpdate2(body, authorization, accountUpdate.isSelf);
    cloned.lazyAuthorization = accountUpdate.lazyAuthorization;
    cloned.children.callsType = accountUpdate.children.callsType;
    cloned.children.accountUpdates = accountUpdate.children.accountUpdates.map(AccountUpdate2.clone);
    cloned.id = accountUpdate.id;
    cloned.label = accountUpdate.label;
    cloned.parent = accountUpdate.parent;
    cloned.isDelegateCall = accountUpdate.isDelegateCall;
    return cloned;
  }
  token() {
    let thisAccountUpdate = this;
    let customToken = new Token({
      tokenOwner: thisAccountUpdate.body.publicKey,
      parentTokenId: thisAccountUpdate.body.tokenId
    });
    return {
      id: customToken.id,
      parentTokenId: customToken.parentTokenId,
      tokenOwner: customToken.tokenOwner,
      mint({ address, amount }) {
        let receiver = AccountUpdate2.defaultAccountUpdate(address, this.id);
        thisAccountUpdate.approve(receiver);
        receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
        return receiver;
      },
      burn({ address, amount }) {
        let sender = AccountUpdate2.defaultAccountUpdate(address, this.id);
        thisAccountUpdate.approve(sender);
        sender.body.useFullCommitment = Bool(true);
        sender.body.balanceChange = Int64.fromObject(sender.body.balanceChange).sub(amount);
        Authorization.setLazySignature(sender);
      },
      send({ from, to, amount }) {
        let sender = AccountUpdate2.defaultAccountUpdate(from, this.id);
        thisAccountUpdate.approve(sender);
        sender.body.useFullCommitment = Bool(true);
        sender.body.balanceChange = Int64.fromObject(sender.body.balanceChange).sub(amount);
        Authorization.setLazySignature(sender);
        let receiverAccountUpdate = createChildAccountUpdate(thisAccountUpdate, to, this.id);
        let i1 = receiverAccountUpdate.body.balanceChange;
        receiverAccountUpdate.body.balanceChange = new Int64(i1.magnitude, i1.sgn).add(amount);
        return receiverAccountUpdate;
      }
    };
  }
  get tokenId() {
    return this.body.tokenId;
  }
  get tokenSymbol() {
    let accountUpdate = this;
    return {
      set(tokenSymbol) {
        AccountUpdate2.setValue(accountUpdate.update.tokenSymbol, TokenSymbol.from(tokenSymbol));
      }
    };
  }
  send({ to, amount }) {
    let receiver;
    if (to instanceof AccountUpdate2) {
      receiver = to;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else {
      receiver = AccountUpdate2.defaultAccountUpdate(to, this.body.tokenId);
    }
    this.approve(receiver);
    this.body.balanceChange = Int64.fromObject(this.body.balanceChange).sub(amount);
    receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
  }
  approve(childUpdate, layout = AccountUpdate2.Layout.NoDelegation) {
    makeChildAccountUpdate(this, childUpdate);
    this.isDelegateCall = Bool(false);
    AccountUpdate2.witnessChildren(childUpdate, layout, { skipCheck: true });
  }
  get balance() {
    let accountUpdate = this;
    return {
      addInPlace(x) {
        let { magnitude, sgn } = accountUpdate.body.balanceChange;
        accountUpdate.body.balanceChange = new Int64(magnitude, sgn).add(x);
      },
      subInPlace(x) {
        let { magnitude, sgn } = accountUpdate.body.balanceChange;
        accountUpdate.body.balanceChange = new Int64(magnitude, sgn).sub(x);
      }
    };
  }
  get update() {
    return this.body.update;
  }
  static setValue(maybeValue, value) {
    maybeValue.isSome = Bool(true);
    maybeValue.value = value;
  }
  static assertBetween(property, lower, upper) {
    property.isSome = Bool(true);
    property.value.lower = lower;
    property.value.upper = upper;
  }
  static assertEquals(property, value) {
    property.isSome = Bool(true);
    if ("lower" in property.value && "upper" in property.value) {
      property.value.lower = value;
      property.value.upper = value;
    } else {
      property.value = value;
    }
  }
  get publicKey() {
    return this.body.publicKey;
  }
  requireSignature() {
    let nonce = AccountUpdate2.getNonce(this);
    this.account.nonce.assertEquals(nonce);
    this.body.incrementNonce = Bool(true);
    Authorization.setLazySignature(this, {});
  }
  sign(privateKey) {
    let nonce = AccountUpdate2.getNonce(this);
    this.account.nonce.assertEquals(nonce);
    this.body.incrementNonce = Bool(true);
    Authorization.setLazySignature(this, { privateKey });
  }
  static signFeePayerInPlace(feePayer, privateKey) {
    feePayer.body.nonce = this.getNonce(feePayer);
    feePayer.authorization = Ledger.dummySignature();
    feePayer.lazyAuthorization = { kind: "lazy-signature", privateKey };
  }
  static getNonce(accountUpdate) {
    return memoizeWitness(UInt32, () => AccountUpdate2.getNonceUnchecked(accountUpdate));
  }
  static getNonceUnchecked(update) {
    let publicKey = update.body.publicKey;
    let tokenId = update instanceof AccountUpdate2 ? update.body.tokenId : TokenId3.default;
    let nonce = Number(getAccountPreconditions(update.body).nonce.toString());
    let isFeePayer = currentTransaction()?.sender?.equals(publicKey);
    let shouldIncreaseNonce = isFeePayer?.and(tokenId.equals(TokenId3.default));
    if (shouldIncreaseNonce?.toBoolean())
      nonce++;
    CallForest.forEachPredecessor(currentTransaction.get().accountUpdates, update, (otherUpdate) => {
      let shouldIncreaseNonce2 = otherUpdate.publicKey.equals(publicKey).and(otherUpdate.tokenId.equals(tokenId)).and(otherUpdate.body.incrementNonce);
      if (shouldIncreaseNonce2.toBoolean())
        nonce++;
    });
    return UInt32.from(nonce);
  }
  toJSON() {
    return transaction_exports.AccountUpdate.toJSON(this);
  }
  static toJSON(a) {
    return transaction_exports.AccountUpdate.toJSON(a);
  }
  static fromJSON(json) {
    let accountUpdate = transaction_exports.AccountUpdate.fromJSON(json);
    return new AccountUpdate2(accountUpdate.body, accountUpdate.authorization);
  }
  hash() {
    if (inCheckedComputation()) {
      let input = transaction_exports.AccountUpdate.toInput(this);
      return hashWithPrefix(prefixes.body, packToFields(input));
    } else {
      let json = transaction_exports.AccountUpdate.toJSON(this);
      return Ledger.hashAccountUpdateFromJson(JSON.stringify(json));
    }
  }
  toPublicInput() {
    let accountUpdate = this.hash();
    let calls = CallForest.hashChildren(this);
    return { accountUpdate, calls };
  }
  static defaultAccountUpdate(address, tokenId) {
    const body = Body.keepAll(address);
    if (tokenId) {
      body.tokenId = tokenId;
      body.caller = tokenId;
    }
    return new AccountUpdate2(body);
  }
  static dummy() {
    return this.defaultAccountUpdate(PublicKey.empty());
  }
  isDummy() {
    return this.body.publicKey.isEmpty();
  }
  static defaultFeePayer(address, key, nonce) {
    let body = FeePayerBody.keepAll(address, nonce);
    return {
      body,
      authorization: Ledger.dummySignature(),
      lazyAuthorization: { kind: "lazy-signature", privateKey: key }
    };
  }
  static dummyFeePayer() {
    let body = FeePayerBody.keepAll(PublicKey.empty(), UInt32.zero);
    return { body, authorization: Ledger.dummySignature() };
  }
  static create(publicKey, tokenId) {
    let accountUpdate = AccountUpdate2.defaultAccountUpdate(publicKey, tokenId);
    if (smartContractContext.has()) {
      smartContractContext.get().this.self.approve(accountUpdate);
    } else {
      currentTransaction()?.accountUpdates.push(accountUpdate);
    }
    return accountUpdate;
  }
  static attachToTransaction(accountUpdate) {
    if (smartContractContext.has()) {
      let selfUpdate = smartContractContext.get().this.self;
      if (selfUpdate === accountUpdate)
        return;
      smartContractContext.get().this.self.approve(accountUpdate);
    } else {
      if (!currentTransaction.has())
        return;
      let updates = currentTransaction.get().accountUpdates;
      if (!updates.find((update) => update.id === accountUpdate.id)) {
        updates.push(accountUpdate);
      }
    }
  }
  static createSigned(signer) {
    let publicKey = signer.toPublicKey();
    if (!currentTransaction.has()) {
      throw new Error("AccountUpdate.createSigned: Cannot run outside of a transaction");
    }
    let accountUpdate = AccountUpdate2.defaultAccountUpdate(publicKey);
    let nonce = Circuit.witness(UInt32, () => AccountUpdate2.getNonceUnchecked(accountUpdate));
    accountUpdate.account.nonce.assertEquals(nonce);
    accountUpdate.body.incrementNonce = Bool(true);
    Authorization.setLazySignature(accountUpdate, { privateKey: signer });
    currentTransaction.get().accountUpdates.push(accountUpdate);
    return accountUpdate;
  }
  static fundNewAccount(feePayerKey, { initialBalance = UInt64.zero } = {}) {
    let accountUpdate = AccountUpdate2.createSigned(feePayerKey);
    let amount = initialBalance instanceof UInt64 ? initialBalance : UInt64.from(`${initialBalance}`);
    accountUpdate.balance.subInPlace(amount.add(accountCreationFee()));
  }
  toProvable() {
    return { accountUpdate: this, isDelegateCall: this.isDelegateCall };
  }
  static toFields(a) {
    return AccountUpdate2.provable.toFields(a.toProvable());
  }
  static toAuxiliary(a) {
    let aux = AccountUpdate2.provable.toAuxiliary(a?.toProvable());
    let children = {
      callsType: { type: "None" },
      accountUpdates: []
    };
    let lazyAuthorization = a && a.lazyAuthorization;
    if (a) {
      children.callsType = a.children.callsType;
      children.accountUpdates = a.children.accountUpdates.map(AccountUpdate2.clone);
    }
    let parent = a?.parent;
    let id = a?.id ?? Math.random();
    let label = a?.label ?? "";
    return [{ lazyAuthorization, children, parent, id, label }, aux];
  }
  static toInput(a) {
    return AccountUpdate2.provable.toInput(a.toProvable());
  }
  static check(a) {
    AccountUpdate2.provable.check(a.toProvable());
  }
  static fromFields(fields, [other, aux]) {
    let { accountUpdate, isDelegateCall } = AccountUpdate2.provable.fromFields(fields, aux);
    return Object.assign(new AccountUpdate2(accountUpdate.body, accountUpdate.authorization), { isDelegateCall }, other);
  }
  static witness(type, compute, { skipCheck = false } = {}) {
    let accountUpdateType = skipCheck ? { ...provable(AccountUpdate2), check() {
    } } : AccountUpdate2;
    let combinedType = provable({
      accountUpdate: accountUpdateType,
      result: type
    });
    return Circuit.witness(combinedType, compute);
  }
  static witnessChildren(accountUpdate, childLayout, options) {
    if (childLayout === AccountUpdate2.Layout.AnyChildren) {
      accountUpdate.children.callsType = { type: "Witness" };
      return;
    }
    if (childLayout === AccountUpdate2.Layout.NoDelegation) {
      accountUpdate.children.callsType = { type: "Witness" };
      accountUpdate.isDelegateCall.assertFalse();
      return;
    }
    let childArray = typeof childLayout === "number" ? Array(childLayout).fill(AccountUpdate2.Layout.NoChildren) : childLayout;
    let n = childArray.length;
    for (let i2 = 0; i2 < n; i2++) {
      accountUpdate.children.accountUpdates[i2] = AccountUpdate2.witnessTree(provable(null), childArray[i2], () => ({
        accountUpdate: accountUpdate.children.accountUpdates[i2] ?? AccountUpdate2.dummy(),
        result: null
      }), options).accountUpdate;
    }
    if (n === 0) {
      accountUpdate.children.callsType = {
        type: "Equals",
        value: CallForest.emptyHash()
      };
    }
  }
  static witnessTree(resultType, childLayout, compute, options) {
    let { accountUpdate, result } = AccountUpdate2.witness(resultType, compute, options);
    AccountUpdate2.witnessChildren(accountUpdate, childLayout, options);
    return { accountUpdate, result };
  }
  toPretty() {
    function short(s) {
      return ".." + s.slice(-4);
    }
    let jsonUpdate = toJSONEssential(jsLayout.AccountUpdate, this);
    let body = jsonUpdate.body;
    delete body.callData;
    body.publicKey = short(body.publicKey);
    if (body.balanceChange?.magnitude === "0")
      delete body.balanceChange;
    if (body.tokenId === TokenId3.toBase58(TokenId3.default)) {
      delete body.tokenId;
    } else {
      body.tokenId = short(body.tokenId);
    }
    if (body.caller === TokenId3.toBase58(TokenId3.default)) {
      delete body.caller;
    } else {
      body.caller = short(body.caller);
    }
    if (body.incrementNonce === false)
      delete body.incrementNonce;
    if (body.useFullCommitment === false)
      delete body.useFullCommitment;
    if (body.events?.length === 0)
      delete body.events;
    if (body.sequenceEvents?.length === 0)
      delete body.sequenceEvents;
    if (body.preconditions?.account) {
      body.preconditions.account = JSON.stringify(body.preconditions.account);
    }
    if (body.preconditions?.network) {
      body.preconditions.network = JSON.stringify(body.preconditions.network);
    }
    if (jsonUpdate.authorization?.proof) {
      jsonUpdate.authorization.proof = short(jsonUpdate.authorization.proof);
    }
    if (jsonUpdate.authorization?.signature) {
      jsonUpdate.authorization.signature = short(jsonUpdate.authorization.signature);
    }
    if (body.update?.verificationKey) {
      body.update.verificationKey = JSON.stringify({
        data: short(body.update.verificationKey.data),
        hash: short(body.update.verificationKey.hash)
      });
    }
    for (let key of ["permissions", "appState", "timing"]) {
      if (body.update?.[key]) {
        body.update[key] = JSON.stringify(body.update[key]);
      }
    }
    for (let key of ["events", "sequenceEvents"]) {
      if (body[key]) {
        body[key] = JSON.stringify(body[key]);
      }
    }
    if (jsonUpdate.authorization !== void 0 || body.authorizationKind !== "None_given") {
      body.authorization = jsonUpdate.authorization;
    }
    if (this.isDelegateCall.toBoolean())
      body.isDelegateCall = true;
    let pretty = { ...body };
    let withId = false;
    if (withId)
      pretty = { id: Math.floor(this.id * 1e3), ...pretty };
    if (this.label)
      pretty = { label: this.label, ...pretty };
    return pretty;
  }
};
AccountUpdate2.SequenceEvents = SequenceEvents;
AccountUpdate2.provable = provable({
  accountUpdate: transaction_exports.AccountUpdate,
  isDelegateCall: Bool
});
AccountUpdate2.sizeInFields = AccountUpdate2.provable.sizeInFields;
AccountUpdate2.Layout = {
  StaticChildren: (...args) => {
    if (args.length === 1 && typeof args[0] === "number")
      return args[0];
    if (args.length === 0)
      return 0;
    return args;
  },
  NoChildren: 0,
  AnyChildren: "AnyChildren",
  NoDelegation: "NoDelegation"
};
var CallForest = {
  toFlatList(forest, depth = 0) {
    let accountUpdates = [];
    for (let accountUpdate of forest) {
      if (accountUpdate.isDummy().toBoolean())
        continue;
      accountUpdate.body.callDepth = depth;
      let children = accountUpdate.children.accountUpdates;
      accountUpdates.push(accountUpdate, ...CallForest.toFlatList(children, depth + 1));
    }
    return accountUpdates;
  },
  emptyHash() {
    return Field(0);
  },
  hashChildren(update) {
    let { callsType } = update.children;
    if (callsType.type === "Witness") {
      return Circuit.witness(Field, () => CallForest.hashChildrenBase(update));
    }
    let calls = CallForest.hashChildrenBase(update);
    if (callsType.type === "Equals" && inCheckedComputation()) {
      calls.assertEquals(callsType.value);
    }
    return calls;
  },
  hashChildrenBase({ children }) {
    let stackHash = CallForest.emptyHash();
    for (let accountUpdate of [...children.accountUpdates].reverse()) {
      let calls = CallForest.hashChildren(accountUpdate);
      let nodeHash = hashWithPrefix(prefixes.accountUpdateNode, [
        accountUpdate.hash(),
        calls
      ]);
      let newHash = hashWithPrefix(prefixes.accountUpdateCons, [
        nodeHash,
        stackHash
      ]);
      stackHash = Circuit.if(accountUpdate.isDummy(), stackHash, newHash);
    }
    return stackHash;
  },
  addCallers(updates, context = {
    self: TokenId3.default,
    caller: TokenId3.default
  }) {
    for (let update of updates) {
      let { isDelegateCall } = update;
      let caller = Circuit.if(isDelegateCall, context.caller, context.self);
      let self = Circuit.if(isDelegateCall, context.self, Token.getId(update.body.publicKey, update.body.tokenId));
      update.body.caller = caller;
      let childContext = { caller, self };
      CallForest.addCallers(update.children.accountUpdates, childContext);
    }
  },
  computeCallerContext(update) {
    let current = update;
    let ancestors = [];
    while (true) {
      let parent = current.parent;
      if (parent === void 0)
        break;
      ancestors.unshift(parent);
      current = parent;
    }
    let context = { self: TokenId3.default, caller: TokenId3.default };
    for (let update2 of ancestors) {
      if (!update2.isDelegateCall.toBoolean()) {
        context.caller = context.self;
        context.self = Token.getId(update2.body.publicKey, update2.body.tokenId);
      }
    }
    return context;
  },
  callerContextType: provablePure({ self: Field, caller: Field }),
  computeCallDepth(update) {
    for (let callDepth = 0; ; callDepth++) {
      if (update.parent === void 0)
        return callDepth;
      update = update.parent;
    }
  },
  forEach(updates, callback) {
    for (let update of updates) {
      callback(update);
      CallForest.forEach(update.children.accountUpdates, callback);
    }
  },
  forEachPredecessor(updates, update, callback) {
    let isPredecessor = true;
    CallForest.forEach(updates, (otherUpdate) => {
      if (otherUpdate.id === update.id)
        isPredecessor = false;
      if (isPredecessor)
        callback(otherUpdate);
    });
  }
};
function createChildAccountUpdate(parent, childAddress, tokenId) {
  let child = AccountUpdate2.defaultAccountUpdate(childAddress, tokenId);
  makeChildAccountUpdate(parent, child);
  return child;
}
function makeChildAccountUpdate(parent, child) {
  child.body.callDepth = parent.body.callDepth + 1;
  let wasChildAlready = parent.children.accountUpdates.find((update) => update.id === child.id);
  if (!wasChildAlready) {
    parent.children.accountUpdates.push(child);
  }
  if (child.parent === void 0) {
    let topLevelUpdates = currentTransaction()?.accountUpdates;
    let i2 = topLevelUpdates?.findIndex((update) => update.id === child.id);
    if (i2 !== void 0 && i2 !== -1) {
      topLevelUpdates.splice(i2, 1);
    }
  } else if (!wasChildAlready) {
    let siblings = child.parent.children.accountUpdates;
    let i2 = siblings?.findIndex((update) => update.id === child.id);
    if (i2 !== void 0 && i2 !== -1) {
      siblings.splice(i2, 1);
    }
  }
  child.parent = parent;
}
var ZkappCommand2 = {
  toPretty(transaction2) {
    let feePayer = zkappCommandToJson(transaction2).feePayer;
    feePayer.body.publicKey = ".." + feePayer.body.publicKey.slice(-4);
    feePayer.body.authorization = ".." + feePayer.authorization.slice(-4);
    if (feePayer.body.validUntil === null)
      delete feePayer.body.validUntil;
    return [
      feePayer.body,
      ...transaction2.accountUpdates.map((a) => a.toPretty())
    ];
  }
};
function zkappCommandToJson({ feePayer, accountUpdates, memo }) {
  memo = Ledger.memoToBase58(memo);
  return transaction_exports.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });
}
var Authorization = {
  hasLazyProof(accountUpdate) {
    return accountUpdate.lazyAuthorization?.kind === "lazy-proof";
  },
  hasAny(accountUpdate) {
    let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;
    return !!(lazyAuth || "proof" in auth || "signature" in auth);
  },
  setSignature(accountUpdate, signature) {
    accountUpdate.authorization = { signature };
    accountUpdate.lazyAuthorization = void 0;
  },
  setProof(accountUpdate, proof) {
    accountUpdate.authorization = { proof };
    accountUpdate.lazyAuthorization = void 0;
  },
  setLazySignature(accountUpdate, signature) {
    signature ?? (signature = {});
    accountUpdate.body.authorizationKind.isSigned = Bool(true);
    accountUpdate.body.authorizationKind.isProved = Bool(false);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...signature, kind: "lazy-signature" };
  },
  setLazyProof(accountUpdate, proof) {
    accountUpdate.body.authorizationKind.isSigned = Bool(false);
    accountUpdate.body.authorizationKind.isProved = Bool(true);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...proof, kind: "lazy-proof" };
  },
  setLazyNone(accountUpdate) {
    accountUpdate.body.authorizationKind.isSigned = Bool(false);
    accountUpdate.body.authorizationKind.isProved = Bool(false);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { kind: "lazy-none" };
  }
};
function addMissingSignatures(zkappCommand, additionalKeys = []) {
  let additionalPublicKeys = additionalKeys.map((sk) => sk.toPublicKey());
  let { commitment, fullCommitment } = Ledger.transactionCommitments(JSON.stringify(zkappCommandToJson(zkappCommand)));
  function addFeePayerSignature(accountUpdate) {
    let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);
    if (lazyAuthorization === void 0)
      return { body, authorization };
    let { privateKey } = lazyAuthorization;
    if (privateKey === void 0) {
      let i2 = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
      if (i2 === -1) {
        let pk = PublicKey.toBase58(accountUpdate.body.publicKey);
        throw Error(`addMissingSignatures: Cannot add signature for fee payer (${pk}), private key is missing.`);
      }
      privateKey = additionalKeys[i2];
    }
    let signature = Ledger.signFieldElement(fullCommitment, privateKey);
    return { body, authorization: signature };
  }
  function addSignature(accountUpdate) {
    accountUpdate = AccountUpdate2.clone(accountUpdate);
    if (accountUpdate.lazyAuthorization?.kind !== "lazy-signature") {
      return accountUpdate;
    }
    let { privateKey } = accountUpdate.lazyAuthorization;
    if (privateKey === void 0) {
      let i2 = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
      if (i2 === -1)
        throw Error(`addMissingSignatures: Cannot add signature for ${accountUpdate.publicKey.toBase58()}, private key is missing.`);
      privateKey = additionalKeys[i2];
    }
    let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean() ? fullCommitment : commitment;
    let signature = Ledger.signFieldElement(transactionCommitment, privateKey);
    Authorization.setSignature(accountUpdate, signature);
    return accountUpdate;
  }
  let { feePayer, accountUpdates, memo } = zkappCommand;
  return {
    feePayer: addFeePayerSignature(feePayer),
    accountUpdates: accountUpdates.map(addSignature),
    memo
  };
}
var ZkappPublicInput = provablePure({ accountUpdate: Field, calls: Field }, { customObjectKeys: ["accountUpdate", "calls"] });
async function addMissingProofs(zkappCommand, { proofsEnabled = true }) {
  async function addProof(index, accountUpdate) {
    accountUpdate = AccountUpdate2.clone(accountUpdate);
    if (accountUpdate.lazyAuthorization?.kind !== "lazy-proof") {
      return {
        accountUpdateProved: accountUpdate,
        proof: void 0
      };
    }
    if (!proofsEnabled) {
      Authorization.setProof(accountUpdate, Pickles.dummyBase64Proof());
      return {
        accountUpdateProved: accountUpdate,
        proof: void 0
      };
    }
    let { methodName, args, previousProofs, ZkappClass, memoized, blindingValue } = accountUpdate.lazyAuthorization;
    let publicInput = accountUpdate.toPublicInput();
    let publicInputFields = ZkappPublicInput.toFields(publicInput);
    if (ZkappClass._provers === void 0)
      throw Error(`Cannot prove execution of ${methodName}(), no prover found. Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
    let provers = ZkappClass._provers;
    let methodError2 = `Error when computing proofs: Method ${methodName} not found. Make sure your environment supports decorators, and annotate with \`@method ${methodName}\`.`;
    if (ZkappClass._methods === void 0)
      throw Error(methodError2);
    let i2 = ZkappClass._methods.findIndex((m) => m.methodName === methodName);
    if (i2 === -1)
      throw Error(methodError2);
    let [, [, proof]] = await zkAppProver.run([accountUpdate.publicKey, accountUpdate.tokenId, ...args], { transaction: zkappCommand, accountUpdate, index }, () => memoizationContext.runWithAsync({ memoized, currentIndex: 0, blindingValue }, async () => {
      try {
        return await provers[i2](publicInputFields, previousProofs);
      } catch (err) {
        console.error(`Error when proving ${ZkappClass.name}.${methodName}()`);
        throw err;
      }
    }));
    Authorization.setProof(accountUpdate, Pickles.proofToBase64Transaction(proof));
    let maxProofsVerified = ZkappClass._maxProofsVerified;
    const Proof2 = ZkappClass.Proof();
    return {
      accountUpdateProved: accountUpdate,
      proof: new Proof2({ publicInput, proof, maxProofsVerified })
    };
  }
  let { feePayer, accountUpdates, memo } = zkappCommand;
  let accountUpdatesProved = [];
  let proofs = [];
  for (let i2 = 0; i2 < accountUpdates.length; i2++) {
    let { accountUpdateProved, proof } = await addProof(i2, accountUpdates[i2]);
    accountUpdatesProved.push(accountUpdateProved);
    proofs.push(proof);
  }
  return {
    zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },
    proofs
  };
}
function signJsonTransaction(transactionJson, privateKey) {
  if (typeof privateKey === "string")
    privateKey = PrivateKey.fromBase58(privateKey);
  let publicKey = privateKey.toPublicKey().toBase58();
  let zkappCommand = JSON.parse(transactionJson);
  let feePayer = zkappCommand.feePayer;
  if (feePayer.body.publicKey === publicKey) {
    zkappCommand = JSON.parse(Ledger.signFeePayer(JSON.stringify(zkappCommand), privateKey));
  }
  for (let i2 = 0; i2 < zkappCommand.accountUpdates.length; i2++) {
    let accountUpdate = zkappCommand.accountUpdates[i2];
    if (accountUpdate.body.publicKey === publicKey && accountUpdate.authorization.proof === null) {
      zkappCommand = JSON.parse(Ledger.signAccountUpdate(JSON.stringify(zkappCommand), privateKey, i2));
    }
  }
  return JSON.stringify(zkappCommand);
}

// dist/node/lib/fetch.js
var import_isomorphic_fetch = __toModule(require("isomorphic-fetch"));
var defaultGraphqlEndpoint = "none";
function setGraphqlEndpoint(graphqlEndpoint) {
  defaultGraphqlEndpoint = graphqlEndpoint;
}
async function fetchAccount(accountInfo, graphqlEndpoint = defaultGraphqlEndpoint, { timeout = defaultTimeout } = {}) {
  let publicKeyBase58 = accountInfo.publicKey instanceof PublicKey ? accountInfo.publicKey.toBase58() : accountInfo.publicKey;
  let response = await fetchAccountInternal({ publicKey: publicKeyBase58, tokenId: accountInfo.tokenId }, graphqlEndpoint, {
    timeout
  });
  return response.error === void 0 ? {
    account: parseFetchedAccount(response.account),
    error: void 0
  } : { account: void 0, error: response.error };
}
async function fetchAccountInternal(accountInfo, graphqlEndpoint = defaultGraphqlEndpoint, config) {
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(accountQuery(publicKey, tokenId ?? TokenId3.toBase58(TokenId3.default)), graphqlEndpoint, config);
  if (error !== void 0)
    return { account: void 0, error };
  let account = response.data.account;
  if (account === null) {
    return {
      account: void 0,
      error: {
        statusCode: 404,
        statusText: `fetchAccount: Account with public key ${publicKey} does not exist.`
      }
    };
  }
  addCachedAccountInternal(account, graphqlEndpoint);
  return {
    account,
    error: void 0
  };
}
var defaultTimeout = 3e4;
var accountQuery = (publicKey, tokenId) => `{
  account(publicKey: "${publicKey}", token: "${tokenId}") {
    publicKey
    nonce
    zkappUri
    zkappState
    permissions {
      editState
      send
      receive
      setDelegate
      setPermissions
      setVerificationKey
      setZkappUri
      editSequenceState
      setTokenSymbol
      incrementNonce
      setVotingFor
    }
    receiptChainHash
    balance { total }
    delegateAccount { publicKey }
    sequenceEvents
    token
    tokenSymbol
    verificationKey {
      verificationKey
    }
  }
}
`;
function parseFetchedAccount({ publicKey, nonce, zkappState, balance, permissions, delegateAccount, receiptChainHash, sequenceEvents, token, tokenSymbol, verificationKey }) {
  return {
    publicKey: publicKey !== void 0 ? PublicKey.fromBase58(publicKey) : void 0,
    nonce: nonce !== void 0 ? UInt32.from(nonce) : void 0,
    balance: balance && UInt64.from(balance.total),
    appState: (zkappState && zkappState.map(Field)) ?? void 0,
    permissions: permissions && Object.fromEntries(Object.entries(permissions).map(([k, v]) => [
      k,
      Permissions.fromString(v)
    ])),
    sequenceState: sequenceEvents != void 0 ? Field(sequenceEvents[0]) : void 0,
    receiptChainHash: receiptChainHash !== void 0 ? ReceiptChainHash.fromBase58(receiptChainHash) : void 0,
    delegate: delegateAccount && PublicKey.fromBase58(delegateAccount.publicKey),
    tokenId: token !== void 0 ? Ledger.fieldOfBase58(token) : void 0,
    tokenSymbol: tokenSymbol !== void 0 ? tokenSymbol : void 0,
    verificationKey: verificationKey?.verificationKey
  };
}
function stringifyAccount(account) {
  let { publicKey, nonce, balance, zkapp, tokenId, tokenSymbol } = account;
  return {
    publicKey: publicKey instanceof PublicKey ? publicKey.toBase58() : publicKey,
    nonce: nonce?.toString(),
    zkappState: zkapp?.appState.map((s) => s.toString()) ?? Array(ZkappStateLength).fill("0"),
    balance: { total: balance?.toString() ?? "0" },
    token: tokenId ?? TokenId3.toBase58(TokenId3.default),
    tokenSymbol: tokenSymbol ?? ""
  };
}
var accountCache = {};
var networkCache = {};
var accountsToFetch = {};
var networksToFetch = {};
var cacheExpiry = 10 * 60 * 1e3;
function markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint) {
  let publicKeyBase58 = publicKey.toBase58();
  let tokenBase58 = TokenId3.toBase58(tokenId);
  accountsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    graphqlEndpoint
  };
}
function markNetworkToBeFetched(graphqlEndpoint) {
  networksToFetch[graphqlEndpoint] = { graphqlEndpoint };
}
async function fetchMissingData(graphqlEndpoint) {
  let expired = Date.now() - cacheExpiry;
  let accounts = Object.entries(accountsToFetch).filter(([key, account]) => {
    if (account.graphqlEndpoint !== graphqlEndpoint)
      return false;
    let cachedAccount = accountCache[key];
    return cachedAccount === void 0 || cachedAccount.timestamp < expired;
  });
  let promises = accounts.map(async ([key, { publicKey, tokenId }]) => {
    let response = await fetchAccountInternal({ publicKey, tokenId }, graphqlEndpoint);
    if (response.error === void 0)
      delete accountsToFetch[key];
  });
  let network = Object.entries(networksToFetch).find(([key, network2]) => {
    if (network2.graphqlEndpoint !== graphqlEndpoint)
      return;
    let cachedNetwork = networkCache[key];
    return cachedNetwork === void 0 || cachedNetwork.timestamp < expired;
  });
  if (network !== void 0) {
    promises.push((async () => {
      try {
        await fetchLastBlock(graphqlEndpoint);
        delete networksToFetch[network[0]];
      } catch {
      }
    })());
  }
  await Promise.all(promises);
}
function getCachedAccount(publicKey, tokenId, graphqlEndpoint = defaultGraphqlEndpoint) {
  let account = accountCache[`${publicKey.toBase58()};${TokenId3.toBase58(tokenId)};${graphqlEndpoint}`]?.account;
  if (account !== void 0)
    return parseFetchedAccount(account);
}
function getCachedNetwork(graphqlEndpoint = defaultGraphqlEndpoint) {
  return networkCache[graphqlEndpoint]?.network;
}
function addCachedAccount(account, graphqlEndpoint = defaultGraphqlEndpoint) {
  addCachedAccountInternal(stringifyAccount(account), graphqlEndpoint);
}
function addCachedAccountInternal(account, graphqlEndpoint) {
  accountCache[`${account.publicKey};${account.token};${graphqlEndpoint}`] = {
    account,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
async function fetchLastBlock(graphqlEndpoint = defaultGraphqlEndpoint) {
  let [resp, error] = await makeGraphqlRequest(lastBlockQuery, graphqlEndpoint);
  if (error)
    throw Error(error.statusText);
  let lastBlock = resp?.data?.bestChain?.[0];
  if (lastBlock === void 0) {
    throw Error("Failed to fetch latest network state.");
  }
  let network = parseFetchedBlock(lastBlock);
  networkCache[graphqlEndpoint] = {
    network,
    graphqlEndpoint,
    timestamp: Date.now()
  };
  return network;
}
var lastBlockQuery = `{
  bestChain(maxLength: 1) {
    protocolState {
      blockchainState {
        snarkedLedgerHash
        stagedLedgerHash
        date
        utcDate
        stagedLedgerProofEmitted
      }
      previousStateHash
      consensusState {
        blockHeight
        slotSinceGenesis
        slot
        nextEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        stakingEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        epochCount
        minWindowDensity
        totalCurrency
        epoch
      }
    }
  }
}`;
function parseFetchedBlock({ protocolState: { blockchainState: { snarkedLedgerHash, utcDate }, consensusState: { blockHeight, minWindowDensity, totalCurrency, slot, slotSinceGenesis, nextEpochData, stakingEpochData } } }) {
  return {
    snarkedLedgerHash: LedgerHash.fromBase58(snarkedLedgerHash),
    timestamp: UInt64.from(utcDate),
    blockchainLength: UInt32.from(blockHeight),
    minWindowDensity: UInt32.from(minWindowDensity),
    totalCurrency: UInt64.from(totalCurrency),
    globalSlotSinceHardFork: UInt32.from(slot),
    globalSlotSinceGenesis: UInt32.from(slotSinceGenesis),
    nextEpochData: parseEpochData(nextEpochData),
    stakingEpochData: parseEpochData(stakingEpochData)
  };
}
function parseEpochData({ ledger: { hash, totalCurrency }, seed, startCheckpoint, lockCheckpoint, epochLength }) {
  return {
    ledger: {
      hash: LedgerHash.fromBase58(hash),
      totalCurrency: UInt64.from(totalCurrency)
    },
    seed: EpochSeed.fromBase58(seed),
    startCheckpoint: StateHash.fromBase58(startCheckpoint),
    lockCheckpoint: StateHash.fromBase58(lockCheckpoint),
    epochLength: UInt32.from(epochLength)
  };
}
function sendZkapp(json, graphqlEndpoint = defaultGraphqlEndpoint, { timeout = defaultTimeout } = {}) {
  return makeGraphqlRequest(sendZkappQuery(json), graphqlEndpoint, {
    timeout
  });
}
function sendZkappQuery(json) {
  return `mutation {
  sendZkapp(input: {
    zkappCommand: ${removeJsonQuotes(json)}
  }) {
    zkapp {
      hash
      id
      failureReason {
        failures
        index
      }
      zkappCommand {
        memo
        feePayer {
          body {
            publicKey
          }
        }
        accountUpdates {
          body {
            publicKey
            useFullCommitment
            incrementNonce
          }
        }
      }
    }
  }
}
`;
}
function removeJsonQuotes(json) {
  let cleaned = JSON.stringify(JSON.parse(json), null, 2);
  return cleaned.replace(/\"(\S+)\"\s*:/gm, "$1:");
}
async function makeGraphqlRequest(query, graphqlEndpoint = defaultGraphqlEndpoint, { timeout = defaultTimeout } = {}) {
  if (graphqlEndpoint === "none")
    throw Error("Should have made a graphql request, but don't know to which endpoint. Try calling `setGraphqlEndpoint` first.");
  const controller = new AbortController();
  const timer = setTimeout(() => {
    controller.abort();
  }, timeout);
  try {
    let body = JSON.stringify({ operationName: null, query, variables: {} });
    let response = await fetch(graphqlEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body,
      signal: controller.signal
    });
    return await checkResponseStatus(response);
  } catch (error) {
    clearTimeout(timer);
    return [void 0, inferError(error)];
  }
}
async function checkResponseStatus(response) {
  if (response.ok) {
    return [await response.json(), void 0];
  } else {
    return [
      void 0,
      {
        statusCode: response.status,
        statusText: response.statusText
      }
    ];
  }
}
function inferError(error) {
  let errorMessage = JSON.stringify(error);
  if (error instanceof AbortSignal) {
    return { statusCode: 408, statusText: `Request Timeout: ${errorMessage}` };
  } else {
    return {
      statusCode: 500,
      statusText: `Unknown Error: ${errorMessage}`
    };
  }
}

// dist/node/lib/zkapp.js
var import_tslib3 = __toModule(require("tslib"));

// dist/node/lib/state.js
function State() {
  return createState();
}
function state(stateType) {
  return function(target, key, _descriptor) {
    const ZkappClass = target.constructor;
    if (reservedPropNames.has(key)) {
      throw Error(`Property name ${key} is reserved.`);
    }
    let sc = smartContracts.get(ZkappClass);
    if (sc === void 0) {
      sc = { states: [], layout: void 0 };
      smartContracts.set(ZkappClass, sc);
    }
    sc.states.push([key, stateType]);
    Object.defineProperty(target, key, {
      get() {
        return this._?.[key];
      },
      set(v) {
        if (v._contract !== void 0)
          throw Error("A State should only be assigned once to a SmartContract");
        if (this._?.[key])
          throw Error("A @state should only be assigned once");
        v._contract = {
          key,
          stateType,
          instance: this,
          class: ZkappClass,
          wasConstrained: false,
          wasRead: false,
          cachedVariable: void 0
        };
        (this._ ?? (this._ = {}))[key] = v;
      }
    });
  };
}
function declareState(SmartContract2, states) {
  for (let key in states) {
    let CircuitValue2 = states[key];
    state(CircuitValue2)(SmartContract2.prototype, key);
  }
}
function createState() {
  return {
    _contract: void 0,
    set(state2) {
      if (this._contract === void 0)
        throw Error("set can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state2);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i2) => {
        AccountUpdate2.setValue(accountUpdate.body.update.appState[layout.offset + i2], x);
      });
    },
    assertEquals(state2) {
      if (this._contract === void 0)
        throw Error("assertEquals can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state2);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i2) => {
        AccountUpdate2.assertEquals(accountUpdate.body.preconditions.account.state[layout.offset + i2], x);
      });
      this._contract.wasConstrained = true;
    },
    assertNothing() {
      if (this._contract === void 0)
        throw Error("assertNothing can only be called when the State is assigned to a SmartContract @state.");
      this._contract.wasConstrained = true;
    },
    get() {
      if (this._contract === void 0)
        throw Error("get can only be called when the State is assigned to a SmartContract @state.");
      if (this._contract.cachedVariable !== void 0 && inCheckedComputation()) {
        this._contract.wasRead = true;
        return this._contract.cachedVariable;
      }
      let layout = getLayoutPosition(this._contract);
      let contract = this._contract;
      let inProver_ = inProver();
      let stateFieldsType = circuitArray(Field, layout.length);
      let stateAsFields = Circuit.witness(stateFieldsType, () => {
        let account;
        try {
          account = getAccount(contract.instance.address, contract.instance.self.body.tokenId);
        } catch (err) {
          if (inProver_) {
            throw err;
          }
          throw Error(`${contract.key}.get() failed, either:
1. We can't find this zkapp account in the ledger
2. Because the zkapp account was not found in the cache. Try calling \`await fetchAccount(zkappAddress)\` first.
If none of these are the case, then please reach out on Discord at #zkapp-developers and/or open an issue to tell us!`);
        }
        if (account.appState === void 0) {
          return Array(layout.length).fill(Field(0));
        } else {
          let stateAsFields2 = [];
          for (let i2 = 0; i2 < layout.length; ++i2) {
            stateAsFields2.push(account.appState[layout.offset + i2]);
          }
          return stateAsFields2;
        }
      });
      let state2 = this._contract.stateType.fromFields(stateAsFields);
      this._contract.stateType.check?.(state2);
      this._contract.wasRead = true;
      this._contract.cachedVariable = state2;
      return state2;
    },
    async fetch() {
      if (this._contract === void 0)
        throw Error("fetch can only be called when the State is assigned to a SmartContract @state.");
      if (currentTransaction.has())
        throw Error("fetch is not intended to be called inside a transaction block.");
      let layout = getLayoutPosition(this._contract);
      let address = this._contract.instance.address;
      let { account } = await fetchAccount({
        publicKey: address,
        tokenId: TokenId3.toBase58(TokenId3.default)
      });
      if (account === void 0)
        return void 0;
      let stateAsFields;
      if (account.appState === void 0) {
        stateAsFields = Array(layout.length).fill(Field(0));
      } else {
        stateAsFields = [];
        for (let i2 = 0; i2 < layout.length; i2++) {
          stateAsFields.push(account.appState[layout.offset + i2]);
        }
      }
      return this._contract.stateType.fromFields(stateAsFields);
    }
  };
}
function getLayoutPosition({ key, class: contractClass }) {
  let layout = getLayout(contractClass);
  let stateLayout = layout.get(key);
  if (stateLayout === void 0) {
    throw new Error(`state ${key} not found`);
  }
  return stateLayout;
}
function getLayout(scClass) {
  let sc = smartContracts.get(scClass);
  if (sc === void 0)
    throw Error("bug");
  if (sc.layout === void 0) {
    let layout = new Map();
    sc.layout = layout;
    let offset = 0;
    sc.states.forEach(([key, stateType]) => {
      let length = stateType.sizeInFields();
      layout.set(key, { offset, length });
      offset += length;
    });
  }
  return sc.layout;
}
var smartContracts = new WeakMap();
var reservedPropNames = new Set(["_methods", "_"]);
function assertStatePrecondition(sc) {
  try {
    for (let [key, context] of getStateContexts(sc)) {
      if (!context?.wasRead || context.wasConstrained)
        continue;
      let errorMessage = `You used \`this.${key}.get()\` without adding a precondition that links it to the actual on-chain state.
Consider adding this line to your code:
this.${key}.assertEquals(this.${key}.get());`;
      throw Error(errorMessage);
    }
  } finally {
    cleanStatePrecondition(sc);
  }
}
function cleanStatePrecondition(sc) {
  for (let [, context] of getStateContexts(sc)) {
    if (context === void 0)
      continue;
    context.wasRead = false;
    context.wasConstrained = false;
    context.cachedVariable = void 0;
  }
}
function getStateContexts(sc) {
  let scClass = sc.constructor;
  let scInfo = smartContracts.get(scClass);
  if (scInfo === void 0)
    return [];
  return scInfo.states.map(([key]) => [key, sc[key]?._contract]);
}

// dist/node/lib/zkapp.js
var _SmartContract_executionState;
var reservedPropNames2 = new Set(["_methods", "_"]);
function method(target, methodName, descriptor) {
  const ZkappClass = target.constructor;
  if (reservedPropNames2.has(methodName)) {
    throw Error(`Property name ${methodName} is reserved.`);
  }
  if (typeof target[methodName] !== "function") {
    throw Error(`@method decorator was applied to \`${methodName}\`, which is not a function.`);
  }
  let paramTypes = Reflect.getMetadata("design:paramtypes", target, methodName);
  let returnType = Reflect.getMetadata("design:returntype", target, methodName);
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = ZkappPublicInput;
  SelfProof2.tag = () => ZkappClass;
  let internalMethodEntry = sortMethodArguments(ZkappClass.name, methodName, paramTypes, SelfProof2);
  let methodEntry = sortMethodArguments(ZkappClass.name, methodName, [PublicKey, Field, ...paramTypes], SelfProof2);
  if (isAsFields(returnType)) {
    internalMethodEntry.returnType = returnType;
    methodEntry.returnType = returnType;
  }
  ZkappClass._methods ?? (ZkappClass._methods = []);
  ZkappClass._methods.push(methodEntry);
  ZkappClass._maxProofsVerified ?? (ZkappClass._maxProofsVerified = 0);
  ZkappClass._maxProofsVerified = Math.max(ZkappClass._maxProofsVerified, methodEntry.proofArgs.length);
  let func = descriptor.value;
  descriptor.value = wrapMethod(func, ZkappClass, internalMethodEntry);
}
function wrapMethod(method2, ZkappClass, methodIntf) {
  let methodName = methodIntf.methodName;
  return function wrappedMethod(...actualArgs) {
    cleanStatePrecondition(this);
    if (!smartContractContext.has() || smartContractContext()?.isCallback) {
      return smartContractContext.runWith(smartContractContext() ?? {
        this: this,
        methodCallDepth: 0,
        isCallback: false,
        selfUpdate: selfAccountUpdate(this, methodName)
      }, (context) => {
        if (inCheckedComputation() && !context.isCallback) {
          let [, result2] = currentTransaction.runWith({
            sender: void 0,
            accountUpdates: [],
            fetchMode: inProver() ? "cached" : "test",
            isFinalRunOutsideCircuit: false,
            numberOfRuns: void 0
          }, () => {
            let publicInput = actualArgs.shift();
            let accountUpdate = this.self;
            let blindingValue = Circuit.witness(Field, getBlindingValue);
            let context2 = memoizationContext() ?? {
              memoized: [],
              currentIndex: 0
            };
            let [, result3] = memoizationContext.runWith({ ...context2, blindingValue }, () => method2.apply(this, actualArgs));
            let callDataFields = computeCallData(methodIntf, actualArgs, result3, blindingValue);
            accountUpdate.body.callData = Poseidon2.hash(callDataFields);
            accountUpdate.body.authorizationKind.isSigned = Bool(false);
            accountUpdate.body.authorizationKind.isProved = Bool(true);
            let callerContext = Circuit.witness(CallForest.callerContextType, () => {
              let { accountUpdate: accountUpdate2 } = zkAppProver.getData();
              return CallForest.computeCallerContext(accountUpdate2);
            });
            CallForest.addCallers([accountUpdate], callerContext);
            if (DEBUG_PUBLIC_INPUT_CHECK) {
              Circuit.asProver(() => {
                function diff(prover, input) {
                  delete prover.id;
                  delete prover.callDepth;
                  delete input.id;
                  delete input.callDepth;
                  if (JSON.stringify(prover) !== JSON.stringify(input)) {
                    console.log("transaction:", ZkappCommand2.toPretty(transaction2));
                    console.log("index", index);
                    console.log("inconsistent account updates:");
                    console.log("update created by the prover:");
                    console.log(prover);
                    console.log("update created in transaction block:");
                    console.log(input);
                  }
                }
                function diffRecursive(prover, input) {
                  diff(prover.toPretty(), input.toPretty());
                  let nChildren = input.children.accountUpdates.length;
                  for (let i2 = 0; i2 < nChildren; i2++) {
                    let inputChild = input.children.accountUpdates[i2];
                    let child = prover.children.accountUpdates[i2];
                    if (!inputChild || !child)
                      return;
                    diffRecursive(child, inputChild);
                  }
                }
                let { accountUpdate: inputUpdate, transaction: transaction2, index } = zkAppProver.getData();
                diffRecursive(accountUpdate, inputUpdate);
              });
            }
            checkPublicInput(publicInput, accountUpdate);
            assertPreconditionInvariants(accountUpdate);
            cleanPreconditionsCache(accountUpdate);
            assertStatePrecondition(this);
            return result3;
          });
          return result2;
        } else if (!currentTransaction.has()) {
          let result2 = method2.apply(this, actualArgs);
          assertPreconditionInvariants(this.self);
          cleanPreconditionsCache(this.self);
          assertStatePrecondition(this);
          return result2;
        } else {
          let accountUpdate = context.selfUpdate;
          if (!context.isCallback) {
            currentTransaction()?.accountUpdates.push(accountUpdate);
          }
          let clonedArgs = cloneCircuitValue(actualArgs);
          let blindingValue = getBlindingValue();
          let [{ memoized }, result2] = memoizationContext.runWith({
            memoized: [],
            currentIndex: 0,
            blindingValue
          }, () => method2.apply(this, actualArgs));
          assertStatePrecondition(this);
          let callDataFields = computeCallData(methodIntf, actualArgs, result2, blindingValue);
          accountUpdate.body.callData = Poseidon2.hash(callDataFields);
          if (!Authorization.hasAny(accountUpdate)) {
            Authorization.setLazyProof(accountUpdate, {
              methodName: methodIntf.methodName,
              args: clonedArgs,
              previousProofs: getPreviousProofsForProver(actualArgs, methodIntf),
              ZkappClass,
              memoized,
              blindingValue
            });
          }
          return result2;
        }
      })[1];
    }
    let parentAccountUpdate = smartContractContext.get().this.self;
    let methodCallDepth = smartContractContext.get().methodCallDepth;
    let [, result] = smartContractContext.runWith({
      this: this,
      methodCallDepth: methodCallDepth + 1,
      isCallback: false,
      selfUpdate: selfAccountUpdate(this, methodName)
    }, () => {
      let { returnType } = methodIntf;
      let noReturnTypeError = `To return a result from ${methodIntf.methodName}() inside another zkApp, you need to declare the return type.
This can be done by annotating the type at the end of the function signature. For example:

@method ${methodIntf.methodName}(): Field {
  // ...
}

Note: Only types built out of \`Field\` are valid return types. This includes snarkyjs primitive types and custom CircuitValues.`;
      if (ZkappClass._methodMetadata[methodIntf.methodName]?.hasReturn && returnType === void 0) {
        throw Error(noReturnTypeError);
      }
      let blindingValue = getBlindingValue();
      let runCalledContract = () => {
        let constantArgs = methodArgumentsToConstant(methodIntf, actualArgs);
        let constantBlindingValue = blindingValue.toConstant();
        let accountUpdate2 = this.self;
        accountUpdate2.body.callDepth = parentAccountUpdate.body.callDepth + 1;
        accountUpdate2.parent = parentAccountUpdate;
        let [{ memoized }, result3] = memoizationContext.runWith({
          memoized: [],
          currentIndex: 0,
          blindingValue: constantBlindingValue
        }, () => method2.apply(this, constantArgs));
        assertStatePrecondition(this);
        if (result3 !== void 0) {
          if (returnType === void 0) {
            throw Error(noReturnTypeError);
          } else {
            result3 = toConstant(returnType, result3);
          }
        }
        let callDataFields2 = computeCallData(methodIntf, constantArgs, result3, constantBlindingValue);
        accountUpdate2.body.callData = Poseidon.hash(callDataFields2, false);
        if (!Authorization.hasAny(accountUpdate2)) {
          Authorization.setLazyProof(accountUpdate2, {
            methodName: methodIntf.methodName,
            args: constantArgs,
            previousProofs: getPreviousProofsForProver(constantArgs, methodIntf),
            ZkappClass,
            memoized,
            blindingValue: constantBlindingValue
          });
        }
        return { accountUpdate: accountUpdate2, result: result3 ?? null };
      };
      let { accountUpdate, result: result2 } = methodCallDepth === 0 ? AccountUpdate2.witness(returnType ?? provable(null), runCalledContract, { skipCheck: true }) : runCalledContract();
      accountUpdate.body.callDepth = parentAccountUpdate.body.callDepth + 1;
      accountUpdate.parent = parentAccountUpdate;
      accountUpdate.children.callsType = { type: "Witness" };
      parentAccountUpdate.children.accountUpdates.push(accountUpdate);
      accountUpdate.body.publicKey.assertEquals(this.address);
      accountUpdate.body.tokenId.assertEquals(this.self.body.tokenId);
      let callDataFields = computeCallData(methodIntf, actualArgs, result2, blindingValue);
      let callData = Poseidon2.hash(callDataFields);
      accountUpdate.body.callData.assertEquals(callData);
      let isTopLevel = Circuit.witness(Bool, () => {
        let isProverUpdate = inProver() && zkAppProver.getData().accountUpdate.body.publicKey.equals(parentAccountUpdate.body.publicKey).toBoolean();
        let parentCallDepth = isProverUpdate ? zkAppProver.getData().accountUpdate.body.callDepth : CallForest.computeCallDepth(parentAccountUpdate);
        return Bool(parentCallDepth === 0);
      });
      parentAccountUpdate.isDelegateCall = isTopLevel.not();
      return result2;
    });
    return result;
  };
}
function checkPublicInput({ accountUpdate, calls }, self) {
  let otherInput = self.toPublicInput();
  accountUpdate.assertEquals(otherInput.accountUpdate);
  calls.assertEquals(otherInput.calls);
}
function computeCallData(methodIntf, argumentValues, returnValue, blindingValue) {
  let { returnType, methodName } = methodIntf;
  let args = methodArgumentTypesAndValues(methodIntf, argumentValues);
  let argSizesAndFields = args.map(({ type, value }) => [
    Field(type.sizeInFields()),
    ...type.toFields(value)
  ]);
  let totalArgSize = Field(args.map(({ type }) => type.sizeInFields()).reduce((s, t) => s + t, 0));
  let totalArgFields = argSizesAndFields.flat();
  let returnSize = Field(returnType?.sizeInFields() ?? 0);
  let returnFields = returnType?.toFields(returnValue) ?? [];
  let methodNameFields = stringToFields(methodName);
  return [
    totalArgSize,
    ...totalArgFields,
    returnSize,
    ...returnFields,
    ...methodNameFields,
    blindingValue
  ];
}
var Callback = class extends GenericArgument {
  constructor(self) {
    super();
    Object.assign(this, self);
  }
  static create(instance, methodName, args) {
    let ZkappClass = instance.constructor;
    let methodIntf_ = (ZkappClass._methods ?? []).find((i2) => i2.methodName === methodName);
    if (methodIntf_ === void 0)
      throw Error(`Callback: could not find method ${ZkappClass.name}.${String(methodName)}`);
    let methodIntf = {
      ...methodIntf_,
      returnType: methodIntf_.returnType ?? provable(null)
    };
    let result = instance[methodName](...args);
    let accountUpdate = instance.self;
    let callback = new Callback({
      instance,
      methodIntf,
      args,
      result,
      accountUpdate,
      isEmpty: false
    });
    return callback;
  }
};
var SmartContract = class {
  constructor(address, tokenId) {
    _SmartContract_executionState.set(this, void 0);
    this.events = {};
    this.address = address;
    this.tokenId = tokenId ?? TokenId3.default;
    Object.defineProperty(this, "reducer", {
      set(reducer) {
        var _a;
        ((_a = this)._ ?? (_a._ = {})).reducer = reducer;
      },
      get() {
        return getReducer(this);
      }
    });
  }
  static Proof() {
    var _a;
    let Contract = this;
    return _a = class extends Proof {
    }, _a.publicInputType = ZkappPublicInput, _a.tag = () => Contract, _a;
  }
  static async compile() {
    let methodIntfs = this._methods ?? [];
    let methods = methodIntfs.map(({ methodName }) => {
      return (publicInput, publicKey, tokenId, ...args) => {
        let instance = new this(publicKey, tokenId);
        instance[methodName](publicInput, ...args);
      };
    });
    this.analyzeMethods();
    let { getVerificationKeyArtifact, provers, verify: verify2 } = compileProgram(ZkappPublicInput, methodIntfs, methods, this);
    let verificationKey = getVerificationKeyArtifact();
    this._provers = provers;
    this._verificationKey = {
      data: verificationKey.data,
      hash: Field(verificationKey.hash)
    };
    return { verificationKey, provers, verify: verify2 };
  }
  static digest() {
    let methodData = this.analyzeMethods();
    let hash = Poseidon.hash(Object.values(methodData).map((d) => Field(BigInt("0x" + d.digest))), false);
    return hash.toBigInt().toString(16);
  }
  deploy({ verificationKey, zkappKey } = {}) {
    let accountUpdate = this.newSelf();
    verificationKey ?? (verificationKey = this.constructor._verificationKey);
    if (verificationKey !== void 0) {
      let { hash: hash_, data } = verificationKey;
      let hash = typeof hash_ === "string" ? Field(hash_) : hash_;
      this.setValue(accountUpdate.update.verificationKey, { hash, data });
    }
    this.setValue(accountUpdate.update.permissions, Permissions.default());
    accountUpdate.sign(zkappKey);
    AccountUpdate2.attachToTransaction(accountUpdate);
    let shouldInit = !hasAccount(this.address) || getAccount(this.address).verificationKey === void 0;
    if (!shouldInit)
      return;
    if (zkappKey)
      this.init(zkappKey);
    else
      this.init();
    let initUpdate = this.self;
    (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, {
      transactionId: (0, import_tslib3.__classPrivateFieldGet)(this, _SmartContract_executionState, "f").transactionId,
      accountUpdate
    }, "f");
    let isFirstRun = currentTransaction()?.numberOfRuns === 0;
    if (!isFirstRun)
      return;
    Circuit.asProver(() => {
      if (initUpdate.update.appState.some(({ isSome }) => !isSome.toBoolean())) {
        console.warn(`WARNING: the \`init()\` method was called without overwriting the entire state. This means that your zkApp will lack
the \`provedState === true\` status which certifies that the current state was verifiably produced by proofs (and not arbitrarily set by the zkApp developer).
To make sure the entire state is reset, consider adding this line to the beginning of your \`init()\` method:
super.init();
`);
      }
    });
  }
  init(zkappKey) {
    zkappKey?.toPublicKey().assertEquals(this.address);
    let accountUpdate = this.self;
    for (let i2 = 0; i2 < ZkappStateLength; i2++) {
      AccountUpdate2.setValue(accountUpdate.body.update.appState[i2], Field(0));
    }
    AccountUpdate2.attachToTransaction(accountUpdate);
  }
  requireSignature() {
    this.self.requireSignature();
  }
  sign(zkappKey) {
    this.self.sign(zkappKey);
  }
  skipAuthorization() {
    Authorization.setLazyNone(this.self);
  }
  get self() {
    let inTransaction = currentTransaction.has();
    let inSmartContract = smartContractContext.has();
    if (!inTransaction && !inSmartContract) {
      return selfAccountUpdate(this);
    }
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    if (inSmartContract && smartContractContext.get().this === this) {
      let accountUpdate2 = smartContractContext.get().selfUpdate;
      (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, { accountUpdate: accountUpdate2, transactionId }, "f");
      return accountUpdate2;
    }
    let executionState = (0, import_tslib3.__classPrivateFieldGet)(this, _SmartContract_executionState, "f");
    if (executionState !== void 0 && executionState.transactionId === transactionId) {
      return executionState.accountUpdate;
    }
    let accountUpdate = selfAccountUpdate(this);
    (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  newSelf() {
    let inTransaction = currentTransaction.has();
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    let accountUpdate = selfAccountUpdate(this);
    (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  get account() {
    return this.self.account;
  }
  get network() {
    return this.self.network;
  }
  get token() {
    return this.self.token();
  }
  approve(updateOrCallback, layout) {
    let accountUpdate = updateOrCallback instanceof AccountUpdate2 ? updateOrCallback : Circuit.witness(AccountUpdate2, () => updateOrCallback.accountUpdate);
    this.self.approve(accountUpdate, layout);
    return accountUpdate;
  }
  send(args) {
    return this.self.send(args);
  }
  get tokenSymbol() {
    return this.self.tokenSymbol;
  }
  get balance() {
    return this.self.balance;
  }
  emitEvent(type, event) {
    let accountUpdate = this.self;
    let eventTypes = Object.keys(this.events);
    if (eventTypes.length === 0)
      throw Error(`emitEvent: You are trying to emit an event without having declared the types of your events.
Make sure to add a property \`events\` on ${this.constructor.name}, for example: 
class ${this.constructor.name} extends SmartContract {
  events = { 'my-event': Field }
}`);
    let eventNumber = eventTypes.sort().indexOf(type);
    if (eventNumber === -1)
      throw Error(`emitEvent: Unknown event type "${type}". The declared event types are: ${eventTypes.join(", ")}.`);
    let eventType = this.events[type];
    let eventFields;
    if (eventTypes.length === 1) {
      eventFields = eventType.toFields(event);
    } else {
      eventFields = [Field(eventNumber), ...eventType.toFields(event)];
    }
    accountUpdate.body.events = Events.pushEvent(accountUpdate.body.events, eventFields);
  }
  async fetchEvents(start = UInt32.from(0), end) {
    let events = (await fetchEvents(this.address, this.self.body.tokenId)).filter((el) => {
      let slot = UInt32.from(el.slot);
      return end === void 0 ? start.lte(slot).toBoolean() : start.lte(slot).toBoolean() && slot.lte(end).toBoolean();
    }).map((el) => el.events).flat();
    let sortedEventTypes = Object.keys(this.events).sort();
    return events.map((event) => {
      if (sortedEventTypes.length === 1) {
        let type = sortedEventTypes[0];
        return {
          type,
          event: this.events[type].fromFields(event.map((f) => Field(f)))
        };
      } else {
        let type = sortedEventTypes[event[0]];
        event.shift();
        return {
          type,
          event: this.events[type].fromFields(event.map((f) => Field(f)))
        };
      }
    });
  }
  static runOutsideCircuit(run) {
    if (currentTransaction()?.isFinalRunOutsideCircuit || inProver())
      Circuit.asProver(run);
  }
  static analyzeMethods() {
    let methodMetaData = this._methodMetadata;
    let ZkappClass = this;
    let methodIntfs = ZkappClass._methods ?? [];
    if (!methodIntfs.every((m) => m.methodName in methodMetaData) && !inAnalyze()) {
      if (snarkContext.get().inRunAndCheck) {
        let err = new Error("Can not analyze methods inside Circuit.runAndCheck, because this creates a circuit nested in another circuit");
        err.bootstrap = () => ZkappClass.analyzeMethods();
        throw err;
      }
      for (let methodIntf of methodIntfs) {
        let accountUpdate;
        let { rows, digest, result } = analyzeMethod(ZkappPublicInput, methodIntf, (publicInput, publicKey, tokenId, ...args) => {
          let instance = new ZkappClass(publicKey, tokenId);
          let result2 = instance[methodIntf.methodName](publicInput, ...args);
          accountUpdate = (0, import_tslib3.__classPrivateFieldGet)(instance, _SmartContract_executionState, "f").accountUpdate;
          return result2;
        });
        ZkappClass._methodMetadata[methodIntf.methodName] = {
          sequenceEvents: accountUpdate.body.sequenceEvents.data.length,
          rows,
          digest,
          hasReturn: result !== void 0
        };
      }
    }
    return ZkappClass._methodMetadata;
  }
  setValue(maybeValue, value) {
    AccountUpdate2.setValue(maybeValue, value);
  }
  setPermissions(permissions) {
    this.setValue(this.self.update.permissions, permissions);
  }
};
_SmartContract_executionState = new WeakMap();
SmartContract._methodMetadata = {};
function getReducer(contract) {
  var _a;
  let reducer = ((_a = contract)._ ?? (_a._ = {})).reducer;
  if (reducer === void 0)
    throw Error(`You are trying to use a reducer without having declared its type.
Make sure to add a property \`reducer\` on ${contract.constructor.name}, for example:
class ${contract.constructor.name} extends SmartContract {
  reducer = { actionType: Field };
}`);
  return {
    dispatch(action) {
      let accountUpdate = contract.self;
      let eventFields = reducer.actionType.toFields(action);
      accountUpdate.body.sequenceEvents = SequenceEvents.pushEvent(accountUpdate.body.sequenceEvents, eventFields);
    },
    reduce(actionLists, stateType, reduce, { state: state2, actionsHash }, { maxTransactionsWithActions = 32 } = {}) {
      if (actionLists.length > maxTransactionsWithActions) {
        throw Error(`reducer.reduce: Exceeded the maximum number of lists of actions, ${maxTransactionsWithActions}.
Use the optional \`maxTransactionsWithActions\` argument to increase this number.`);
      }
      let methodData = contract.constructor.analyzeMethods();
      let possibleActionsPerTransaction = [
        ...new Set(Object.values(methodData).map((o) => o.sequenceEvents)).add(0)
      ].sort((x, y) => x - y);
      let possibleActionTypes = possibleActionsPerTransaction.map((n) => circuitArray(reducer.actionType, n));
      for (let i2 = 0; i2 < maxTransactionsWithActions; i2++) {
        let actions = i2 < actionLists.length ? actionLists[i2] : [];
        let length = actions.length;
        let lengths = possibleActionsPerTransaction.map((n) => Circuit.witness(Bool, () => Bool(length === n)));
        let actionss = possibleActionsPerTransaction.map((n, i3) => {
          let type = possibleActionTypes[i3];
          return Circuit.witness(type, () => length === n ? actions : emptyValue(type));
        });
        let eventsHashes = actionss.map((actions2) => {
          let events = actions2.map((u) => reducer.actionType.toFields(u));
          return SequenceEvents.hash(events);
        });
        let eventsHash = Circuit.switch(lengths, Field, eventsHashes);
        let newActionsHash = SequenceEvents.updateSequenceState(actionsHash, eventsHash);
        let isEmpty = lengths[0];
        actionsHash = Circuit.if(isEmpty, actionsHash, newActionsHash);
        let newStates = actionss.map((actions2) => {
          let newState = Circuit.witness(stateType, () => {
            let { toFields, fromFields, toAuxiliary } = stateType;
            return fromFields(toFields(state2).map((x) => x.toConstant()), toAuxiliary(state2));
          });
          Circuit.assertEqual(newState, state2);
          actions2.forEach((action) => {
            newState = reduce(newState, action);
          });
          return newState;
        });
        state2 = Circuit.switch(lengths, stateType, newStates);
      }
      contract.account.sequenceState.assertEquals(actionsHash);
      return { state: state2, actionsHash };
    },
    getActions({ fromActionHash, endActionHash }) {
      let actionsForAccount = [];
      Circuit.asProver(() => {
        fromActionHash = fromActionHash?.equals(SequenceEvents.emptySequenceState()).toBoolean() ? void 0 : fromActionHash;
        let start = fromActionHash ? Ledger.fieldToBase58(fromActionHash) : void 0;
        let end = endActionHash ? Ledger.fieldToBase58(endActionHash) : void 0;
        let actions = getActions(contract.address, contract.self.tokenId);
        let startIndex = start ? actions.findIndex((e) => e.hash === start) + 1 : 0;
        let endIndex = end ? actions.findIndex((e) => e.hash === end) + 1 : void 0;
        actionsForAccount = actions.slice(startIndex, endIndex === 0 ? void 0 : endIndex).map((event) => event.actions.map((action) => reducer.actionType.fromFields(action.map((fieldAsString) => Field(fieldAsString)))));
      });
      return actionsForAccount;
    }
  };
}
var VerificationKey = class extends Struct({
  ...provable({ data: String, hash: Field }),
  toJSON({ data }) {
    return data;
  }
}) {
};
function selfAccountUpdate(zkapp, methodName) {
  let body = Body.keepAll(zkapp.address);
  if (zkapp.tokenId) {
    body.tokenId = zkapp.tokenId;
    body.caller = zkapp.tokenId;
  }
  let update = new AccountUpdate2(body, {}, true);
  update.label = methodName ? `${zkapp.constructor.name}.${methodName}()` : `${zkapp.constructor.name}, no method`;
  return update;
}
async function deploy(SmartContract2, { zkappKey, verificationKey, initialBalance, feePayer, tokenId = TokenId3.default }) {
  let address = zkappKey.toPublicKey();
  let feePayerKey = feePayer instanceof PrivateKey ? feePayer : feePayer?.feePayerKey;
  let tx = await transaction(feePayer, () => {
    if (initialBalance !== void 0) {
      if (feePayerKey === void 0)
        throw Error(`When using the optional initialBalance argument, you need to also supply the fee payer's private key as part of the \`feePayer\` argument, to sign the initial balance funding.`);
      let amount = UInt64.from(String(initialBalance)).add(accountCreationFee());
      let feePayerAddress = feePayerKey.toPublicKey();
      let accountUpdate = AccountUpdate2.defaultAccountUpdate(feePayerAddress);
      accountUpdate.body.useFullCommitment = Bool(true);
      accountUpdate.balance.subInPlace(amount);
      currentTransaction()?.accountUpdates.push(accountUpdate);
    }
    let zkapp = new SmartContract2(address, tokenId);
    zkapp.deploy({ verificationKey, zkappKey });
    if (initialBalance !== void 0) {
      let amount = UInt64.from(String(initialBalance));
      zkapp.self.balance.addInPlace(amount);
    }
  });
  return tx.sign().toJSON();
}
function Account2(address, tokenId) {
  if (smartContractContext.has()) {
    return AccountUpdate2.create(address, tokenId).account;
  } else {
    return AccountUpdate2.defaultAccountUpdate(address, tokenId).account;
  }
}
function signFeePayer(transactionJson, feePayerKey, { transactionFee = 0, feePayerNonce = void 0, memo: feePayerMemo = void 0 }) {
  let zkappCommand = JSON.parse(transactionJson);
  if (typeof feePayerKey === "string")
    feePayerKey = PrivateKey.fromBase58(feePayerKey);
  let senderAddress = feePayerKey.toPublicKey();
  if (feePayerNonce === void 0) {
    let senderAccount = getAccount(senderAddress, TokenId3.default);
    feePayerNonce = senderAccount.nonce.toString();
  }
  if (feePayerMemo)
    zkappCommand.memo = Ledger.memoToBase58(feePayerMemo);
  zkappCommand.feePayer.body.nonce = `${feePayerNonce}`;
  zkappCommand.feePayer.body.publicKey = Ledger.publicKeyToString(senderAddress);
  zkappCommand.feePayer.body.fee = `${transactionFee}`;
  return signJsonTransaction(JSON.stringify(zkappCommand), feePayerKey);
}
function declareMethods(SmartContract2, methodArguments) {
  for (let key in methodArguments) {
    let argumentTypes = methodArguments[key];
    let target = SmartContract2.prototype;
    Reflect.metadata("design:paramtypes", argumentTypes)(target, key);
    let descriptor = Object.getOwnPropertyDescriptor(target, key);
    method(SmartContract2.prototype, key, descriptor);
    Object.defineProperty(target, key, descriptor);
  }
}
var Reducer = Object.defineProperty(function(reducer) {
  return reducer;
}, "initialActionsHash", { get: SequenceEvents.emptySequenceState });
var DEBUG_PUBLIC_INPUT_CHECK = false;

// dist/node/lib/errors.js
var ErrorHandlers = {
  Invalid_fee_excess({ transaction: { accountUpdates }, isFeePayer, accountCreationFee: accountCreationFee2 }) {
    if (isFeePayer)
      return;
    let balances = accountUpdates.map(({ body }) => {
      if (body.tokenId.equals(TokenId3.default).toBoolean()) {
        return Number(Int64.fromObject(body.balanceChange).toString()) * 1e-9;
      }
    });
    let sum = balances.reduce((a = 0, b = 0) => a + b) ?? 0;
    return `Invalid fee excess.
This means that balance changes in your transaction do not sum up to the amount of fees needed.
Here's the list of balance changes:

${balances.map((balance, i2) => {
      return `Account update #${i2 + 1}) ${balance === void 0 ? "not a MINA account" : `${balance.toFixed(2)} MINA`}`;
    }).join(`
`)}

Total change: ${sum.toFixed(2)} MINA

If there are no new accounts created in your transaction, then this sum should be equal to 0.00 MINA.
If you are creating new accounts -- by updating accounts that didn't exist yet --
then keep in mind the ${(Number(accountCreationFee2) * 1e-9).toFixed(2)} MINA account creation fee, and make sure that the sum equals
${(-Number(accountCreationFee2) * 1e-9).toFixed(2)} times the number of newly created accounts.`;
  }
};
function invalidTransactionError(transaction2, errors, additionalContext) {
  let errorMessages = [];
  let rawErrors = JSON.stringify(errors);
  let errorsForFeePayer = errors[0];
  for (let [error] of errorsForFeePayer) {
    let message = ErrorHandlers[error]?.({
      transaction: transaction2,
      accountUpdateIndex: NaN,
      isFeePayer: true,
      ...additionalContext
    });
    if (message)
      errorMessages.push(message);
  }
  let n = transaction2.accountUpdates.length;
  for (let i2 = 0; i2 < n; i2++) {
    let errorsForUpdate = errors[i2 + 1];
    for (let [error] of errorsForUpdate) {
      let message = ErrorHandlers[error]?.({
        transaction: transaction2,
        accountUpdateIndex: i2,
        isFeePayer: false,
        ...additionalContext
      });
      if (message)
        errorMessages.push(message);
    }
  }
  if (errorMessages.length > 1) {
    return [
      "There were multiple errors when applying your transaction:",
      ...errorMessages.map((msg, i2) => `${i2 + 1}.) ${msg}`),
      `Raw list of errors: ${rawErrors}`
    ].join("\n\n");
  }
  if (errorMessages.length === 1) {
    return `${errorMessages[0]}

Raw list of errors: ${rawErrors}`;
  }
  return rawErrors;
}

// dist/node/lib/mina.js
var currentTransaction = Context.create();
function reportGetAccountError(publicKey, tokenId) {
  if (tokenId === TokenId3.toBase58(TokenId3.default)) {
    return `getAccount: Could not find account for public key ${publicKey}`;
  } else {
    return `getAccount: Could not find account for public key ${publicKey} with the tokenId ${tokenId}`;
  }
}
function createTransaction(feePayer, f, numberOfRuns, { fetchMode = "cached", isFinalRunOutsideCircuit = true, proofsEnabled = true } = {}) {
  if (currentTransaction.has()) {
    throw new Error("Cannot start new transaction within another transaction");
  }
  let feePayerKey = feePayer instanceof PrivateKey ? feePayer : feePayer?.feePayerKey;
  let fee = feePayer instanceof PrivateKey ? void 0 : feePayer?.fee;
  let memo = feePayer instanceof PrivateKey ? "" : feePayer?.memo ?? "";
  let nonce = feePayer instanceof PrivateKey ? void 0 : feePayer?.nonce;
  let transactionId = currentTransaction.enter({
    sender: feePayerKey?.toPublicKey(),
    accountUpdates: [],
    fetchMode,
    isFinalRunOutsideCircuit,
    numberOfRuns
  });
  try {
    let err;
    while (true) {
      if (err !== void 0)
        err.bootstrap();
      try {
        snarkContext.runWith({ inRunAndCheck: true }, () => Circuit.runAndCheck(f));
        break;
      } catch (err_) {
        if (err_?.bootstrap)
          err = err_;
        else
          throw err_;
      }
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let accountUpdates = currentTransaction.get().accountUpdates;
  CallForest.addCallers(accountUpdates);
  accountUpdates = CallForest.toFlatList(accountUpdates);
  try {
    for (let accountUpdate of accountUpdates) {
      assertPreconditionInvariants(accountUpdate);
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let feePayerAccountUpdate;
  if (feePayerKey !== void 0) {
    let senderAddress = feePayerKey.toPublicKey();
    let nonce_;
    let senderAccount = getAccount(senderAddress, TokenId3.default);
    if (nonce === void 0) {
      nonce_ = senderAccount.nonce;
    } else {
      nonce_ = UInt32.from(nonce);
      senderAccount.nonce = nonce_;
      addCachedAccount({
        nonce: senderAccount.nonce,
        publicKey: senderAccount.publicKey,
        tokenId: senderAccount.tokenId.toString(),
        balance: senderAccount.balance,
        zkapp: {
          appState: senderAccount.appState ?? []
        }
      });
    }
    feePayerAccountUpdate = AccountUpdate2.defaultFeePayer(senderAddress, feePayerKey, nonce_);
    if (fee !== void 0) {
      feePayerAccountUpdate.body.fee = fee instanceof UInt64 ? fee : UInt64.from(String(fee));
    }
  } else {
    feePayerAccountUpdate = AccountUpdate2.dummyFeePayer();
  }
  let transaction2 = {
    accountUpdates,
    feePayer: feePayerAccountUpdate,
    memo
  };
  currentTransaction.leave(transactionId);
  let self = {
    transaction: transaction2,
    sign(additionalKeys) {
      self.transaction = addMissingSignatures(self.transaction, additionalKeys);
      return self;
    },
    async prove() {
      let { zkappCommand, proofs } = await addMissingProofs(self.transaction, {
        proofsEnabled
      });
      self.transaction = zkappCommand;
      return proofs;
    },
    toJSON() {
      let json = zkappCommandToJson(self.transaction);
      return JSON.stringify(json);
    },
    toPretty() {
      return ZkappCommand2.toPretty(self.transaction);
    },
    toGraphqlQuery() {
      return sendZkappQuery(self.toJSON());
    },
    async send() {
      return await sendTransaction(self);
    }
  };
  return self;
}
var defaultAccountCreationFee = 1e9;
function LocalBlockchain({ accountCreationFee: accountCreationFee2 = defaultAccountCreationFee, proofsEnabled = true } = {}) {
  const msPerSlot = 3 * 60 * 1e3;
  const startTime = new Date().valueOf();
  const ledger = Ledger.create([]);
  let networkState = defaultNetworkState();
  function addAccount(pk, balance) {
    ledger.addAccount(pk, balance);
  }
  let testAccounts = [];
  for (let i2 = 0; i2 < 10; ++i2) {
    let MINA = 10n ** 9n;
    const largeValue = 1000n * MINA;
    const k = PrivateKey.random();
    const pk = k.toPublicKey();
    addAccount(pk, largeValue.toString());
    testAccounts.push({ privateKey: k, publicKey: pk });
  }
  const events = {};
  const actions = {};
  return {
    accountCreationFee: () => UInt64.from(accountCreationFee2),
    currentSlot() {
      return UInt32.from(Math.ceil((new Date().valueOf() - startTime) / msPerSlot));
    },
    hasAccount(publicKey, tokenId = TokenId3.default) {
      return !!ledger.getAccount(publicKey, tokenId);
    },
    getAccount(publicKey, tokenId = TokenId3.default) {
      let ledgerAccount = ledger.getAccount(publicKey, tokenId);
      if (ledgerAccount == void 0) {
        throw new Error(reportGetAccountError(publicKey.toBase58(), TokenId3.toBase58(tokenId)));
      } else {
        let { timing } = ledgerAccount;
        return {
          publicKey,
          tokenId,
          balance: new UInt64(ledgerAccount.balance.value),
          nonce: new UInt32(ledgerAccount.nonce.value),
          appState: ledgerAccount.zkapp?.appState ?? Array(ZkappStateLength).fill(Field(0)),
          tokenSymbol: ledgerAccount.tokenSymbol,
          receiptChainHash: ledgerAccount.receiptChainHash,
          provedState: Bool(ledgerAccount.zkapp?.provedState ?? false),
          delegate: ledgerAccount.delegate && PublicKey.from(ledgerAccount.delegate),
          sequenceState: ledgerAccount.zkapp?.sequenceState[0] ?? SequenceEvents.emptySequenceState(),
          permissions: Permissions.fromJSON(ledgerAccount.permissions),
          timing: {
            isTimed: timing.isTimed,
            initialMinimumBalance: UInt64.fromObject(timing.initialMinimumBalance),
            cliffAmount: UInt64.fromObject(timing.cliffAmount),
            cliffTime: UInt32.fromObject(timing.cliffTime),
            vestingPeriod: UInt32.fromObject(timing.vestingPeriod),
            vestingIncrement: UInt64.fromObject(timing.vestingIncrement)
          }
        };
      }
    },
    getNetworkState() {
      return networkState;
    },
    async sendTransaction(txn) {
      txn.sign();
      let commitments = Ledger.transactionCommitments(JSON.stringify(zkappCommandToJson(txn.transaction)));
      for (const update of txn.transaction.accountUpdates) {
        let account = ledger.getAccount(update.body.publicKey, update.body.tokenId);
        if (account) {
          await verifyAccountUpdate(account, update, commitments, proofsEnabled);
        }
      }
      let zkappCommandJson = zkappCommandToJson(txn.transaction);
      try {
        ledger.applyJsonTransaction(JSON.stringify(zkappCommandJson), String(accountCreationFee2), JSON.stringify(networkState));
      } catch (err) {
        try {
          let errors = JSON.parse(err.message);
          err.message = invalidTransactionError(txn.transaction, errors, {
            accountCreationFee: accountCreationFee2
          });
        } finally {
          throw err;
        }
      }
      zkappCommandJson.accountUpdates.forEach((p2) => {
        let addr = p2.body.publicKey;
        let tokenId = p2.body.tokenId;
        if (events[addr] === void 0) {
          events[addr] = {};
        }
        if (p2.body.events.length > 0) {
          if (events[addr][tokenId] === void 0) {
            events[addr][tokenId] = [];
          }
          events[addr][tokenId].push({
            events: p2.body.events,
            slot: networkState.globalSlotSinceHardFork.toString()
          });
        }
        let n = actions[addr]?.[tokenId]?.length ?? 1;
        let sequenceState = actions?.[addr]?.[tokenId]?.[n - 1]?.hash;
        let latestActionsHash = sequenceState === void 0 ? SequenceEvents.emptySequenceState() : Ledger.fieldOfBase58(sequenceState);
        let actionList = p2.body.sequenceEvents;
        let eventsHash = SequenceEvents.hash(actionList.map((e) => e.map((f) => Field(f))));
        if (actions[addr] === void 0) {
          actions[addr] = {};
        }
        if (p2.body.sequenceEvents.length > 0) {
          latestActionsHash = SequenceEvents.updateSequenceState(latestActionsHash, eventsHash);
          if (actions[addr][tokenId] === void 0) {
            actions[addr][tokenId] = [];
          }
          actions[addr][tokenId].push({
            actions: actionList,
            hash: Ledger.fieldToBase58(latestActionsHash)
          });
        }
      });
      return {
        wait: async () => {
        },
        hash: () => {
          const message = "Txn Hash retrieving is not supported for LocalBlockchain.";
          console.log(message);
          return message;
        }
      };
    },
    async transaction(sender, f) {
      let tx = createTransaction(sender, f, 0, {
        isFinalRunOutsideCircuit: false,
        proofsEnabled
      });
      let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
      return createTransaction(sender, f, 1, {
        isFinalRunOutsideCircuit: !hasProofs,
        proofsEnabled
      });
    },
    applyJsonTransaction(json) {
      return ledger.applyJsonTransaction(json, String(accountCreationFee2), JSON.stringify(networkState));
    },
    async fetchEvents(publicKey, tokenId = TokenId3.default) {
      return events?.[publicKey.toBase58()]?.[TokenId3.toBase58(tokenId)] ?? [];
    },
    getActions(publicKey, tokenId = TokenId3.default) {
      return actions?.[publicKey.toBase58()]?.[Ledger.fieldToBase58(tokenId)] ?? [];
    },
    addAccount,
    testAccounts,
    setTimestamp(ms) {
      networkState.timestamp = ms;
    },
    setGlobalSlot(slot) {
      networkState.globalSlotSinceGenesis = UInt32.from(slot);
      let difference = networkState.globalSlotSinceGenesis.sub(slot);
      networkState.globalSlotSinceHardFork = networkState.globalSlotSinceHardFork.add(difference);
    },
    incrementGlobalSlot(increment) {
      networkState.globalSlotSinceGenesis = networkState.globalSlotSinceGenesis.add(increment);
      networkState.globalSlotSinceHardFork = networkState.globalSlotSinceHardFork.add(increment);
    },
    setBlockchainLength(height) {
      networkState.blockchainLength = height;
    },
    setTotalCurrency(currency) {
      networkState.totalCurrency = currency;
    },
    setProofsEnabled(newProofsEnabled) {
      proofsEnabled = newProofsEnabled;
    }
  };
}
function Network2(graphqlEndpoint) {
  let accountCreationFee2 = UInt64.from(defaultAccountCreationFee);
  setGraphqlEndpoint(graphqlEndpoint);
  return {
    accountCreationFee: () => accountCreationFee2,
    currentSlot() {
      throw Error("currentSlot() is not implemented yet for remote blockchains.");
    },
    hasAccount(publicKey, tokenId = TokenId3.default) {
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        return !!getCachedAccount(publicKey, tokenId, graphqlEndpoint);
      }
      return false;
    },
    getAccount(publicKey, tokenId = TokenId3.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint);
        let account = getCachedAccount(publicKey, tokenId, graphqlEndpoint);
        return account ?? dummyAccount(publicKey);
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let account = getCachedAccount(publicKey, tokenId, graphqlEndpoint);
        if (account !== void 0)
          return account;
      }
      throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId3.toBase58(tokenId))}
Graphql endpoint: ${graphqlEndpoint}`);
    },
    getNetworkState() {
      if (currentTransaction()?.fetchMode === "test") {
        markNetworkToBeFetched(graphqlEndpoint);
        let network = getCachedNetwork(graphqlEndpoint);
        return network ?? defaultNetworkState();
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let network = getCachedNetwork(graphqlEndpoint);
        if (network !== void 0)
          return network;
      }
      throw Error(`getNetworkState: Could not fetch network state from graphql endpoint ${graphqlEndpoint}`);
    },
    async sendTransaction(txn) {
      txn.sign();
      let [response, error] = await sendZkapp(txn.toJSON());
      let errors;
      if (error === void 0) {
        if (response.data === null && response.errors?.length > 0) {
          console.log("got graphql errors", JSON.stringify(response.errors, null, 2));
          errors = response.errors;
        }
      } else {
        console.log("got fetch error", error);
        errors = [error];
      }
      return {
        data: response?.data,
        errors,
        async wait() {
          console.log("Info: waiting for inclusion in a block is not implemented yet.");
        },
        hash() {
          return response?.data?.sendZkapp?.zkapp?.hash;
        }
      };
    },
    async transaction(sender, f) {
      let tx = createTransaction(sender, f, 0, {
        fetchMode: "test",
        isFinalRunOutsideCircuit: false
      });
      await fetchMissingData(graphqlEndpoint);
      let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
      return createTransaction(sender, f, 1, {
        fetchMode: "cached",
        isFinalRunOutsideCircuit: !hasProofs
      });
    },
    async fetchEvents() {
      throw Error("fetchEvents() is not implemented yet for remote blockchains.");
    },
    getActions() {
      throw Error("fetchEvents() is not implemented yet for remote blockchains.");
    }
  };
}
function BerkeleyQANet(graphqlEndpoint) {
  return Network2(graphqlEndpoint);
}
var activeInstance = {
  accountCreationFee: () => UInt64.from(defaultAccountCreationFee),
  currentSlot: () => {
    throw new Error("must call Mina.setActiveInstance first");
  },
  hasAccount(publicKey, tokenId = TokenId3.default) {
    if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
      return !!getCachedAccount(publicKey, tokenId, defaultGraphqlEndpoint);
    }
    return false;
  },
  getAccount(publicKey, tokenId = TokenId3.default) {
    if (currentTransaction()?.fetchMode === "test") {
      markAccountToBeFetched(publicKey, tokenId, defaultGraphqlEndpoint);
      return dummyAccount(publicKey);
    }
    if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
      let account = getCachedAccount(publicKey, tokenId, defaultGraphqlEndpoint);
      if (account === void 0)
        throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId3.toBase58(tokenId))}

Either call Mina.setActiveInstance first or explicitly add the account with addCachedAccount`);
      return account;
    }
    throw new Error("must call Mina.setActiveInstance first");
  },
  getNetworkState() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  sendTransaction() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  async transaction(sender, f) {
    return createTransaction(sender, f, 0);
  },
  fetchEvents() {
    throw Error("must call Mina.setActiveInstance first");
  },
  getActions() {
    throw Error("must call Mina.setActiveInstance first");
  }
};
function setActiveInstance(m) {
  activeInstance = m;
}
function transaction(senderOrF, fOrUndefined) {
  let sender;
  let f;
  if (fOrUndefined !== void 0) {
    sender = senderOrF;
    f = fOrUndefined;
  } else {
    sender = void 0;
    f = senderOrF;
  }
  return activeInstance.transaction(sender, f);
}
function currentSlot() {
  return activeInstance.currentSlot();
}
function getAccount(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId);
}
function hasAccount(publicKey, tokenId) {
  return activeInstance.hasAccount(publicKey, tokenId);
}
function getNetworkState() {
  return activeInstance.getNetworkState();
}
function getBalance(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId).balance;
}
function accountCreationFee() {
  return activeInstance.accountCreationFee();
}
async function sendTransaction(txn) {
  return await activeInstance.sendTransaction(txn);
}
async function fetchEvents(publicKey, tokenId) {
  return await activeInstance.fetchEvents(publicKey, tokenId);
}
function getActions(publicKey, tokenId) {
  return activeInstance.getActions(publicKey, tokenId);
}
function dummyAccount(pubkey) {
  return {
    balance: UInt64.zero,
    nonce: UInt32.zero,
    publicKey: pubkey ?? PublicKey.empty(),
    tokenId: TokenId3.default,
    appState: Array(ZkappStateLength).fill(Field(0)),
    tokenSymbol: "",
    provedState: Bool(false),
    receiptChainHash: emptyReceiptChainHash(),
    delegate: void 0,
    sequenceState: SequenceEvents.emptySequenceState()
  };
}
function defaultNetworkState() {
  let epochData = {
    ledger: { hash: Field(0), totalCurrency: UInt64.zero },
    seed: Field(0),
    startCheckpoint: Field(0),
    lockCheckpoint: Field(0),
    epochLength: UInt32.zero
  };
  return {
    snarkedLedgerHash: Field(0),
    timestamp: UInt64.zero,
    blockchainLength: UInt32.zero,
    minWindowDensity: UInt32.zero,
    totalCurrency: UInt64.zero,
    globalSlotSinceHardFork: UInt32.zero,
    globalSlotSinceGenesis: UInt32.zero,
    stakingEpochData: epochData,
    nextEpochData: cloneCircuitValue(epochData)
  };
}
async function verifyAccountUpdate(account, accountUpdate, transactionCommitments, proofsEnabled) {
  let perm = account.permissions;
  let { commitment, fullCommitment } = transactionCommitments;
  function includesChange(val) {
    if (Array.isArray(val)) {
      return !val.every((v) => v === null);
    } else {
      return val != null;
    }
  }
  function permissionForUpdate(key) {
    switch (key) {
      case "appState":
        return perm.editState;
      case "delegate":
        return perm.setDelegate;
      case "verificationKey":
        return perm.setVerificationKey;
      case "permissions":
        return perm.setPermissions;
      case "zkappUri":
        return perm.setZkappUri;
      case "tokenSymbol":
        return perm.setTokenSymbol;
      case "timing":
        return "None";
      case "votingFor":
        return perm.setVotingFor;
      case "sequenceEvents":
        return perm.editSequenceState;
      case "incrementNonce":
        return perm.incrementNonce;
      case "send":
        return perm.send;
      case "receive":
        return perm.receive;
      default:
        throw Error(`Invalid permission for field ${key}: does not exist.`);
    }
  }
  const update = accountUpdate.toJSON().body.update;
  let errorTrace = "";
  let isValidProof = false;
  let isValidSignature = false;
  if (!proofsEnabled)
    isValidProof = true;
  if (accountUpdate.authorization.proof && proofsEnabled) {
    try {
      let publicInput = accountUpdate.toPublicInput();
      let publicInputFields = ZkappPublicInput.toFields(publicInput);
      const proof = SmartContract.Proof().fromJSON({
        maxProofsVerified: 2,
        proof: accountUpdate.authorization.proof,
        publicInput: publicInputFields.map((f) => f.toString())
      });
      let verificationKey = account.zkapp?.verificationKey?.data;
      isValidProof = await verify(proof.toJSON(), verificationKey);
      if (!isValidProof) {
        throw Error(`Invalid proof for account update
${JSON.stringify(update)}`);
      }
    } catch (error) {
      errorTrace += "\n\n" + error.message;
      isValidProof = false;
    }
  }
  if (accountUpdate.authorization.signature) {
    let txC = accountUpdate.body.useFullCommitment.toBoolean() ? fullCommitment : commitment;
    try {
      isValidSignature = Ledger.checkAccountUpdateSignature(JSON.stringify(accountUpdate.toJSON()), txC);
    } catch (error) {
      errorTrace += "\n\n" + error.message;
      isValidSignature = false;
    }
  }
  let verified = false;
  function checkPermission(p2, field) {
    if (p2 == "None")
      return;
    if (p2 == "Impossible") {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p2}'`);
    }
    if (p2 == "Signature" || p2 == "Either") {
      verified || (verified = isValidSignature);
    }
    if (p2 == "Proof" || p2 == "Either") {
      verified || (verified = isValidProof);
    }
    if (!verified) {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p2}', but the required authorization was not provided or is invalid.
        ${errorTrace != "" ? "Error trace: " + errorTrace : ""}`);
    }
  }
  Object.entries(update).forEach(([key, value]) => {
    if (includesChange(value)) {
      let p2 = permissionForUpdate(key);
      checkPermission(p2, key);
    }
  });
  if (accountUpdate.body.sequenceEvents.data.length > 0) {
    let p2 = permissionForUpdate("sequenceEvents");
    checkPermission(p2, "sequenceEvents");
  }
  if (accountUpdate.body.incrementNonce.toBoolean()) {
    let p2 = permissionForUpdate("incrementNonce");
    checkPermission(p2, "incrementNonce");
  }
  if (errorTrace && !verified) {
    throw Error(`One or more proofs were invalid and no other form of authorization was provided.
${errorTrace}`);
  }
}

// dist/node/lib/encryption.js
var encryption_exports = {};
__export(encryption_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
function encrypt(message, otherPublicKey) {
  let privateKey = Circuit.witness(Scalar, () => Scalar.random());
  let publicKey = Group.generator.scale(privateKey);
  let sharedSecret = otherPublicKey.toGroup().scale(privateKey);
  let sponge = new Poseidon2.Sponge();
  sponge.absorb(sharedSecret.x);
  let cipherText = [];
  for (let i2 = 0; i2 < message.length; i2++) {
    let keyStream = sponge.squeeze();
    let encryptedChunk = message[i2].add(keyStream);
    cipherText.push(encryptedChunk);
    if (i2 % 2 === 1)
      sponge.absorb(cipherText[i2 - 1]);
    if (i2 % 2 === 1 || i2 === message.length - 1)
      sponge.absorb(cipherText[i2]);
  }
  let authenticationTag = sponge.squeeze();
  cipherText.push(authenticationTag);
  return { publicKey, cipherText };
}
function decrypt({ publicKey, cipherText }, privateKey) {
  let sharedSecret = publicKey.scale(privateKey.s);
  let sponge = new Poseidon2.Sponge();
  sponge.absorb(sharedSecret.x);
  let authenticationTag = cipherText.pop();
  let message = [];
  for (let i2 = 0; i2 < cipherText.length; i2++) {
    let keyStream = sponge.squeeze();
    let messageChunk = cipherText[i2].sub(keyStream);
    message.push(messageChunk);
    if (i2 % 2 === 1)
      sponge.absorb(cipherText[i2 - 1]);
    if (i2 % 2 === 1 || i2 === cipherText.length - 1)
      sponge.absorb(cipherText[i2]);
  }
  sponge.squeeze().assertEquals(authenticationTag);
  return message;
}

// dist/node/lib/string.js
var import_tslib4 = __toModule(require("tslib"));
var DEFAULT_STRING_LENGTH = 128;
var Character = class extends CircuitValue {
  isNull() {
    return this.equals(NullCharacter());
  }
  toField() {
    return this.value;
  }
  toString() {
    const charCode = Number(this.value.toString());
    return String.fromCharCode(charCode);
  }
  static fromString(str) {
    const char = Field(str.charCodeAt(0));
    return new Character(char);
  }
  static check(c) {
    c.value.rangeCheckHelper(16).assertEquals(c.value);
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Field)
], Character.prototype, "value", void 0);
var CircuitString = class extends CircuitValue {
  constructor(values) {
    super(values);
  }
  static fromCharacters(chars) {
    return new CircuitString(fillWithNull(chars, this.maxLength));
  }
  maxLength() {
    return this.constructor.maxLength;
  }
  computeLengthAndMask() {
    let n = this.values.length;
    let length = Field(0);
    let mask = [];
    let wasntNullAlready = Bool(true);
    for (let i2 = 0; i2 < n; i2++) {
      let isNull = this.values[i2].isNull();
      mask[i2] = isNull.and(wasntNullAlready);
      wasntNullAlready = isNull.not().and(wasntNullAlready);
      length.add(wasntNullAlready.toField());
    }
    mask[n] = wasntNullAlready;
    this._length = length;
    this._mask = mask;
    return { mask, length };
  }
  lengthMask() {
    return this._mask ?? this.computeLengthAndMask().mask;
  }
  length() {
    return this._length ?? this.computeLengthAndMask().length;
  }
  append(str) {
    let n = this.maxLength();
    this.length().add(str.length()).assertLt(n);
    let chars = this.values;
    let otherChars = fillWithNull(str.values, n);
    let possibleResults = [];
    for (let length = 0; length < n + 1; length++) {
      possibleResults[length] = chars.slice(0, length).concat(otherChars.slice(0, n - length));
    }
    let result = [];
    let mask = this.lengthMask();
    for (let i2 = 0; i2 < n; i2++) {
      let possibleCharsAtI = possibleResults.map((r) => r[i2]);
      result[i2] = Circuit.switch(mask, Character, possibleCharsAtI);
    }
    return CircuitString.fromCharacters(result);
  }
  hash() {
    return Poseidon2.hash(this.values.map((x) => x.value));
  }
  substring(start, end) {
    return CircuitString.fromCharacters(this.values.slice(start, end));
  }
  toString() {
    return this.values.map((x) => x.toString()).join("").replace(/[^ -~]+/g, "");
  }
  static fromString(str) {
    if (str.length > this.maxLength) {
      throw Error("CircuitString.fromString: input string exceeds max length!");
    }
    let characters = str.split("").map((x) => Character.fromString(x));
    return CircuitString.fromCharacters(characters);
  }
};
CircuitString.maxLength = DEFAULT_STRING_LENGTH;
(0, import_tslib4.__decorate)([
  arrayProp(Character, DEFAULT_STRING_LENGTH),
  (0, import_tslib4.__metadata)("design:type", Array)
], CircuitString.prototype, "values", void 0);
var NullCharacter = () => new Character(Field(0));
function fillWithNull([...values], length) {
  let nullChar = NullCharacter();
  for (let i2 = values.length; i2 < length; i2++) {
    values[i2] = nullChar;
  }
  return values;
}

// dist/node/lib/merkle_tree.js
var MerkleTree = class {
  constructor(height) {
    this.height = height;
    this.nodes = {};
    this.zeroes = [Field(0)];
    for (let i2 = 1; i2 < height; i2++) {
      this.zeroes.push(Poseidon2.hash([this.zeroes[i2 - 1], this.zeroes[i2 - 1]]));
    }
  }
  getNode(level, index) {
    return this.nodes[level]?.[index.toString()] ?? this.zeroes[level];
  }
  getRoot() {
    return this.getNode(this.height - 1, 0n);
  }
  setNode(level, index, value) {
    var _a;
    ((_a = this.nodes)[level] ?? (_a[level] = {}))[index.toString()] = value;
  }
  setLeaf(index, leaf) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    this.setNode(0, index, leaf);
    let currIndex = index;
    for (let level = 1; level < this.height; level++) {
      currIndex /= 2n;
      const left = this.getNode(level - 1, currIndex * 2n);
      const right = this.getNode(level - 1, currIndex * 2n + 1n);
      this.setNode(level, currIndex, Poseidon2.hash([left, right]));
    }
  }
  getWitness(index) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    const witness = [];
    for (let level = 0; level < this.height - 1; level++) {
      const isLeft = index % 2n === 0n;
      const sibling = this.getNode(level, isLeft ? index + 1n : index - 1n);
      witness.push({ isLeft, sibling });
      index /= 2n;
    }
    return witness;
  }
  validate(index) {
    const path = this.getWitness(index);
    let hash = this.getNode(0, index);
    for (const node of path) {
      hash = Poseidon2.hash(node.isLeft ? [hash, node.sibling] : [node.sibling, hash]);
    }
    return hash.toString() === this.getRoot().toString();
  }
  fill(leaves) {
    leaves.forEach((value, index) => {
      this.setLeaf(BigInt(index), value);
    });
  }
  get leafCount() {
    return 2n ** BigInt(this.height - 1);
  }
};
var BaseMerkleWitness = class extends CircuitValue {
  constructor(witness) {
    super();
    let height = witness.length + 1;
    if (height !== this.height()) {
      throw Error(`Length of witness ${height}-1 doesn't match static tree height ${this.height()}.`);
    }
    this.path = witness.map((item) => item.sibling);
    this.isLeft = witness.map((item) => Bool(item.isLeft));
  }
  height() {
    return this.constructor.height;
  }
  calculateRoot(leaf) {
    let hash = leaf;
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      const left = Circuit.if(this.isLeft[i2 - 1], hash, this.path[i2 - 1]);
      const right = Circuit.if(this.isLeft[i2 - 1], this.path[i2 - 1], hash);
      hash = Poseidon2.hash([left, right]);
    }
    return hash;
  }
  calculateIndex() {
    let powerOfTwo = Field(1);
    let index = Field(0);
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      index = Circuit.if(this.isLeft[i2 - 1], index, index.add(powerOfTwo));
      powerOfTwo = powerOfTwo.mul(2);
    }
    return index;
  }
};
function MerkleWitness(height) {
  class MerkleWitness_ extends BaseMerkleWitness {
  }
  MerkleWitness_.height = height;
  arrayProp(Field, height - 1)(MerkleWitness_.prototype, "path");
  arrayProp(Bool, height - 1)(MerkleWitness_.prototype, "isLeft");
  return MerkleWitness_;
}

// dist/node/lib/merkle_map.js
var import_tslib5 = __toModule(require("tslib"));
var bits = 255;
var printDebugs = false;
var MerkleMap = class {
  constructor() {
    if (bits > 255) {
      throw Error("bits must be <= 255");
    }
    if (bits != 255) {
      console.warn("bits set to", bits + ". Should be set to 255 in production to avoid collisions");
    }
    this.tree = new MerkleTree(bits + 1);
  }
  _keyToIndex(key) {
    let keyBits = key.toBits().slice(0, bits).reverse().map((b) => b.toBoolean());
    let n = 0n;
    for (let i2 = 0; i2 < keyBits.length; i2++) {
      const b = keyBits[i2] ? 1 : 0;
      n += 2n ** BigInt(i2) * BigInt(b);
    }
    return n;
  }
  set(key, value) {
    const index = this._keyToIndex(key);
    this.tree.setLeaf(index, value);
  }
  get(key) {
    const index = this._keyToIndex(key);
    return this.tree.getNode(0, index);
  }
  getRoot() {
    return this.tree.getRoot();
  }
  getWitness(key) {
    const index = this._keyToIndex(key);
    class MyMerkleWitness extends MerkleWitness(bits + 1) {
    }
    const witness = new MyMerkleWitness(this.tree.getWitness(index));
    if (printDebugs) {
      console.log("witness bits", witness.isLeft.map((l) => l.toBoolean() ? "0" : "1").join(", "));
      console.log("key bits", key.toBits().slice(0, bits).map((l) => l.toBoolean() ? "1" : "0").join(", "));
    }
    return new MerkleMapWitness(witness.isLeft, witness.path);
  }
};
var MerkleMapWitness = class extends CircuitValue {
  constructor(isLefts, siblings) {
    super();
    this.isLefts = isLefts;
    this.siblings = siblings;
  }
  computeRootAndKey(value) {
    let hash = value;
    const isLeft = this.isLefts;
    const siblings = this.siblings;
    let key = Field(0);
    for (let i2 = 0; i2 < bits; i2++) {
      const left = Circuit.if(isLeft[i2], hash, siblings[i2]);
      const right = Circuit.if(isLeft[i2], siblings[i2], hash);
      hash = Poseidon2.hash([left, right]);
      const bit = Circuit.if(isLeft[i2], Field(0), Field(1));
      key = key.mul(2).add(bit);
    }
    return [hash, key];
  }
};
(0, import_tslib5.__decorate)([
  arrayProp(Bool, bits),
  (0, import_tslib5.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "isLefts", void 0);
(0, import_tslib5.__decorate)([
  arrayProp(Field, bits),
  (0, import_tslib5.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "siblings", void 0);

// dist/node/index.js
var Experimental_ = {
  Callback,
  createChildAccountUpdate,
  memoizeWitness,
  ZkProgram
};
var Experimental;
(function(Experimental2) {
  Experimental2.ZkProgram = Experimental_.ZkProgram;
  Experimental2.createChildAccountUpdate = Experimental_.createChildAccountUpdate;
  Experimental2.memoizeWitness = Experimental_.memoizeWitness;
  Experimental2.Callback = Experimental_.Callback;
})(Experimental || (Experimental = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  AccountUpdate,
  Bool,
  Character,
  Circuit,
  CircuitString,
  CircuitValue,
  Encoding,
  Encryption,
  Experimental,
  Field,
  Group,
  Int64,
  Ledger,
  MerkleMap,
  MerkleMapWitness,
  MerkleTree,
  MerkleWitness,
  Mina,
  Permissions,
  Poseidon,
  PrivateKey,
  Proof,
  PublicKey,
  Reducer,
  Scalar,
  SelfProof,
  Sign,
  Signature,
  SmartContract,
  State,
  Struct,
  Token,
  TokenSymbol,
  Types,
  UInt32,
  UInt64,
  VerificationKey,
  ZkappPublicInput,
  addCachedAccount,
  arrayProp,
  circuitMain,
  declareMethods,
  declareState,
  deploy,
  fetchAccount,
  fetchLastBlock,
  getSrs,
  isReady,
  matrixProp,
  method,
  prop,
  provable,
  provablePure,
  public_,
  recoverVerificationKey,
  sendZkapp,
  serializeVerificationKey,
  setGraphqlEndpoint,
  shutdown,
  signFeePayer,
  state,
  verify,
  zkappCommandToJson
});
